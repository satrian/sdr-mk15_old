   1              		.file	"uip.c"
  11              	.Ltext0:
  12              		.file 1 "uIP/uip/uip.c"
 74067              		.align	1
 74068              		.global	uip_setipid
 74070              	uip_setipid:
 74071              	.LFB0:
   1:uIP/uip/uip.c **** //#define DEBUG_PRINTF(...) /*printf(__VA_ARGS__)*/
   2:uIP/uip/uip.c **** //#define DEBUG_PRINTF(...) printf(__VA_ARGS__)
   3:uIP/uip/uip.c **** 
   4:uIP/uip/uip.c **** /**
   5:uIP/uip/uip.c ****  * \defgroup uip The uIP TCP/IP stack
   6:uIP/uip/uip.c ****  * @{
   7:uIP/uip/uip.c ****  *
   8:uIP/uip/uip.c ****  * uIP is an implementation of the TCP/IP protocol stack intended for
   9:uIP/uip/uip.c ****  * small 8-bit and 16-bit microcontrollers.
  10:uIP/uip/uip.c ****  *
  11:uIP/uip/uip.c ****  * uIP provides the necessary protocols for Internet communication,
  12:uIP/uip/uip.c ****  * with a very small code footprint and RAM requirements - the uIP
  13:uIP/uip/uip.c ****  * code size is on the order of a few kilobytes and RAM usage is on
  14:uIP/uip/uip.c ****  * the order of a few hundred bytes.
  15:uIP/uip/uip.c ****  */
  16:uIP/uip/uip.c **** 
  17:uIP/uip/uip.c **** /**
  18:uIP/uip/uip.c ****  * \file
  19:uIP/uip/uip.c ****  * The uIP TCP/IP stack code.
  20:uIP/uip/uip.c ****  * \author Adam Dunkels <adam@dunkels.com>
  21:uIP/uip/uip.c ****  */
  22:uIP/uip/uip.c **** 
  23:uIP/uip/uip.c **** /*
  24:uIP/uip/uip.c ****  * Copyright (c) 2001-2003, Adam Dunkels.
  25:uIP/uip/uip.c ****  * All rights reserved.
  26:uIP/uip/uip.c ****  *
  27:uIP/uip/uip.c ****  * Redistribution and use in source and binary forms, with or without
  28:uIP/uip/uip.c ****  * modification, are permitted provided that the following conditions
  29:uIP/uip/uip.c ****  * are met:
  30:uIP/uip/uip.c ****  * 1. Redistributions of source code must retain the above copyright
  31:uIP/uip/uip.c ****  *    notice, this list of conditions and the following disclaimer.
  32:uIP/uip/uip.c ****  * 2. Redistributions in binary form must reproduce the above copyright
  33:uIP/uip/uip.c ****  *    notice, this list of conditions and the following disclaimer in the
  34:uIP/uip/uip.c ****  *    documentation and/or other materials provided with the distribution.
  35:uIP/uip/uip.c ****  * 3. The name of the author may not be used to endorse or promote
  36:uIP/uip/uip.c ****  *    products derived from this software without specific prior
  37:uIP/uip/uip.c ****  *    written permission.
  38:uIP/uip/uip.c ****  *
  39:uIP/uip/uip.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  40:uIP/uip/uip.c ****  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  41:uIP/uip/uip.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  42:uIP/uip/uip.c ****  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  43:uIP/uip/uip.c ****  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  44:uIP/uip/uip.c ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  45:uIP/uip/uip.c ****  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  46:uIP/uip/uip.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  47:uIP/uip/uip.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  48:uIP/uip/uip.c ****  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  49:uIP/uip/uip.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  50:uIP/uip/uip.c ****  *
  51:uIP/uip/uip.c ****  * This file is part of the uIP TCP/IP stack.
  52:uIP/uip/uip.c ****  *
  53:uIP/uip/uip.c ****  * $Id: uip.c,v 1.65 2006/06/11 21:46:39 adam Exp $
  54:uIP/uip/uip.c ****  *
  55:uIP/uip/uip.c ****  */
  56:uIP/uip/uip.c **** 
  57:uIP/uip/uip.c **** /*
  58:uIP/uip/uip.c ****  * uIP is a small implementation of the IP, UDP and TCP protocols (as
  59:uIP/uip/uip.c ****  * well as some basic ICMP stuff). The implementation couples the IP,
  60:uIP/uip/uip.c ****  * UDP, TCP and the application layers very tightly. To keep the size
  61:uIP/uip/uip.c ****  * of the compiled code down, this code frequently uses the goto
  62:uIP/uip/uip.c ****  * statement. While it would be possible to break the uip_process()
  63:uIP/uip/uip.c ****  * function into many smaller functions, this would increase the code
  64:uIP/uip/uip.c ****  * size because of the overhead of parameter passing and the fact that
  65:uIP/uip/uip.c ****  * the optimier would not be as efficient.
  66:uIP/uip/uip.c ****  *
  67:uIP/uip/uip.c ****  * The principle is that we have a small buffer, called the uip_buf,
  68:uIP/uip/uip.c ****  * in which the device driver puts an incoming packet. The TCP/IP
  69:uIP/uip/uip.c ****  * stack parses the headers in the packet, and calls the
  70:uIP/uip/uip.c ****  * application. If the remote host has sent data to the application,
  71:uIP/uip/uip.c ****  * this data is present in the uip_buf and the application read the
  72:uIP/uip/uip.c ****  * data from there. It is up to the application to put this data into
  73:uIP/uip/uip.c ****  * a byte stream if needed. The application will not be fed with data
  74:uIP/uip/uip.c ****  * that is out of sequence.
  75:uIP/uip/uip.c ****  *
  76:uIP/uip/uip.c ****  * If the application whishes to send data to the peer, it should put
  77:uIP/uip/uip.c ****  * its data into the uip_buf. The uip_appdata pointer points to the
  78:uIP/uip/uip.c ****  * first available byte. The TCP/IP stack will calculate the
  79:uIP/uip/uip.c ****  * checksums, and fill in the necessary header fields and finally send
  80:uIP/uip/uip.c ****  * the packet back to the peer.
  81:uIP/uip/uip.c **** */
  82:uIP/uip/uip.c **** 
  83:uIP/uip/uip.c **** #include "uip.h"
  84:uIP/uip/uip.c **** #include "uipopt.h"
  85:uIP/uip/uip.c **** #include "uip_arch.h"
  86:uIP/uip/uip.c **** 
  87:uIP/uip/uip.c **** #if UIP_CONF_IPV6
  88:uIP/uip/uip.c **** #include "uip-neighbor.h"
  89:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
  90:uIP/uip/uip.c **** 
  91:uIP/uip/uip.c **** #include <string.h>
  92:uIP/uip/uip.c **** 
  93:uIP/uip/uip.c **** //#include "usart.h"
  94:uIP/uip/uip.c **** 
  95:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
  96:uIP/uip/uip.c **** /* Variable definitions. */
  97:uIP/uip/uip.c **** 
  98:uIP/uip/uip.c **** 
  99:uIP/uip/uip.c **** /* The IP address of this host. If it is defined to be fixed (by
 100:uIP/uip/uip.c ****    setting UIP_FIXEDADDR to 1 in uipopt.h), the address is set
 101:uIP/uip/uip.c ****    here. Otherwise, the address */
 102:uIP/uip/uip.c **** #if UIP_FIXEDADDR > 0
 103:uIP/uip/uip.c **** const uip_ipaddr_t uip_hostaddr =
 104:uIP/uip/uip.c ****   {HTONS((UIP_IPADDR0 << 8) | UIP_IPADDR1),
 105:uIP/uip/uip.c ****    HTONS((UIP_IPADDR2 << 8) | UIP_IPADDR3)};
 106:uIP/uip/uip.c **** const uip_ipaddr_t uip_draddr =
 107:uIP/uip/uip.c ****   {HTONS((UIP_DRIPADDR0 << 8) | UIP_DRIPADDR1),
 108:uIP/uip/uip.c ****    HTONS((UIP_DRIPADDR2 << 8) | UIP_DRIPADDR3)};
 109:uIP/uip/uip.c **** const uip_ipaddr_t uip_netmask =
 110:uIP/uip/uip.c ****   {HTONS((UIP_NETMASK0 << 8) | UIP_NETMASK1),
 111:uIP/uip/uip.c ****    HTONS((UIP_NETMASK2 << 8) | UIP_NETMASK3)};
 112:uIP/uip/uip.c **** #else
 113:uIP/uip/uip.c **** uip_ipaddr_t uip_hostaddr, uip_draddr, uip_netmask;
 114:uIP/uip/uip.c **** #endif /* UIP_FIXEDADDR */
 115:uIP/uip/uip.c **** 
 116:uIP/uip/uip.c **** static const uip_ipaddr_t all_ones_addr =
 117:uIP/uip/uip.c **** #if UIP_CONF_IPV6
 118:uIP/uip/uip.c ****   {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
 119:uIP/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 120:uIP/uip/uip.c ****   {0xffff,0xffff};
 121:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 122:uIP/uip/uip.c **** static const uip_ipaddr_t all_zeroes_addr =
 123:uIP/uip/uip.c **** #if UIP_CONF_IPV6
 124:uIP/uip/uip.c ****   {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000};
 125:uIP/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 126:uIP/uip/uip.c ****   {0x0000,0x0000};
 127:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 128:uIP/uip/uip.c **** 
 129:uIP/uip/uip.c **** 
 130:uIP/uip/uip.c **** #if UIP_FIXEDETHADDR
 131:uIP/uip/uip.c **** const struct uip_eth_addr uip_ethaddr = {{UIP_ETHADDR0,
 132:uIP/uip/uip.c **** 					  UIP_ETHADDR1,
 133:uIP/uip/uip.c **** 					  UIP_ETHADDR2,
 134:uIP/uip/uip.c **** 					  UIP_ETHADDR3,
 135:uIP/uip/uip.c **** 					  UIP_ETHADDR4,
 136:uIP/uip/uip.c **** 					  UIP_ETHADDR5}};
 137:uIP/uip/uip.c **** #else
 138:uIP/uip/uip.c **** struct uip_eth_addr uip_ethaddr = {{0,0,0,0,0,0}};
 139:uIP/uip/uip.c **** #endif
 140:uIP/uip/uip.c **** 
 141:uIP/uip/uip.c **** #ifndef UIP_CONF_EXTERNAL_BUFFER
 142:uIP/uip/uip.c **** u8_t uip_buf[UIP_BUFSIZE + 2];   /* The packet buffer that contains
 143:uIP/uip/uip.c **** 				    incoming packets. */
 144:uIP/uip/uip.c **** #endif /* UIP_CONF_EXTERNAL_BUFFER */
 145:uIP/uip/uip.c **** 
 146:uIP/uip/uip.c **** void *uip_appdata;               /* The uip_appdata pointer points to
 147:uIP/uip/uip.c **** 				    application data. */
 148:uIP/uip/uip.c **** void *uip_sappdata;              /* The uip_appdata pointer points to
 149:uIP/uip/uip.c **** 				    the application data which is to
 150:uIP/uip/uip.c **** 				    be sent. */
 151:uIP/uip/uip.c **** #if UIP_URGDATA > 0
 152:uIP/uip/uip.c **** void *uip_urgdata;               /* The uip_urgdata pointer points to
 153:uIP/uip/uip.c ****    				    urgent data (out-of-band data), if
 154:uIP/uip/uip.c ****    				    present. */
 155:uIP/uip/uip.c **** u16_t uip_urglen, uip_surglen;
 156:uIP/uip/uip.c **** #endif /* UIP_URGDATA > 0 */
 157:uIP/uip/uip.c **** 
 158:uIP/uip/uip.c **** u16_t uip_len, uip_slen;
 159:uIP/uip/uip.c ****                              /* The uip_len is either 8 or 16 bits,
 160:uIP/uip/uip.c **** 				depending on the maximum packet
 161:uIP/uip/uip.c **** 				size. */
 162:uIP/uip/uip.c **** 
 163:uIP/uip/uip.c **** volatile u8_t uip_flags;     /* The uip_flags variable is used for
 164:uIP/uip/uip.c **** 				communication between the TCP/IP stack
 165:uIP/uip/uip.c **** 				and the application program. */
 166:uIP/uip/uip.c **** struct uip_conn *uip_conn;   /* uip_conn always points to the current
 167:uIP/uip/uip.c **** 				connection. */
 168:uIP/uip/uip.c **** 
 169:uIP/uip/uip.c **** struct uip_conn uip_conns[UIP_CONNS];
 170:uIP/uip/uip.c ****                              /* The uip_conns array holds all TCP
 171:uIP/uip/uip.c **** 				connections. */
 172:uIP/uip/uip.c **** u16_t uip_listenports[UIP_LISTENPORTS];
 173:uIP/uip/uip.c ****                              /* The uip_listenports list all currently
 174:uIP/uip/uip.c **** 				listning ports. */
 175:uIP/uip/uip.c **** #if UIP_UDP
 176:uIP/uip/uip.c **** struct uip_udp_conn *uip_udp_conn;
 177:uIP/uip/uip.c **** struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
 178:uIP/uip/uip.c **** #endif /* UIP_UDP */
 179:uIP/uip/uip.c **** 
 180:uIP/uip/uip.c **** static u16_t ipid;           /* Ths ipid variable is an increasing
 181:uIP/uip/uip.c **** 				number that is used for the IP ID
 182:uIP/uip/uip.c **** 				field. */
 183:uIP/uip/uip.c **** 
 184:uIP/uip/uip.c **** void uip_setipid(u16_t id) { ipid = id; }
 74072              		.loc 1 184 0
 74073              		# args = 0, frame = 0, pretend = 0
 74074              		# frame_needed = 0, leaf_function = 1
 74075              		# uses_anonymous_args = 0
 74076              	.LVL0:
 74077              		.loc 1 184 0
 74078 0000 4828     		lda.w	r8, .LANCHOR0
 74079 0002 B00C     		st.h	r8[0], r12
 74080 0004 5EFC     		retal	r12
 74081 0006 00000000 		.cpool
 74081      0000
 74082              		.align	2
 74083              	.L3:
 74084              	.LFE0:
 74086              		.section	.text.uip_add32,"ax",@progbits
 74087              		.align	1
 74088              		.global	uip_add32
 74090              	uip_add32:
 74091              	.LFB1:
 185:uIP/uip/uip.c **** 
 186:uIP/uip/uip.c **** static u8_t iss[4];          /* The iss variable is used for the TCP
 187:uIP/uip/uip.c **** 				initial sequence number. */
 188:uIP/uip/uip.c **** 
 189:uIP/uip/uip.c **** #if UIP_ACTIVE_OPEN
 190:uIP/uip/uip.c **** static u16_t lastport;       /* Keeps track of the last port used for
 191:uIP/uip/uip.c **** 				a new connection. */
 192:uIP/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 193:uIP/uip/uip.c **** 
 194:uIP/uip/uip.c **** /* Temporary variables. */
 195:uIP/uip/uip.c **** u8_t uip_acc32[4];
 196:uIP/uip/uip.c **** static u8_t c, opt;
 197:uIP/uip/uip.c **** static u16_t tmp16;
 198:uIP/uip/uip.c **** 
 199:uIP/uip/uip.c **** /* Structures and definitions. */
 200:uIP/uip/uip.c **** #define TCP_FIN 0x01
 201:uIP/uip/uip.c **** #define TCP_SYN 0x02
 202:uIP/uip/uip.c **** #define TCP_RST 0x04
 203:uIP/uip/uip.c **** #define TCP_PSH 0x08
 204:uIP/uip/uip.c **** #define TCP_ACK 0x10
 205:uIP/uip/uip.c **** #define TCP_URG 0x20
 206:uIP/uip/uip.c **** #define TCP_CTL 0x3f
 207:uIP/uip/uip.c **** 
 208:uIP/uip/uip.c **** #define TCP_OPT_END     0   /* End of TCP options list */
 209:uIP/uip/uip.c **** #define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
 210:uIP/uip/uip.c **** #define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
 211:uIP/uip/uip.c **** 
 212:uIP/uip/uip.c **** #define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
 213:uIP/uip/uip.c **** 
 214:uIP/uip/uip.c **** #define ICMP_ECHO_REPLY 0
 215:uIP/uip/uip.c **** #define ICMP_ECHO       8
 216:uIP/uip/uip.c **** 
 217:uIP/uip/uip.c **** #define ICMP6_ECHO_REPLY             129
 218:uIP/uip/uip.c **** #define ICMP6_ECHO                   128
 219:uIP/uip/uip.c **** #define ICMP6_NEIGHBOR_SOLICITATION  135
 220:uIP/uip/uip.c **** #define ICMP6_NEIGHBOR_ADVERTISEMENT 136
 221:uIP/uip/uip.c **** 
 222:uIP/uip/uip.c **** #define ICMP6_FLAG_S (1 << 6)
 223:uIP/uip/uip.c **** 
 224:uIP/uip/uip.c **** #define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
 225:uIP/uip/uip.c **** #define ICMP6_OPTION_TARGET_LINK_ADDRESS 2
 226:uIP/uip/uip.c **** 
 227:uIP/uip/uip.c **** 
 228:uIP/uip/uip.c **** /* Macros. */
 229:uIP/uip/uip.c **** #define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
 230:uIP/uip/uip.c **** #define FBUF ((struct uip_tcpip_hdr *)&uip_reassbuf[0])
 231:uIP/uip/uip.c **** #define ICMPBUF ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
 232:uIP/uip/uip.c **** #define UDPBUF ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
 233:uIP/uip/uip.c **** 
 234:uIP/uip/uip.c **** 
 235:uIP/uip/uip.c **** #if UIP_STATISTICS == 1
 236:uIP/uip/uip.c **** struct uip_stats uip_stat;
 237:uIP/uip/uip.c **** #define UIP_STAT(s) s
 238:uIP/uip/uip.c **** #else
 239:uIP/uip/uip.c **** #define UIP_STAT(s)
 240:uIP/uip/uip.c **** #endif /* UIP_STATISTICS == 1 */
 241:uIP/uip/uip.c **** 
 242:uIP/uip/uip.c **** /*
 243:uIP/uip/uip.c **** #if UIP_LOGGING == 1
 244:uIP/uip/uip.c **** #include <stdio.h>
 245:uIP/uip/uip.c **** void uip_log(char *msg);
 246:uIP/uip/uip.c **** #define UIP_LOG(m) uip_log(m)
 247:uIP/uip/uip.c **** #else
 248:uIP/uip/uip.c **** #define UIP_LOG(m)
 249:uIP/uip/uip.c **** #endif // UIP_LOGGING == 1
 250:uIP/uip/uip.c **** */
 251:uIP/uip/uip.c **** 
 252:uIP/uip/uip.c **** #if ! UIP_ARCH_ADD32
 253:uIP/uip/uip.c **** void
 254:uIP/uip/uip.c **** uip_add32(u8_t *op32, u16_t op16)
 255:uIP/uip/uip.c **** {
 74092              		.loc 1 255 0
 74093              		# args = 0, frame = 0, pretend = 0
 74094              		# frame_needed = 0, leaf_function = 1
 74095              		# uses_anonymous_args = 0
 74096              	.LVL1:
 74097 0000 D401     		pushm	lr
 74098              	.LCFI0:
 256:uIP/uip/uip.c ****   uip_acc32[3] = op32[3] + (op16 & 0xff);
 74099              		.loc 1 256 0
 74100 0002 4998     		lda.w	r8, uip_acc32
 74101 0004 19B9     		ld.ub	r9, r12[3]
 74102 0006 1609     		add     r9, r11
 74103              	.LVL2:
 74104 0008 B0B9     		st.b	r8[3], r9
 257:uIP/uip/uip.c ****   uip_acc32[2] = op32[2] + (op16 >> 8);
 74105              		.loc 1 257 0
 74106 000a F5DBC108 		bfextu	r10, r11, 8, 8
 74107 000e 19A9     		ld.ub	r9, r12[2]
 74108 0010 1409     		add     r9, r10
 74109 0012 B0A9     		st.b	r8[2], r9
 258:uIP/uip/uip.c ****   uip_acc32[1] = op32[1];
 74110              		.loc 1 258 0
 74111 0014 199E     		ld.ub	lr, r12[1]
 74112 0016 B09E     		st.b	r8[1], lr
 259:uIP/uip/uip.c ****   uip_acc32[0] = op32[0];
 74113              		.loc 1 259 0
 74114 0018 198C     		ld.ub	r12, r12[0]
 74115              	.LVL3:
 74116 001a B08C     		st.b	r8[0], r12
 260:uIP/uip/uip.c **** 
 261:uIP/uip/uip.c ****   if(uip_acc32[2] < (op16 >> 8)) {
 74117              		.loc 1 261 0
 74118 001c F20A1900 		cp.h	r10, r9
 74119 0020 E0880009 		brls .L5
 262:uIP/uip/uip.c ****     ++uip_acc32[1];
 74120              		.loc 1 262 0
 74121 0024 2FFE     		sub     lr, -1
 74122 0026 5C5E     		castu.b	lr
 74123 0028 B09E     		st.b	r8[1], lr
 263:uIP/uip/uip.c ****     if(uip_acc32[1] == 0) {
 264:uIP/uip/uip.c ****       ++uip_acc32[0];
 74124              		.loc 1 264 0
 74125 002a F7BC00FF 		 subeq	r12, -1
 74126 002e F1FC0E00 		 st.beq	r8[0], r12
 74127              	.L5:
 265:uIP/uip/uip.c ****     }
 266:uIP/uip/uip.c ****   }
 267:uIP/uip/uip.c **** 
 268:uIP/uip/uip.c **** 
 269:uIP/uip/uip.c ****   if(uip_acc32[3] < (op16 & 0xff)) {
 74128              		.loc 1 269 0
 74129 0032 48D8     		lda.w	r8, uip_acc32
 74130 0034 11B8     		ld.ub	r8, r8[3]
 74131 0036 5C5B     		castu.b	r11
 74132              	.LVL4:
 74133 0038 1638     		cp.w	r8, r11
 74134 003a C134     		brge .L7
 270:uIP/uip/uip.c ****     ++uip_acc32[2];
 74135              		.loc 1 270 0
 74136 003c 48A9     		lda.w	r9, uip_acc32
 74137 003e 13A8     		ld.ub	r8, r9[2]
 74138 0040 2FF8     		sub     r8, -1
 74139 0042 5C58     		castu.b	r8
 74140 0044 B2A8     		st.b	r9[2], r8
 271:uIP/uip/uip.c ****     if(uip_acc32[2] == 0) {
 74141              		.loc 1 271 0
 74142 0046 C0D1     		brne .L7
 272:uIP/uip/uip.c ****       ++uip_acc32[1];
 74143              		.loc 1 272 0
 74144 0048 1398     		ld.ub	r8, r9[1]
 74145 004a 2FF8     		sub     r8, -1
 74146 004c 5C58     		castu.b	r8
 74147 004e B298     		st.b	r9[1], r8
 273:uIP/uip/uip.c ****       if(uip_acc32[1] == 0) {
 274:uIP/uip/uip.c **** 	++uip_acc32[0];
 74148              		.loc 1 274 0
 74149 0050 F2081700 		 moveq	r8, r9
 74150 0054 F1F90800 		 ld.ubeq	r9, r8[0]
 74151 0058 F7B900FF 		 subeq	r9, -1
 74152 005c F1F90E00 		 st.beq	r8[0], r9
 74153              	.L7:
 74154 0060 D802     		popm	pc
 74155 0062 00000000 		.cpool
 74155      0000
 74156              		.align	2
 74157              	.L8:
 74158              	.LFE1:
 74160              		.section	.text.chksum,"ax",@progbits
 74161              		.align	1
 74163              	chksum:
 74164              	.LFB2:
 275:uIP/uip/uip.c ****       }
 276:uIP/uip/uip.c ****     }
 277:uIP/uip/uip.c ****   }
 278:uIP/uip/uip.c **** }
 279:uIP/uip/uip.c **** 
 280:uIP/uip/uip.c **** #endif /* UIP_ARCH_ADD32 */
 281:uIP/uip/uip.c **** 
 282:uIP/uip/uip.c **** #if ! UIP_ARCH_CHKSUM
 283:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 284:uIP/uip/uip.c **** static u16_t
 285:uIP/uip/uip.c **** chksum(u16_t sum, const u8_t *data, u16_t len)
 286:uIP/uip/uip.c **** {
 74165              		.loc 1 286 0
 74166              		# args = 0, frame = 0, pretend = 0
 74167              		# frame_needed = 0, leaf_function = 1
 74168              		# uses_anonymous_args = 0
 74169              	.LVL5:
 74170 0000 D401     		pushm	lr
 74171              	.LCFI1:
 287:uIP/uip/uip.c ****   u16_t t;
 288:uIP/uip/uip.c ****   const u8_t *dataptr;
 289:uIP/uip/uip.c ****   const u8_t *last_byte;
 290:uIP/uip/uip.c **** 
 291:uIP/uip/uip.c ****   dataptr = data;
 292:uIP/uip/uip.c ****   last_byte = data + len - 1;
 74172              		.loc 1 292 0
 74173 0002 FDDAC010 		bfextu	lr, r10, 0, 16
 74174              	.LVL6:
 74175 0006 201E     		sub     lr, 1
 74176              	.LVL7:
 74177 0008 F60E000E 		add     lr, r11, lr
 74178              	.LVL8:
 293:uIP/uip/uip.c **** 
 294:uIP/uip/uip.c ****   while(dataptr < last_byte) {	/* At least two more bytes */
 74179              		.loc 1 294 0
 74180 000c 1C3B     		cp.w	r11, lr
 74181 000e C1A2     		brhs .L11
 74182 0010 1698     		mov	r8, r11
 74183              	.LVL9:
 74184              	.L13:
 295:uIP/uip/uip.c ****     t = (dataptr[0] << 8) + dataptr[1];
 74185              		.loc 1 295 0
 74186 0012 1189     		ld.ub	r9, r8[0]
 74187              	.LVL10:
 74188 0014 A969     		lsl     r9, 8
 74189 0016 119A     		ld.ub	r10, r8[1]
 74190 0018 F4090009 		add     r9, r10, r9
 74191              	.LVL11:
 296:uIP/uip/uip.c ****     sum += t;
 74192              		.loc 1 296 0
 74193 001c 120C     		add     r12, r9
 74194              	.LVL12:
 74195 001e 5C8C     		casts.h	r12
 74196              	.LVL13:
 297:uIP/uip/uip.c ****     if(sum < t) {
 74197              		.loc 1 297 0
 74198 0020 F8091900 		cp.h	r9, r12
 74199 0024 E0880004 		brls .L12
 298:uIP/uip/uip.c ****       sum++;		/* carry */
 74200              		.loc 1 298 0
 74201 0028 2FFC     		sub     r12, -1
 74202              	.LVL14:
 74203 002a 5C8C     		casts.h	r12
 74204              	.LVL15:
 74205              	.L12:
 299:uIP/uip/uip.c ****     }
 300:uIP/uip/uip.c ****     dataptr += 2;
 74206              		.loc 1 300 0
 74207 002c 2FE8     		sub     r8, -2
 294:uIP/uip/uip.c ****   while(dataptr < last_byte) {	/* At least two more bytes */
 74208              		.loc 1 294 0
 74209 002e 103E     		cp.w	lr, r8
 74210 0030 FE9BFFF1 		brhi .L13
 74211 0034 F60811FF 		rsub	r8, r11, -1
 74212              	.LVL16:
 74213 0038 FC080008 		add     r8, lr, r8
 74214 003c A1C8     		cbr	r8, 0
 74215 003e 2FE8     		sub     r8, -2
 74216 0040 100B     		add     r11, r8
 74217              	.LVL17:
 74218              	.L11:
 301:uIP/uip/uip.c ****   }
 302:uIP/uip/uip.c **** 
 303:uIP/uip/uip.c ****   if(dataptr == last_byte) {
 74219              		.loc 1 303 0
 74220 0042 1C3B     		cp.w	r11, lr
 74221 0044 C0D1     		brne .L14
 304:uIP/uip/uip.c ****     t = (dataptr[0] << 8) + 0;
 74222              		.loc 1 304 0
 74223 0046 F7280000 		ld.sb	r8, r11[0]
 74224 004a A968     		lsl     r8, 8
 74225              	.LVL18:
 305:uIP/uip/uip.c ****     sum += t;
 74226              		.loc 1 305 0
 74227 004c F00C000C 		add     r12, r8, r12
 74228              	.LVL19:
 74229 0050 5C8C     		casts.h	r12
 74230              	.LVL20:
 306:uIP/uip/uip.c ****     if(sum < t) {
 74231              		.loc 1 306 0
 74232 0052 F8081900 		cp.h	r8, r12
 74233 0056 E0880004 		brls .L14
 307:uIP/uip/uip.c ****       sum++;		/* carry */
 74234              		.loc 1 307 0
 74235 005a 2FFC     		sub     r12, -1
 74236              	.LVL21:
 74237 005c 5C8C     		casts.h	r12
 74238              	.LVL22:
 74239              	.L14:
 74240              	.LVL23:
 308:uIP/uip/uip.c ****     }
 309:uIP/uip/uip.c ****   }
 310:uIP/uip/uip.c **** 
 311:uIP/uip/uip.c ****   /* Return sum in host byte order. */
 312:uIP/uip/uip.c ****   return sum;
 313:uIP/uip/uip.c **** }
 74241              		.loc 1 313 0
 74242 005e D802     		popm	pc
 74243              	.LFE2:
 74245              		.section	.text.uip_init,"ax",@progbits
 74246              		.align	1
 74247              		.global	uip_init
 74249              	uip_init:
 74250              	.LFB7:
 314:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 315:uIP/uip/uip.c **** u16_t
 316:uIP/uip/uip.c **** uip_chksum(u16_t *data, u16_t len)
 317:uIP/uip/uip.c **** {
 318:uIP/uip/uip.c ****   return htons(chksum(0, (u8_t *)data, len));
 319:uIP/uip/uip.c **** }
 320:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 321:uIP/uip/uip.c **** #ifndef UIP_ARCH_IPCHKSUM
 322:uIP/uip/uip.c **** u16_t
 323:uIP/uip/uip.c **** uip_ipchksum(void)
 324:uIP/uip/uip.c **** {
 325:uIP/uip/uip.c ****   u16_t sum;
 326:uIP/uip/uip.c **** 
 327:uIP/uip/uip.c ****   sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
 328:uIP/uip/uip.c ****   DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\r\n", sum);
 329:uIP/uip/uip.c ****   return (sum == 0) ? 0xffff : htons(sum);
 330:uIP/uip/uip.c **** }
 331:uIP/uip/uip.c **** #endif
 332:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 333:uIP/uip/uip.c **** static u16_t
 334:uIP/uip/uip.c **** upper_layer_chksum(u8_t proto)
 335:uIP/uip/uip.c **** {
 336:uIP/uip/uip.c ****   u16_t upper_layer_len;
 337:uIP/uip/uip.c ****   u16_t sum;
 338:uIP/uip/uip.c **** 
 339:uIP/uip/uip.c **** #if UIP_CONF_IPV6
 340:uIP/uip/uip.c ****   upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
 341:uIP/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 342:uIP/uip/uip.c ****   upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
 343:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 344:uIP/uip/uip.c **** 
 345:uIP/uip/uip.c ****   /* First sum pseudoheader. */
 346:uIP/uip/uip.c **** 
 347:uIP/uip/uip.c ****   /* IP protocol and length fields. This addition cannot carry. */
 348:uIP/uip/uip.c ****   sum = upper_layer_len + proto;
 349:uIP/uip/uip.c ****   /* Sum IP source and destination addresses. */
 350:uIP/uip/uip.c ****   sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
 351:uIP/uip/uip.c **** 
 352:uIP/uip/uip.c ****   /* Sum TCP header and data. */
 353:uIP/uip/uip.c ****   sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
 354:uIP/uip/uip.c **** 	       upper_layer_len);
 355:uIP/uip/uip.c **** 
 356:uIP/uip/uip.c ****   return (sum == 0) ? 0xffff : htons(sum);
 357:uIP/uip/uip.c **** }
 358:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 359:uIP/uip/uip.c **** #if UIP_CONF_IPV6
 360:uIP/uip/uip.c **** u16_t
 361:uIP/uip/uip.c **** uip_icmp6chksum(void)
 362:uIP/uip/uip.c **** {
 363:uIP/uip/uip.c ****   return upper_layer_chksum(UIP_PROTO_ICMP6);
 364:uIP/uip/uip.c **** 
 365:uIP/uip/uip.c **** }
 366:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 367:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 368:uIP/uip/uip.c **** u16_t
 369:uIP/uip/uip.c **** uip_tcpchksum(void)
 370:uIP/uip/uip.c **** {
 371:uIP/uip/uip.c ****   return upper_layer_chksum(UIP_PROTO_TCP);
 372:uIP/uip/uip.c **** }
 373:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 374:uIP/uip/uip.c **** #if UIP_UDP_CHECKSUMS
 375:uIP/uip/uip.c **** u16_t
 376:uIP/uip/uip.c **** uip_udpchksum(void)
 377:uIP/uip/uip.c **** {
 378:uIP/uip/uip.c ****   return upper_layer_chksum(UIP_PROTO_UDP);
 379:uIP/uip/uip.c **** }
 380:uIP/uip/uip.c **** #endif /* UIP_UDP_CHECKSUMS */
 381:uIP/uip/uip.c **** #endif /* UIP_ARCH_CHKSUM */
 382:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 383:uIP/uip/uip.c **** void
 384:uIP/uip/uip.c **** uip_init(void)
 385:uIP/uip/uip.c **** {
 74251              		.loc 1 385 0
 74252              		# args = 0, frame = 0, pretend = 0
 74253              		# frame_needed = 0, leaf_function = 1
 74254              		# uses_anonymous_args = 0
 386:uIP/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
 387:uIP/uip/uip.c ****     uip_listenports[c] = 0;
 74255              		.loc 1 387 0
 74256 0000 3008     		mov	r8, 0
 74257 0002 48B9     		lda.w	r9, uip_listenports
 74258 0004 B208     		st.h	r9[0], r8
 388:uIP/uip/uip.c ****   }
 389:uIP/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
 390:uIP/uip/uip.c ****     uip_conns[c].tcpstateflags = UIP_CLOSED;
 74259              		.loc 1 390 0
 74260 0006 48B9     		lda.w	r9, uip_conns
 74261 0008 F3680019 		st.b	r9[25], r8
 74262 000c F36800E5 		st.b	r9[229], r8
 391:uIP/uip/uip.c **** #if defined PORT_APP_MAPPER
 392:uIP/uip/uip.c **** 	uip_conns[c].appstate = -1;
 393:uIP/uip/uip.c **** #endif
 394:uIP/uip/uip.c ****   }
 395:uIP/uip/uip.c **** #if UIP_ACTIVE_OPEN
 396:uIP/uip/uip.c ****   lastport = 1024;
 74263              		.loc 1 396 0
 74264 0010 489A     		lda.w	r10, .LANCHOR0
 74265 0012 E0690400 		mov	r9, 1024
 74266 0016 B419     		st.h	r10[2], r9
 397:uIP/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 398:uIP/uip/uip.c **** 
 399:uIP/uip/uip.c **** #if UIP_UDP
 400:uIP/uip/uip.c ****   for(c = 0; c < UIP_UDP_CONNS; ++c) {
 401:uIP/uip/uip.c ****     uip_udp_conns[c].lport = 0;
 74267              		.loc 1 401 0
 74268 0018 4889     		lda.w	r9, uip_udp_conns
 74269 001a B228     		st.h	r9[4], r8
 74270 001c F3580014 		st.h	r9[20], r8
 74271 0020 F3580024 		st.h	r9[36], r8
 74272 0024 3038     		mov	r8, 3
 74273 0026 B4C8     		st.b	r10[4], r8
 402:uIP/uip/uip.c **** #if defined PORT_APP_MAPPER
 403:uIP/uip/uip.c **** 	uip_udp_conns[c].appstate = -1;
 404:uIP/uip/uip.c **** #endif
 405:uIP/uip/uip.c ****   }
 406:uIP/uip/uip.c **** #endif /* UIP_UDP */
 407:uIP/uip/uip.c **** 
 408:uIP/uip/uip.c **** 
 409:uIP/uip/uip.c ****   /* IPv4 initialization. */
 410:uIP/uip/uip.c **** #if UIP_FIXEDADDR == 0
 411:uIP/uip/uip.c ****   /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
 412:uIP/uip/uip.c **** #endif /* UIP_FIXEDADDR */
 413:uIP/uip/uip.c **** 
 414:uIP/uip/uip.c **** }
 74274              		.loc 1 414 0
 74275 0028 5EFC     		retal	r12
 74276 002a 00000000 		.cpool
 74276      00000000 
 74276      00000000 
 74276      00000000 
 74276      0000
 74277              		.align	2
 74278              	.L19:
 74279              	.LFE7:
 74281              		.section	.text.uip_unlisten,"ax",@progbits
 74282              		.align	1
 74283              		.global	uip_unlisten
 74285              	uip_unlisten:
 74286              	.LFB10:
 415:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 416:uIP/uip/uip.c **** #if UIP_ACTIVE_OPEN
 417:uIP/uip/uip.c **** struct uip_conn * uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
 418:uIP/uip/uip.c **** {
 419:uIP/uip/uip.c **** register struct uip_conn *conn, *cconn;
 420:uIP/uip/uip.c **** 
 421:uIP/uip/uip.c **** /* Find an unused local port. */
 422:uIP/uip/uip.c **** again:
 423:uIP/uip/uip.c **** 
 424:uIP/uip/uip.c **** 	++lastport;
 425:uIP/uip/uip.c **** 
 426:uIP/uip/uip.c **** 	if(lastport >= 32000)
 427:uIP/uip/uip.c **** 	{
 428:uIP/uip/uip.c **** 		lastport = 4096;
 429:uIP/uip/uip.c **** 	}
 430:uIP/uip/uip.c **** 
 431:uIP/uip/uip.c **** 	/* Check if this port is already in use, and if so try to find
 432:uIP/uip/uip.c **** 	another one. */
 433:uIP/uip/uip.c **** 	for(c = 0; c < UIP_CONNS; ++c)
 434:uIP/uip/uip.c **** 	{
 435:uIP/uip/uip.c **** 		conn = &uip_conns[c];
 436:uIP/uip/uip.c **** 		if(conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport))
 437:uIP/uip/uip.c **** 		{
 438:uIP/uip/uip.c **** 			goto again;
 439:uIP/uip/uip.c **** 		}
 440:uIP/uip/uip.c **** 	}
 441:uIP/uip/uip.c **** 
 442:uIP/uip/uip.c **** 	conn = 0;
 443:uIP/uip/uip.c **** 	for(c = 0; c < UIP_CONNS; ++c)
 444:uIP/uip/uip.c **** 	{
 445:uIP/uip/uip.c **** 		cconn = &uip_conns[c];
 446:uIP/uip/uip.c **** 		if(cconn->tcpstateflags == UIP_CLOSED)
 447:uIP/uip/uip.c **** 		{
 448:uIP/uip/uip.c **** 			conn = cconn;
 449:uIP/uip/uip.c **** 			break;
 450:uIP/uip/uip.c **** 		}
 451:uIP/uip/uip.c **** 		if(cconn->tcpstateflags == UIP_TIME_WAIT)
 452:uIP/uip/uip.c **** 		{
 453:uIP/uip/uip.c **** 			if(conn == 0 || cconn->timer > conn->timer)
 454:uIP/uip/uip.c **** 			{
 455:uIP/uip/uip.c **** 				conn = cconn;
 456:uIP/uip/uip.c **** 			}
 457:uIP/uip/uip.c **** 		}
 458:uIP/uip/uip.c **** 	}
 459:uIP/uip/uip.c **** 
 460:uIP/uip/uip.c **** 	if(conn == 0)
 461:uIP/uip/uip.c **** 	{
 462:uIP/uip/uip.c **** 		return 0;
 463:uIP/uip/uip.c **** 	}
 464:uIP/uip/uip.c **** 
 465:uIP/uip/uip.c **** 	conn->tcpstateflags = UIP_SYN_SENT;
 466:uIP/uip/uip.c **** 
 467:uIP/uip/uip.c **** 	conn->snd_nxt[0] = iss[0];
 468:uIP/uip/uip.c **** 	conn->snd_nxt[1] = iss[1];
 469:uIP/uip/uip.c **** 	conn->snd_nxt[2] = iss[2];
 470:uIP/uip/uip.c **** 	conn->snd_nxt[3] = iss[3];
 471:uIP/uip/uip.c **** 
 472:uIP/uip/uip.c **** 	conn->initialmss = conn->mss = UIP_TCP_MSS;
 473:uIP/uip/uip.c **** 
 474:uIP/uip/uip.c **** 	conn->len = 1;   /* TCP length of the SYN is one. */
 475:uIP/uip/uip.c **** 	conn->nrtx = 0;
 476:uIP/uip/uip.c **** 	conn->timer = 1; /* Send the SYN next time around. */
 477:uIP/uip/uip.c **** 	conn->rto = UIP_RTO;
 478:uIP/uip/uip.c **** 	conn->sa = 0;
 479:uIP/uip/uip.c **** 	conn->sv = 16;   /* Initial value of the RTT variance. */
 480:uIP/uip/uip.c **** 	conn->lport = htons(lastport);
 481:uIP/uip/uip.c **** 	conn->rport = rport;
 482:uIP/uip/uip.c **** 	uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 483:uIP/uip/uip.c **** 
 484:uIP/uip/uip.c **** 	return conn;
 485:uIP/uip/uip.c **** }
 486:uIP/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 487:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 488:uIP/uip/uip.c **** #if UIP_UDP
 489:uIP/uip/uip.c **** struct uip_udp_conn * uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
 490:uIP/uip/uip.c **** {
 491:uIP/uip/uip.c **** register struct uip_udp_conn *conn;
 492:uIP/uip/uip.c **** 
 493:uIP/uip/uip.c **** /* Find an unused local port. */
 494:uIP/uip/uip.c **** again:
 495:uIP/uip/uip.c **** 	++lastport;
 496:uIP/uip/uip.c **** 
 497:uIP/uip/uip.c **** 	if(lastport >= 32000)
 498:uIP/uip/uip.c **** 	{
 499:uIP/uip/uip.c **** 		lastport = 4096;
 500:uIP/uip/uip.c **** 	}
 501:uIP/uip/uip.c **** 
 502:uIP/uip/uip.c **** 	for(c = 0; c < UIP_UDP_CONNS; ++c)
 503:uIP/uip/uip.c **** 	{
 504:uIP/uip/uip.c **** 		if(uip_udp_conns[c].lport == htons(lastport))
 505:uIP/uip/uip.c **** 		{
 506:uIP/uip/uip.c **** 			goto again;
 507:uIP/uip/uip.c **** 		}
 508:uIP/uip/uip.c **** 	}
 509:uIP/uip/uip.c **** 
 510:uIP/uip/uip.c **** 
 511:uIP/uip/uip.c **** 	conn = 0;
 512:uIP/uip/uip.c **** 	for(c = 0; c < UIP_UDP_CONNS; ++c)
 513:uIP/uip/uip.c **** 	{
 514:uIP/uip/uip.c **** 		if(uip_udp_conns[c].lport == 0)
 515:uIP/uip/uip.c **** 		{
 516:uIP/uip/uip.c **** 			conn = &uip_udp_conns[c];
 517:uIP/uip/uip.c **** 			break;
 518:uIP/uip/uip.c **** 		}
 519:uIP/uip/uip.c **** 	}
 520:uIP/uip/uip.c **** 
 521:uIP/uip/uip.c **** 	if(conn == 0)
 522:uIP/uip/uip.c **** 	{
 523:uIP/uip/uip.c **** 		return 0;
 524:uIP/uip/uip.c **** 	}
 525:uIP/uip/uip.c **** 
 526:uIP/uip/uip.c **** 	conn->lport = HTONS(lastport);
 527:uIP/uip/uip.c **** 	conn->rport = rport;
 528:uIP/uip/uip.c **** 	if(ripaddr == NULL)
 529:uIP/uip/uip.c **** 	{
 530:uIP/uip/uip.c **** 		memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
 531:uIP/uip/uip.c **** 	}
 532:uIP/uip/uip.c **** 	else
 533:uIP/uip/uip.c **** 	{
 534:uIP/uip/uip.c **** 		uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 535:uIP/uip/uip.c **** 	}
 536:uIP/uip/uip.c **** 	conn->ttl = UIP_TTL;
 537:uIP/uip/uip.c **** 
 538:uIP/uip/uip.c **** 	return conn;
 539:uIP/uip/uip.c **** }
 540:uIP/uip/uip.c **** #endif /* UIP_UDP */
 541:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 542:uIP/uip/uip.c **** void uip_unlisten(u16_t port)
 543:uIP/uip/uip.c **** {
 74287              		.loc 1 543 0
 74288              		# args = 0, frame = 0, pretend = 0
 74289              		# frame_needed = 0, leaf_function = 1
 74290              		# uses_anonymous_args = 0
 74291              	.LVL24:
 544:uIP/uip/uip.c **** 	for(c = 0; c < UIP_LISTENPORTS; ++c)
 74292              		.loc 1 544 0
 74293 0000 3009     		mov	r9, 0
 74294 0002 4888     		lda.w	r8, .LANCHOR0
 74295 0004 B0C9     		st.b	r8[4], r9
 545:uIP/uip/uip.c **** 	{
 546:uIP/uip/uip.c **** 		if(uip_listenports[c] == port)
 74296              		.loc 1 546 0
 74297 0006 4888     		lda.w	r8, uip_listenports
 74298 0008 9008     		ld.sh	r8, r8[0]
 74299 000a F8081900 		cp.h	r8, r12
 74300 000e C051     		brne .L21
 547:uIP/uip/uip.c **** 		{
 548:uIP/uip/uip.c **** 			uip_listenports[c] = 0;
 74301              		.loc 1 548 0
 74302 0010 4858     		lda.w	r8, uip_listenports
 74303 0012 3009     		mov	r9, 0
 74304 0014 B009     		st.h	r8[0], r9
 549:uIP/uip/uip.c **** 			return;
 74305              		.loc 1 549 0
 74306 0016 5EFC     		retal	r12
 74307              	.L21:
 544:uIP/uip/uip.c **** 	for(c = 0; c < UIP_LISTENPORTS; ++c)
 74308              		.loc 1 544 0
 74309 0018 4828     		lda.w	r8, .LANCHOR0
 74310 001a 3019     		mov	r9, 1
 74311 001c B0C9     		st.b	r8[4], r9
 74312 001e 5EFC     		retal	r12
 74313 0020 00000000 		.cpool
 74313      00000000 
 74314              		.align	2
 74315              	.L24:
 74316              	.LFE10:
 74318              		.section	.text.uip_listen,"ax",@progbits
 74319              		.align	1
 74320              		.global	uip_listen
 74322              	uip_listen:
 74323              	.LFB11:
 550:uIP/uip/uip.c **** 		}
 551:uIP/uip/uip.c **** 	}
 552:uIP/uip/uip.c **** }
 553:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 554:uIP/uip/uip.c **** void uip_listen(u16_t port)
 555:uIP/uip/uip.c **** {
 74324              		.loc 1 555 0
 74325              		# args = 0, frame = 0, pretend = 0
 74326              		# frame_needed = 0, leaf_function = 1
 74327              		# uses_anonymous_args = 0
 74328              	.LVL25:
 556:uIP/uip/uip.c **** 	for(c = 0; c < UIP_LISTENPORTS; ++c)
 74329              		.loc 1 556 0
 74330 0000 3009     		mov	r9, 0
 74331 0002 4888     		lda.w	r8, .LANCHOR0
 74332 0004 B0C9     		st.b	r8[4], r9
 557:uIP/uip/uip.c **** 	{
 558:uIP/uip/uip.c **** 		if(uip_listenports[c] == 0)
 74333              		.loc 1 558 0
 74334 0006 4888     		lda.w	r8, uip_listenports
 74335 0008 9009     		ld.sh	r9, r8[0]
 74336 000a 3008     		mov	r8, 0
 74337 000c F0091900 		cp.h	r9, r8
 74338 0010 C041     		brne .L26
 559:uIP/uip/uip.c **** 		{
 560:uIP/uip/uip.c **** 			uip_listenports[c] = port;
 74339              		.loc 1 560 0
 74340 0012 4858     		lda.w	r8, uip_listenports
 74341 0014 B00C     		st.h	r8[0], r12
 561:uIP/uip/uip.c **** 			return;
 74342              		.loc 1 561 0
 74343 0016 5EFC     		retal	r12
 74344              	.L26:
 556:uIP/uip/uip.c **** 	for(c = 0; c < UIP_LISTENPORTS; ++c)
 74345              		.loc 1 556 0
 74346 0018 4828     		lda.w	r8, .LANCHOR0
 74347 001a 3019     		mov	r9, 1
 74348 001c B0C9     		st.b	r8[4], r9
 74349 001e 5EFC     		retal	r12
 74350 0020 00000000 		.cpool
 74350      00000000 
 74351              		.align	2
 74352              	.L29:
 74353              	.LFE11:
 74355              		.section	.text.uip_add_rcv_nxt,"ax",@progbits
 74356              		.align	1
 74358              	uip_add_rcv_nxt:
 74359              	.LFB12:
 562:uIP/uip/uip.c **** 		}
 563:uIP/uip/uip.c **** 	}
 564:uIP/uip/uip.c **** }
 565:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 566:uIP/uip/uip.c **** /* XXX: IP fragment reassembly: not well-tested. */
 567:uIP/uip/uip.c **** 
 568:uIP/uip/uip.c **** #if UIP_REASSEMBLY && !UIP_CONF_IPV6
 569:uIP/uip/uip.c **** #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
 570:uIP/uip/uip.c **** static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
 571:uIP/uip/uip.c **** static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
 572:uIP/uip/uip.c **** static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
 573:uIP/uip/uip.c **** 				    0x0f, 0x07, 0x03, 0x01};
 574:uIP/uip/uip.c **** static u16_t uip_reasslen;
 575:uIP/uip/uip.c **** static u8_t uip_reassflags;
 576:uIP/uip/uip.c **** #define UIP_REASS_FLAG_LASTFRAG 0x01
 577:uIP/uip/uip.c **** static u8_t uip_reasstmr;
 578:uIP/uip/uip.c **** 
 579:uIP/uip/uip.c **** #define IP_MF   0x20
 580:uIP/uip/uip.c **** 
 581:uIP/uip/uip.c **** static u8_t
 582:uIP/uip/uip.c **** uip_reass(void)
 583:uIP/uip/uip.c **** {
 584:uIP/uip/uip.c ****   u16_t offset, len;
 585:uIP/uip/uip.c ****   u16_t i;
 586:uIP/uip/uip.c **** 
 587:uIP/uip/uip.c ****   /* If ip_reasstmr is zero, no packet is present in the buffer, so we
 588:uIP/uip/uip.c ****      write the IP header of the fragment into the reassembly
 589:uIP/uip/uip.c ****      buffer. The timer is updated with the maximum age. */
 590:uIP/uip/uip.c ****   if(uip_reasstmr == 0) {
 591:uIP/uip/uip.c ****     memcpy(uip_reassbuf, &BUF->vhl, UIP_IPH_LEN);
 592:uIP/uip/uip.c ****     uip_reasstmr = UIP_REASS_MAXAGE;
 593:uIP/uip/uip.c ****     uip_reassflags = 0;
 594:uIP/uip/uip.c ****     /* Clear the bitmap. */
 595:uIP/uip/uip.c ****     memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
 596:uIP/uip/uip.c ****   }
 597:uIP/uip/uip.c **** 
 598:uIP/uip/uip.c ****   /* Check if the incoming fragment matches the one currently present
 599:uIP/uip/uip.c ****      in the reasembly buffer. If so, we proceed with copying the
 600:uIP/uip/uip.c ****      fragment into the buffer. */
 601:uIP/uip/uip.c ****   if(BUF->srcipaddr[0] == FBUF->srcipaddr[0] &&
 602:uIP/uip/uip.c ****      BUF->srcipaddr[1] == FBUF->srcipaddr[1] &&
 603:uIP/uip/uip.c ****      BUF->destipaddr[0] == FBUF->destipaddr[0] &&
 604:uIP/uip/uip.c ****      BUF->destipaddr[1] == FBUF->destipaddr[1] &&
 605:uIP/uip/uip.c ****      BUF->ipid[0] == FBUF->ipid[0] &&
 606:uIP/uip/uip.c ****      BUF->ipid[1] == FBUF->ipid[1]) {
 607:uIP/uip/uip.c **** 
 608:uIP/uip/uip.c ****     len = (BUF->len[0] << 8) + BUF->len[1] - (BUF->vhl & 0x0f) * 4;
 609:uIP/uip/uip.c ****     offset = (((BUF->ipoffset[0] & 0x3f) << 8) + BUF->ipoffset[1]) * 8;
 610:uIP/uip/uip.c **** 
 611:uIP/uip/uip.c ****     /* If the offset or the offset + fragment length overflows the
 612:uIP/uip/uip.c ****        reassembly buffer, we discard the entire packet. */
 613:uIP/uip/uip.c ****     if(offset > UIP_REASS_BUFSIZE ||
 614:uIP/uip/uip.c ****        offset + len > UIP_REASS_BUFSIZE) {
 615:uIP/uip/uip.c ****       uip_reasstmr = 0;
 616:uIP/uip/uip.c ****       goto nullreturn;
 617:uIP/uip/uip.c ****     }
 618:uIP/uip/uip.c **** 
 619:uIP/uip/uip.c ****     /* Copy the fragment into the reassembly buffer, at the right
 620:uIP/uip/uip.c ****        offset. */
 621:uIP/uip/uip.c ****     memcpy(&uip_reassbuf[UIP_IPH_LEN + offset],
 622:uIP/uip/uip.c **** 	   (char *)BUF + (int)((BUF->vhl & 0x0f) * 4),
 623:uIP/uip/uip.c **** 	   len);
 624:uIP/uip/uip.c **** 
 625:uIP/uip/uip.c ****     /* Update the bitmap. */
 626:uIP/uip/uip.c ****     if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
 627:uIP/uip/uip.c ****       /* If the two endpoints are in the same byte, we only update
 628:uIP/uip/uip.c **** 	 that byte. */
 629:uIP/uip/uip.c **** 
 630:uIP/uip/uip.c ****       uip_reassbitmap[offset / (8 * 8)] |=
 631:uIP/uip/uip.c **** 	     bitmap_bits[(offset / 8 ) & 7] &
 632:uIP/uip/uip.c **** 	     ~bitmap_bits[((offset + len) / 8 ) & 7];
 633:uIP/uip/uip.c ****     } else {
 634:uIP/uip/uip.c ****       /* If the two endpoints are in different bytes, we update the
 635:uIP/uip/uip.c **** 	 bytes in the endpoints and fill the stuff inbetween with
 636:uIP/uip/uip.c **** 	 0xff. */
 637:uIP/uip/uip.c ****       uip_reassbitmap[offset / (8 * 8)] |=
 638:uIP/uip/uip.c **** 	bitmap_bits[(offset / 8 ) & 7];
 639:uIP/uip/uip.c ****       for(i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
 640:uIP/uip/uip.c **** 	uip_reassbitmap[i] = 0xff;
 641:uIP/uip/uip.c ****       }
 642:uIP/uip/uip.c ****       uip_reassbitmap[(offset + len) / (8 * 8)] |=
 643:uIP/uip/uip.c **** 	~bitmap_bits[((offset + len) / 8 ) & 7];
 644:uIP/uip/uip.c ****     }
 645:uIP/uip/uip.c **** 
 646:uIP/uip/uip.c ****     /* If this fragment has the More Fragments flag set to zero, we
 647:uIP/uip/uip.c ****        know that this is the last fragment, so we can calculate the
 648:uIP/uip/uip.c ****        size of the entire packet. We also set the
 649:uIP/uip/uip.c ****        IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
 650:uIP/uip/uip.c ****        the final fragment. */
 651:uIP/uip/uip.c **** 
 652:uIP/uip/uip.c ****     if((BUF->ipoffset[0] & IP_MF) == 0) {
 653:uIP/uip/uip.c ****       uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
 654:uIP/uip/uip.c ****       uip_reasslen = offset + len;
 655:uIP/uip/uip.c ****     }
 656:uIP/uip/uip.c **** 
 657:uIP/uip/uip.c ****     /* Finally, we check if we have a full packet in the buffer. We do
 658:uIP/uip/uip.c ****        this by checking if we have the last fragment and if all bits
 659:uIP/uip/uip.c ****        in the bitmap are set. */
 660:uIP/uip/uip.c ****     if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
 661:uIP/uip/uip.c ****       /* Check all bytes up to and including all but the last byte in
 662:uIP/uip/uip.c **** 	 the bitmap. */
 663:uIP/uip/uip.c ****       for(i = 0; i < uip_reasslen / (8 * 8) - 1; ++i) {
 664:uIP/uip/uip.c **** 	if(uip_reassbitmap[i] != 0xff) {
 665:uIP/uip/uip.c **** 	  goto nullreturn;
 666:uIP/uip/uip.c **** 	}
 667:uIP/uip/uip.c ****       }
 668:uIP/uip/uip.c ****       /* Check the last byte in the bitmap. It should contain just the
 669:uIP/uip/uip.c **** 	 right amount of bits. */
 670:uIP/uip/uip.c ****       if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
 671:uIP/uip/uip.c **** 	 (u8_t)~bitmap_bits[uip_reasslen / 8 & 7]) {
 672:uIP/uip/uip.c **** 	goto nullreturn;
 673:uIP/uip/uip.c ****       }
 674:uIP/uip/uip.c **** 
 675:uIP/uip/uip.c ****       /* If we have come this far, we have a full packet in the
 676:uIP/uip/uip.c **** 	 buffer, so we allocate a pbuf and copy the packet into it. We
 677:uIP/uip/uip.c **** 	 also reset the timer. */
 678:uIP/uip/uip.c ****       uip_reasstmr = 0;
 679:uIP/uip/uip.c ****       memcpy(BUF, FBUF, uip_reasslen);
 680:uIP/uip/uip.c **** 
 681:uIP/uip/uip.c ****       /* Pretend to be a "normal" (i.e., not fragmented) IP packet
 682:uIP/uip/uip.c **** 	 from now on. */
 683:uIP/uip/uip.c ****       BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
 684:uIP/uip/uip.c ****       BUF->len[0] = uip_reasslen >> 8;
 685:uIP/uip/uip.c ****       BUF->len[1] = uip_reasslen & 0xff;
 686:uIP/uip/uip.c ****       BUF->ipchksum = 0;
 687:uIP/uip/uip.c ****       BUF->ipchksum = ~(uip_ipchksum());
 688:uIP/uip/uip.c **** 
 689:uIP/uip/uip.c ****       return uip_reasslen;
 690:uIP/uip/uip.c ****     }
 691:uIP/uip/uip.c ****   }
 692:uIP/uip/uip.c **** 
 693:uIP/uip/uip.c ****  nullreturn:
 694:uIP/uip/uip.c ****   return 0;
 695:uIP/uip/uip.c **** }
 696:uIP/uip/uip.c **** #endif /* UIP_REASSEMBLY */
 697:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 698:uIP/uip/uip.c **** static void
 699:uIP/uip/uip.c **** uip_add_rcv_nxt(u16_t n)
 700:uIP/uip/uip.c **** {
 74360              		.loc 1 700 0
 74361              		# args = 0, frame = 0, pretend = 0
 74362              		# frame_needed = 0, leaf_function = 0
 74363              		# uses_anonymous_args = 0
 74364              	.LVL26:
 74365 0000 EBCD4080 		stm	--sp, r7, lr
 74366              	.LCFI2:
 701:uIP/uip/uip.c ****   uip_add32(uip_conn->rcv_nxt, n);
 74367              		.loc 1 701 0
 74368 0004 48E7     		lda.w	r7, uip_conn
 74369 0006 6E08     		ld.w	r8, r7[0]
 74370 0008 F7DCC010 		bfextu	r11, r12, 0, 16
 74371 000c F0CCFFF8 		sub     r12, r8, -8
 74372              	.LVL27:
 74373 0010 F01F000C 		call	uip_add32
 702:uIP/uip/uip.c ****   uip_conn->rcv_nxt[0] = uip_acc32[0];
 74374              		.loc 1 702 0
 74375 0014 6E09     		ld.w	r9, r7[0]
 74376 0016 48C8     		lda.w	r8, uip_acc32
 74377 0018 118A     		ld.ub	r10, r8[0]
 74378 001a F36A0008 		st.b	r9[8], r10
 703:uIP/uip/uip.c ****   uip_conn->rcv_nxt[1] = uip_acc32[1];
 74379              		.loc 1 703 0
 74380 001e 6E09     		ld.w	r9, r7[0]
 74381 0020 119A     		ld.ub	r10, r8[1]
 74382 0022 F36A0009 		st.b	r9[9], r10
 704:uIP/uip/uip.c ****   uip_conn->rcv_nxt[2] = uip_acc32[2];
 74383              		.loc 1 704 0
 74384 0026 6E09     		ld.w	r9, r7[0]
 74385 0028 11AA     		ld.ub	r10, r8[2]
 74386 002a F36A000A 		st.b	r9[10], r10
 705:uIP/uip/uip.c ****   uip_conn->rcv_nxt[3] = uip_acc32[3];
 74387              		.loc 1 705 0
 74388 002e 6E09     		ld.w	r9, r7[0]
 74389 0030 11B8     		ld.ub	r8, r8[3]
 74390 0032 F368000B 		st.b	r9[11], r8
 706:uIP/uip/uip.c **** }
 74391              		.loc 1 706 0
 74392 0036 E3CD8080 		ldm	sp++, r7, pc
 74393 003a 00000000 		.cpool
 74393      00000000 
 74393      00000000 
 74393      0000
 74394              		.align	2
 74395              	.L32:
 74396              	.LFE12:
 74398              		.section	.text.htons,"ax",@progbits
 74399              		.align	1
 74400              		.global	htons
 74402              	htons:
 74403              	.LFB14:
 707:uIP/uip/uip.c **** 
 708:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
 709:uIP/uip/uip.c **** struct uip_conn *uip_connr;
 710:uIP/uip/uip.c **** 
 711:uIP/uip/uip.c **** void uip_process(u8_t flag)
 712:uIP/uip/uip.c **** {
 713:uIP/uip/uip.c **** //register struct uip_conn *uip_connr = uip_conn;
 714:uIP/uip/uip.c **** 
 715:uIP/uip/uip.c **** 	DEBUG_PRINTF("uip_process(%d)\r\n", flag);
 716:uIP/uip/uip.c **** 
 717:uIP/uip/uip.c **** #if UIP_UDP
 718:uIP/uip/uip.c **** 	if(flag == UIP_UDP_SEND_CONN)
 719:uIP/uip/uip.c **** 	{
 720:uIP/uip/uip.c **** 		goto udp_send;
 721:uIP/uip/uip.c **** 	}
 722:uIP/uip/uip.c **** #endif /* UIP_UDP */
 723:uIP/uip/uip.c **** 
 724:uIP/uip/uip.c **** 	uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
 725:uIP/uip/uip.c **** 
 726:uIP/uip/uip.c ****   /* Check if we were invoked because of a poll request for a particular connection. */
 727:uIP/uip/uip.c **** 	if(flag == UIP_POLL_REQUEST)
 728:uIP/uip/uip.c **** 	{
 729:uIP/uip/uip.c **** 		if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED && !uip_outstanding(uip_connr))
 730:uIP/uip/uip.c **** 		{
 731:uIP/uip/uip.c **** 			uip_flags = UIP_POLL;
 732:uIP/uip/uip.c **** 			DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
 733:uIP/uip/uip.c **** 			UIP_APPCALL();
 734:uIP/uip/uip.c **** 			goto appsend;
 735:uIP/uip/uip.c **** 		}
 736:uIP/uip/uip.c **** 		goto drop;
 737:uIP/uip/uip.c **** 
 738:uIP/uip/uip.c **** 		/* Check if we were invoked because of the perodic timer fireing. */
 739:uIP/uip/uip.c **** 	}
 740:uIP/uip/uip.c **** 	else if(flag == UIP_TIMER)
 741:uIP/uip/uip.c **** 	{
 742:uIP/uip/uip.c **** #if UIP_REASSEMBLY
 743:uIP/uip/uip.c **** 		if(uip_reasstmr != 0)
 744:uIP/uip/uip.c **** 		{
 745:uIP/uip/uip.c **** 			--uip_reasstmr;
 746:uIP/uip/uip.c **** 		}
 747:uIP/uip/uip.c **** #endif /* UIP_REASSEMBLY */
 748:uIP/uip/uip.c **** 		/* Increase the initial sequence number. */
 749:uIP/uip/uip.c **** 		if(++iss[3] == 0)
 750:uIP/uip/uip.c **** 		{
 751:uIP/uip/uip.c **** 			if(++iss[2] == 0)
 752:uIP/uip/uip.c **** 			{
 753:uIP/uip/uip.c **** 				if(++iss[1] == 0)
 754:uIP/uip/uip.c **** 				{
 755:uIP/uip/uip.c **** 					++iss[0];
 756:uIP/uip/uip.c **** 				}
 757:uIP/uip/uip.c **** 			}
 758:uIP/uip/uip.c **** 		}
 759:uIP/uip/uip.c **** 
 760:uIP/uip/uip.c **** 		/* Reset the length variables. */
 761:uIP/uip/uip.c **** 		uip_len = 0;
 762:uIP/uip/uip.c **** 		uip_slen = 0;
 763:uIP/uip/uip.c **** 
 764:uIP/uip/uip.c **** 		/* Check if the connection is in a state in which we simply wait
 765:uIP/uip/uip.c **** 		   for the connection to time out. If so, we increase the
 766:uIP/uip/uip.c **** 		   connection's timer and remove the connection if it times
 767:uIP/uip/uip.c **** 		   out. */
 768:uIP/uip/uip.c **** 		if(uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2)
 769:uIP/uip/uip.c **** 		{
 770:uIP/uip/uip.c **** 			++(uip_connr->timer);
 771:uIP/uip/uip.c **** 			if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT)
 772:uIP/uip/uip.c **** 			{
 773:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_CLOSED;
 774:uIP/uip/uip.c **** 			}
 775:uIP/uip/uip.c **** 		}
 776:uIP/uip/uip.c **** 		else if(uip_connr->tcpstateflags != UIP_CLOSED)
 777:uIP/uip/uip.c **** 		{
 778:uIP/uip/uip.c **** 			  /* If the connection has outstanding data, we increase the
 779:uIP/uip/uip.c **** 			 connection's timer and see if it has reached the RTO value
 780:uIP/uip/uip.c **** 			 in which case we retransmit. */
 781:uIP/uip/uip.c **** 			if(uip_outstanding(uip_connr))
 782:uIP/uip/uip.c **** 			{
 783:uIP/uip/uip.c **** 				if(uip_connr->timer-- == 0)
 784:uIP/uip/uip.c **** 				{
 785:uIP/uip/uip.c **** 					if(uip_connr->nrtx == UIP_MAXRTX || ((uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->t
 786:uIP/uip/uip.c **** 					{
 787:uIP/uip/uip.c **** 						uip_connr->tcpstateflags = UIP_CLOSED;
 788:uIP/uip/uip.c **** 
 789:uIP/uip/uip.c **** 						/* We call UIP_APPCALL() with uip_flags set to
 790:uIP/uip/uip.c **** 						   UIP_TIMEDOUT to inform the application that the
 791:uIP/uip/uip.c **** 						   connection has timed out. */
 792:uIP/uip/uip.c **** 						uip_flags = UIP_TIMEDOUT;
 793:uIP/uip/uip.c **** 						DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
 794:uIP/uip/uip.c **** 						UIP_APPCALL();
 795:uIP/uip/uip.c **** 
 796:uIP/uip/uip.c **** 						/* We also send a reset packet to the remote host. */
 797:uIP/uip/uip.c **** 						BUF->flags = TCP_RST | TCP_ACK;
 798:uIP/uip/uip.c **** 						goto tcp_send_nodata;
 799:uIP/uip/uip.c **** 					}
 800:uIP/uip/uip.c **** 
 801:uIP/uip/uip.c **** 					/* Exponential backoff. */
 802:uIP/uip/uip.c **** 					uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4? 4:uip_connr->nrtx);
 803:uIP/uip/uip.c **** 					++(uip_connr->nrtx);
 804:uIP/uip/uip.c **** 
 805:uIP/uip/uip.c **** 					  /* Ok, so we need to retransmit. We do this differently
 806:uIP/uip/uip.c **** 						 depending on which state we are in. In ESTABLISHED, we
 807:uIP/uip/uip.c **** 						 call upon the application so that it may prepare the
 808:uIP/uip/uip.c **** 						 data for the retransmit. In SYN_RCVD, we resend the
 809:uIP/uip/uip.c **** 						 SYNACK that we sent earlier and in LAST_ACK we have to
 810:uIP/uip/uip.c **** 						 retransmit our FINACK. */
 811:uIP/uip/uip.c **** 					UIP_STAT(++uip_stat.tcp.rexmit);
 812:uIP/uip/uip.c **** 					switch(uip_connr->tcpstateflags & UIP_TS_MASK)
 813:uIP/uip/uip.c **** 					{
 814:uIP/uip/uip.c **** 					case UIP_SYN_RCVD:
 815:uIP/uip/uip.c **** 						/* In the SYN_RCVD state, we should retransmit our SYNACK. */
 816:uIP/uip/uip.c **** 						goto tcp_send_synack;
 817:uIP/uip/uip.c **** 
 818:uIP/uip/uip.c **** #if UIP_ACTIVE_OPEN
 819:uIP/uip/uip.c **** 					case UIP_SYN_SENT:
 820:uIP/uip/uip.c **** 					/* In the SYN_SENT state, we retransmit out SYN. */
 821:uIP/uip/uip.c **** 						BUF->flags = 0;
 822:uIP/uip/uip.c **** 						goto tcp_send_syn;
 823:uIP/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 824:uIP/uip/uip.c **** 
 825:uIP/uip/uip.c **** 					case UIP_ESTABLISHED:
 826:uIP/uip/uip.c **** 					/* In the ESTABLISHED state, we call upon the application
 827:uIP/uip/uip.c **** 						   to do the actual retransmit after which we jump into
 828:uIP/uip/uip.c **** 						   the code for sending out the packet (the apprexmit
 829:uIP/uip/uip.c **** 						   label). */
 830:uIP/uip/uip.c **** 						uip_flags = UIP_REXMIT;
 831:uIP/uip/uip.c **** 						DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
 832:uIP/uip/uip.c **** 						UIP_APPCALL();
 833:uIP/uip/uip.c **** 						goto apprexmit;
 834:uIP/uip/uip.c **** 
 835:uIP/uip/uip.c **** 					case UIP_FIN_WAIT_1:
 836:uIP/uip/uip.c **** 					case UIP_CLOSING:
 837:uIP/uip/uip.c **** 					case UIP_LAST_ACK:
 838:uIP/uip/uip.c **** 					/* In all these states we should retransmit a FINACK. */
 839:uIP/uip/uip.c **** 						goto tcp_send_finack;
 840:uIP/uip/uip.c **** 
 841:uIP/uip/uip.c **** 					}
 842:uIP/uip/uip.c **** 				}
 843:uIP/uip/uip.c **** 			}
 844:uIP/uip/uip.c **** 			else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED)
 845:uIP/uip/uip.c **** 			{
 846:uIP/uip/uip.c **** 			/* If there was no need for a retransmission, we poll the application for new data. */
 847:uIP/uip/uip.c **** 				uip_flags = UIP_POLL;
 848:uIP/uip/uip.c **** 				DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
 849:uIP/uip/uip.c **** 				UIP_APPCALL();
 850:uIP/uip/uip.c **** 				goto appsend;
 851:uIP/uip/uip.c **** 			}
 852:uIP/uip/uip.c **** 		}
 853:uIP/uip/uip.c **** 		goto drop;
 854:uIP/uip/uip.c **** 	}
 855:uIP/uip/uip.c **** #if UIP_UDP
 856:uIP/uip/uip.c **** 	if(flag == UIP_UDP_TIMER)
 857:uIP/uip/uip.c **** 	{
 858:uIP/uip/uip.c **** 		if(uip_udp_conn->lport != 0)
 859:uIP/uip/uip.c **** 		{
 860:uIP/uip/uip.c **** 			uip_conn = NULL;
 861:uIP/uip/uip.c **** 			uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 862:uIP/uip/uip.c **** 			uip_len = uip_slen = 0;
 863:uIP/uip/uip.c **** 			uip_flags = UIP_POLL;
 864:uIP/uip/uip.c **** 			DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
 865:uIP/uip/uip.c **** 			UIP_UDP_APPCALL();
 866:uIP/uip/uip.c **** 			goto udp_send;
 867:uIP/uip/uip.c **** 		}
 868:uIP/uip/uip.c **** 		else
 869:uIP/uip/uip.c **** 		{
 870:uIP/uip/uip.c **** 			goto drop;
 871:uIP/uip/uip.c **** 		}
 872:uIP/uip/uip.c **** 	}
 873:uIP/uip/uip.c **** #endif
 874:uIP/uip/uip.c **** 
 875:uIP/uip/uip.c **** 	/* This is where the input processing starts. */
 876:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.ip.recv);
 877:uIP/uip/uip.c **** 
 878:uIP/uip/uip.c **** 	/* Start of IP input header processing code. */
 879:uIP/uip/uip.c **** 
 880:uIP/uip/uip.c **** #if UIP_CONF_IPV6
 881:uIP/uip/uip.c **** 	/* Check validity of the IP header. */
 882:uIP/uip/uip.c **** 	if((BUF->vtc & 0xf0) != 0x60)
 883:uIP/uip/uip.c **** 	{	/* IP version and header length. */
 884:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.drop);
 885:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.vhlerr);
 886:uIP/uip/uip.c **** 		UIP_LOG("ipv6: invalid version.\r\n");
 887:uIP/uip/uip.c **** 		goto drop;
 888:uIP/uip/uip.c **** 	}
 889:uIP/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 890:uIP/uip/uip.c **** 	/* Check validity of the IP header. */
 891:uIP/uip/uip.c **** 	if(BUF->vhl != 0x45)
 892:uIP/uip/uip.c **** 	{ /* IP version and header length. */
 893:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.drop);
 894:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.vhlerr);
 895:uIP/uip/uip.c **** 		UIP_LOG("ip: invalid version or header length.\r\n");
 896:uIP/uip/uip.c **** 		goto drop;
 897:uIP/uip/uip.c **** 	}
 898:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 899:uIP/uip/uip.c **** 
 900:uIP/uip/uip.c **** 	/* Check the size of the packet. If the size reported to us in
 901:uIP/uip/uip.c **** 		uip_len is smaller the size reported in the IP header, we assume
 902:uIP/uip/uip.c **** 		that the packet has been corrupted in transit. If the size of
 903:uIP/uip/uip.c **** 		uip_len is larger than the size reported in the IP packet header,
 904:uIP/uip/uip.c **** 		the packet has been padded and we set uip_len to the correct
 905:uIP/uip/uip.c **** 		value.. */
 906:uIP/uip/uip.c **** 
 907:uIP/uip/uip.c **** 	if((BUF->len[0] << 8) + BUF->len[1] <= uip_len)
 908:uIP/uip/uip.c **** 	{
 909:uIP/uip/uip.c **** 		uip_len = (BUF->len[0] << 8) + BUF->len[1];
 910:uIP/uip/uip.c **** #if UIP_CONF_IPV6
 911:uIP/uip/uip.c **** 		uip_len += 40; /* The length reported in the IPv6 header is the
 912:uIP/uip/uip.c **** 							length of the payload that follows the
 913:uIP/uip/uip.c **** 							header. However, uIP uses the uip_len variable
 914:uIP/uip/uip.c **** 							for holding the size of the entire packet,
 915:uIP/uip/uip.c **** 							including the IP header. For IPv4 this is not a
 916:uIP/uip/uip.c **** 							problem as the length field in the IPv4 header
 917:uIP/uip/uip.c **** 							contains the length of the entire packet. But
 918:uIP/uip/uip.c **** 							for IPv6 we need to add the size of the IPv6
 919:uIP/uip/uip.c **** 							header (40 bytes). */
 920:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 921:uIP/uip/uip.c **** 	}
 922:uIP/uip/uip.c **** 	else
 923:uIP/uip/uip.c **** 	{
 924:uIP/uip/uip.c **** 		UIP_LOG("ip: packet shorter than reported in IP header.\r\n");
 925:uIP/uip/uip.c **** 		goto drop;
 926:uIP/uip/uip.c **** 	}
 927:uIP/uip/uip.c **** 
 928:uIP/uip/uip.c **** #if !UIP_CONF_IPV6
 929:uIP/uip/uip.c ****   /* Check the fragment flag. */
 930:uIP/uip/uip.c **** 	if((BUF->ipoffset[0] & 0x3f) != 0 || BUF->ipoffset[1] != 0)
 931:uIP/uip/uip.c **** 	{
 932:uIP/uip/uip.c ****   #if UIP_REASSEMBLY
 933:uIP/uip/uip.c **** 		uip_len = uip_reass();
 934:uIP/uip/uip.c **** 		if(uip_len == 0)
 935:uIP/uip/uip.c **** 		{
 936:uIP/uip/uip.c **** 			goto drop;
 937:uIP/uip/uip.c **** 		}
 938:uIP/uip/uip.c ****   #else /* UIP_REASSEMBLY */
 939:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.drop);
 940:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.fragerr);
 941:uIP/uip/uip.c **** 		UIP_LOG("ip: fragment dropped.\r\n");
 942:uIP/uip/uip.c **** 		goto drop;
 943:uIP/uip/uip.c ****   #endif /* UIP_REASSEMBLY */
 944:uIP/uip/uip.c **** 	}
 945:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 946:uIP/uip/uip.c **** 
 947:uIP/uip/uip.c **** 	if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr))
 948:uIP/uip/uip.c **** 	{
 949:uIP/uip/uip.c **** 	/* If we are configured to use ping IP address configuration and
 950:uIP/uip/uip.c **** 	hasn't been assigned an IP address yet, we accept all ICMP
 951:uIP/uip/uip.c **** 	packets. */
 952:uIP/uip/uip.c **** #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
 953:uIP/uip/uip.c **** 		if(BUF->proto == UIP_PROTO_ICMP)
 954:uIP/uip/uip.c **** 		{
 955:uIP/uip/uip.c **** 			UIP_LOG("ip: possible ping config packet received.\r\n");
 956:uIP/uip/uip.c **** 			goto icmp_input;
 957:uIP/uip/uip.c **** 		}
 958:uIP/uip/uip.c **** 		else
 959:uIP/uip/uip.c **** 		{
 960:uIP/uip/uip.c **** 			UIP_LOG("ip: packet dropped since no address assigned.\r\n");
 961:uIP/uip/uip.c **** 			goto drop;
 962:uIP/uip/uip.c **** 		}
 963:uIP/uip/uip.c **** #endif /* UIP_PINGADDRCONF */
 964:uIP/uip/uip.c **** 
 965:uIP/uip/uip.c **** 	}
 966:uIP/uip/uip.c **** 	else
 967:uIP/uip/uip.c **** 	{
 968:uIP/uip/uip.c **** 		/* If IP broadcast support is configured, we check for a broadcast
 969:uIP/uip/uip.c **** 		UDP packet, which may be destined to us. */
 970:uIP/uip/uip.c **** #if UIP_BROADCAST
 971:uIP/uip/uip.c **** 		DEBUG_PRINTF("UDP IP checksum 0x%04x\r\n", uip_ipchksum());
 972:uIP/uip/uip.c **** 		if(BUF->proto == UIP_PROTO_UDP && uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr) /*&& uip_ipchksu
 973:uIP/uip/uip.c **** 		{
 974:uIP/uip/uip.c **** 			goto udp_input;
 975:uIP/uip/uip.c **** 		}
 976:uIP/uip/uip.c **** #endif /* UIP_BROADCAST */
 977:uIP/uip/uip.c **** 
 978:uIP/uip/uip.c **** 		/* Check if the packet is destined for our IP address. */
 979:uIP/uip/uip.c **** #if !UIP_CONF_IPV6
 980:uIP/uip/uip.c **** 		if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr))
 981:uIP/uip/uip.c **** 		{
 982:uIP/uip/uip.c **** 			UIP_STAT(++uip_stat.ip.drop);
 983:uIP/uip/uip.c **** 			goto drop;
 984:uIP/uip/uip.c **** 		}
 985:uIP/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 986:uIP/uip/uip.c **** 		/* For IPv6, packet reception is a little trickier as we need to
 987:uIP/uip/uip.c **** 		   make sure that we listen to certain multicast addresses (all
 988:uIP/uip/uip.c **** 		   hosts multicast address, and the solicited-node multicast
 989:uIP/uip/uip.c **** 		   address) as well. However, we will cheat here and accept all
 990:uIP/uip/uip.c **** 		   multicast packets that are sent to the ff02::/16 addresses. */
 991:uIP/uip/uip.c **** 		if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) && BUF->destipaddr[0] != HTONS(0xff02))
 992:uIP/uip/uip.c **** 		{
 993:uIP/uip/uip.c **** 			UIP_STAT(++uip_stat.ip.drop);
 994:uIP/uip/uip.c **** 			goto drop;
 995:uIP/uip/uip.c **** 		}
 996:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 997:uIP/uip/uip.c **** 	}
 998:uIP/uip/uip.c **** 
 999:uIP/uip/uip.c **** #if !UIP_CONF_IPV6
1000:uIP/uip/uip.c **** 	if(uip_ipchksum() != 0xffff)
1001:uIP/uip/uip.c **** 	{ /* Compute and check the IP header checksum. */
1002:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.drop);
1003:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.chkerr);
1004:uIP/uip/uip.c **** 		UIP_LOG("ip: bad checksum.\r\n");
1005:uIP/uip/uip.c **** 		goto drop;
1006:uIP/uip/uip.c **** 	}
1007:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
1008:uIP/uip/uip.c **** 
1009:uIP/uip/uip.c **** 	if(BUF->proto == UIP_PROTO_TCP)
1010:uIP/uip/uip.c **** 	{ /* Check for TCP packet. If so, proceed with TCP input processing. */
1011:uIP/uip/uip.c **** 		goto tcp_input;
1012:uIP/uip/uip.c **** 	}
1013:uIP/uip/uip.c **** 
1014:uIP/uip/uip.c **** #if UIP_UDP
1015:uIP/uip/uip.c **** 	if(BUF->proto == UIP_PROTO_UDP)
1016:uIP/uip/uip.c **** 	{
1017:uIP/uip/uip.c **** 		goto udp_input;
1018:uIP/uip/uip.c **** 	}
1019:uIP/uip/uip.c **** #endif /* UIP_UDP */
1020:uIP/uip/uip.c **** 
1021:uIP/uip/uip.c **** #if !UIP_CONF_IPV6
1022:uIP/uip/uip.c **** 	/* ICMPv4 processing code follows. */
1023:uIP/uip/uip.c **** 	if(BUF->proto != UIP_PROTO_ICMP)
1024:uIP/uip/uip.c **** 	{	/* We only allow ICMP packets from here. */
1025:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.drop);
1026:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.protoerr);
1027:uIP/uip/uip.c **** 		UIP_LOG("ip: neither tcp nor icmp.\r\n");
1028:uIP/uip/uip.c **** 		goto drop;
1029:uIP/uip/uip.c **** 	}
1030:uIP/uip/uip.c **** 
1031:uIP/uip/uip.c **** #if UIP_PINGADDRCONF
1032:uIP/uip/uip.c **** icmp_input:
1033:uIP/uip/uip.c **** 	DEBUG_PRINTF("icmp_input:\r\n");
1034:uIP/uip/uip.c **** #endif /* UIP_PINGADDRCONF */
1035:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.icmp.recv);
1036:uIP/uip/uip.c **** 
1037:uIP/uip/uip.c **** 	/* ICMP echo (i.e., ping) processing. This is simple, we only change
1038:uIP/uip/uip.c **** 		the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
1039:uIP/uip/uip.c **** 		checksum before we return the packet. */
1040:uIP/uip/uip.c **** 	if(ICMPBUF->type != ICMP_ECHO)
1041:uIP/uip/uip.c **** 	{
1042:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.icmp.drop);
1043:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.icmp.typeerr);
1044:uIP/uip/uip.c **** 		UIP_LOG("icmp: not icmp echo.\r\n");
1045:uIP/uip/uip.c **** 		goto drop;
1046:uIP/uip/uip.c **** 	}
1047:uIP/uip/uip.c **** 
1048:uIP/uip/uip.c **** 	/* If we are configured to use ping IP address assignment, we use
1049:uIP/uip/uip.c **** 		the destination IP address of this ping packet and assign it to
1050:uIP/uip/uip.c **** 		ourself. */
1051:uIP/uip/uip.c **** #if UIP_PINGADDRCONF
1052:uIP/uip/uip.c **** 	if((uip_hostaddr[0] | uip_hostaddr[1]) == 0)
1053:uIP/uip/uip.c **** 	{
1054:uIP/uip/uip.c **** 		uip_hostaddr[0] = BUF->destipaddr[0];
1055:uIP/uip/uip.c **** 		uip_hostaddr[1] = BUF->destipaddr[1];
1056:uIP/uip/uip.c **** 	}
1057:uIP/uip/uip.c **** #endif /* UIP_PINGADDRCONF */
1058:uIP/uip/uip.c **** 
1059:uIP/uip/uip.c **** 	ICMPBUF->type = ICMP_ECHO_REPLY;
1060:uIP/uip/uip.c **** 
1061:uIP/uip/uip.c **** 	if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8)))
1062:uIP/uip/uip.c **** 	{
1063:uIP/uip/uip.c **** 		ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
1064:uIP/uip/uip.c **** 	}
1065:uIP/uip/uip.c **** 	else
1066:uIP/uip/uip.c **** 	{
1067:uIP/uip/uip.c **** 		ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
1068:uIP/uip/uip.c **** 	}
1069:uIP/uip/uip.c **** 
1070:uIP/uip/uip.c **** 	/* Swap IP addresses. */
1071:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
1072:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1073:uIP/uip/uip.c **** 
1074:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.icmp.sent);
1075:uIP/uip/uip.c **** 	goto send;
1076:uIP/uip/uip.c **** 
1077:uIP/uip/uip.c ****   /* End of IPv4 input header processing code. */
1078:uIP/uip/uip.c **** #else /* !UIP_CONF_IPV6 */
1079:uIP/uip/uip.c **** 
1080:uIP/uip/uip.c **** 	/* This is IPv6 ICMPv6 processing code. */
1081:uIP/uip/uip.c **** 	DEBUG_PRINTF("icmp6_input: length %d\r\n", uip_len);
1082:uIP/uip/uip.c **** 
1083:uIP/uip/uip.c **** 	if(BUF->proto != UIP_PROTO_ICMP6)
1084:uIP/uip/uip.c **** 	{ /* We only allow ICMPv6 packets from	here. */
1085:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.drop);
1086:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.ip.protoerr);
1087:uIP/uip/uip.c **** 		UIP_LOG("ip: neither tcp nor icmp6.\r\n");
1088:uIP/uip/uip.c **** 		goto drop;
1089:uIP/uip/uip.c **** 	}
1090:uIP/uip/uip.c **** 
1091:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.icmp.recv);
1092:uIP/uip/uip.c **** 
1093:uIP/uip/uip.c **** 	/* If we get a neighbor solicitation for our address we should send
1094:uIP/uip/uip.c **** 	a neighbor advertisement message back. */
1095:uIP/uip/uip.c **** 	if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION)
1096:uIP/uip/uip.c **** 	{
1097:uIP/uip/uip.c **** 		if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr))
1098:uIP/uip/uip.c **** 		{
1099:uIP/uip/uip.c **** 
1100:uIP/uip/uip.c **** 			if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS)
1101:uIP/uip/uip.c **** 			{
1102:uIP/uip/uip.c **** 				/* Save the sender's address in our neighbor list. */
1103:uIP/uip/uip.c **** 				uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
1104:uIP/uip/uip.c **** 			}
1105:uIP/uip/uip.c **** 
1106:uIP/uip/uip.c **** 			/* We should now send a neighbor advertisement back to where the
1107:uIP/uip/uip.c **** 			neighbor solicication came from. */
1108:uIP/uip/uip.c **** 			ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
1109:uIP/uip/uip.c **** 			ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
1110:uIP/uip/uip.c **** 
1111:uIP/uip/uip.c **** 			ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
1112:uIP/uip/uip.c **** 
1113:uIP/uip/uip.c **** 			uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
1114:uIP/uip/uip.c **** 			uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
1115:uIP/uip/uip.c **** 			ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
1116:uIP/uip/uip.c **** 			ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
1117:uIP/uip/uip.c **** 			memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
1118:uIP/uip/uip.c **** 			ICMPBUF->icmpchksum = 0;
1119:uIP/uip/uip.c **** 			ICMPBUF->icmpchksum = ~uip_icmp6chksum();
1120:uIP/uip/uip.c **** 			goto send;
1121:uIP/uip/uip.c **** 
1122:uIP/uip/uip.c **** 		}
1123:uIP/uip/uip.c **** 		goto drop;
1124:uIP/uip/uip.c **** 	}
1125:uIP/uip/uip.c **** 	else if(ICMPBUF->type == ICMP6_ECHO)
1126:uIP/uip/uip.c **** 	{
1127:uIP/uip/uip.c **** 			/* ICMP echo (i.e., ping) processing. This is simple, we only
1128:uIP/uip/uip.c **** 			change the ICMP type from ECHO to ECHO_REPLY and update the
1129:uIP/uip/uip.c **** 			ICMP checksum before we return the packet. */
1130:uIP/uip/uip.c **** 
1131:uIP/uip/uip.c **** 			ICMPBUF->type = ICMP6_ECHO_REPLY;
1132:uIP/uip/uip.c **** 
1133:uIP/uip/uip.c **** 			uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
1134:uIP/uip/uip.c **** 			uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1135:uIP/uip/uip.c **** 			ICMPBUF->icmpchksum = 0;
1136:uIP/uip/uip.c **** 			ICMPBUF->icmpchksum = ~uip_icmp6chksum();
1137:uIP/uip/uip.c **** 
1138:uIP/uip/uip.c **** 			UIP_STAT(++uip_stat.icmp.sent);
1139:uIP/uip/uip.c **** 			goto send;
1140:uIP/uip/uip.c **** 	}
1141:uIP/uip/uip.c **** 	else
1142:uIP/uip/uip.c **** 	{
1143:uIP/uip/uip.c **** 		DEBUG_PRINTF("Unknown icmp6 message type %d\r\n", ICMPBUF->type);
1144:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.icmp.drop);
1145:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.icmp.typeerr);
1146:uIP/uip/uip.c **** 		UIP_LOG("icmp: unknown ICMP message.\r\n");
1147:uIP/uip/uip.c **** 		goto drop;
1148:uIP/uip/uip.c **** 	}
1149:uIP/uip/uip.c **** 
1150:uIP/uip/uip.c **** 	/* End of IPv6 ICMP processing. */
1151:uIP/uip/uip.c **** 
1152:uIP/uip/uip.c **** #endif /* !UIP_CONF_IPV6 */
1153:uIP/uip/uip.c **** 
1154:uIP/uip/uip.c **** #if UIP_UDP
1155:uIP/uip/uip.c **** 	/* UDP input processing. */
1156:uIP/uip/uip.c **** udp_input:
1157:uIP/uip/uip.c **** 	DEBUG_PRINTF("udp_input:\r\n");
1158:uIP/uip/uip.c **** 	/* UDP processing is really just a hack. We don't do anything to the
1159:uIP/uip/uip.c **** 	UDP/IP headers, but let the UDP application do all the hard
1160:uIP/uip/uip.c **** 	work. If the application sets uip_slen, it has a packet to
1161:uIP/uip/uip.c **** 	send. */
1162:uIP/uip/uip.c ****   #if UIP_UDP_CHECKSUMS
1163:uIP/uip/uip.c **** 	uip_len = uip_len - UIP_IPUDPH_LEN;
1164:uIP/uip/uip.c **** 	uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
1165:uIP/uip/uip.c **** 	if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff)
1166:uIP/uip/uip.c **** 	{
1167:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.udp.drop);
1168:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.udp.chkerr);
1169:uIP/uip/uip.c **** 		UIP_LOG("udp: bad checksum.\r\n");
1170:uIP/uip/uip.c **** 		goto drop;
1171:uIP/uip/uip.c **** 	}
1172:uIP/uip/uip.c ****   #else /* UIP_UDP_CHECKSUMS */
1173:uIP/uip/uip.c **** 	uip_len = uip_len - UIP_IPUDPH_LEN;
1174:uIP/uip/uip.c ****   #endif /* UIP_UDP_CHECKSUMS */
1175:uIP/uip/uip.c **** 	/* Demultiplex this UDP packet between the UDP "connections". */
1176:uIP/uip/uip.c **** 	for(uip_udp_conn = &uip_udp_conns[0]; uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];	++uip_udp_conn
1177:uIP/uip/uip.c **** 	{
1178:uIP/uip/uip.c **** 		/* If the local UDP port is non-zero, the connection is considered
1179:uIP/uip/uip.c **** 		to be used. If so, the local port number is checked against the
1180:uIP/uip/uip.c **** 		destination port number in the received packet. If the two port
1181:uIP/uip/uip.c **** 		numbers match, the remote port number is checked if the
1182:uIP/uip/uip.c **** 		connection is bound to a remote port. Finally, if the
1183:uIP/uip/uip.c **** 		connection is bound to a remote IP address, the source IP
1184:uIP/uip/uip.c **** 		address of the packet is checked. */
1185:uIP/uip/uip.c **** 		if(	(uip_udp_conn->lport != 0) && 
1186:uIP/uip/uip.c **** 			(UDPBUF->destport == uip_udp_conn->lport) && 
1187:uIP/uip/uip.c **** 			/*((uip_udp_conn->rport == 0) || (UDPBUF->srcport == uip_udp_conn->rport)) &&*/
1188:uIP/uip/uip.c **** 			(uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) || uip_ipaddr_cmp(uip_udp_conn->ripaddr,
1189:uIP/uip/uip.c **** 		{
1190:uIP/uip/uip.c **** 			goto udp_found;
1191:uIP/uip/uip.c **** 		}
1192:uIP/uip/uip.c **** 	}
1193:uIP/uip/uip.c **** 	
1194:uIP/uip/uip.c **** 	UIP_LOG("udp: no matching connection found.\r\n");
1195:uIP/uip/uip.c **** 	UIP_LOG("(destport(lport)=%d, srcport(rport)=%d, ripaddr=%d.%d.%d.%d)\r\n", UDPBUF->destport, UDPB
1196:uIP/uip/uip.c **** 															uip_ipaddr1(BUF->srcipaddr), uip_ipaddr2(BUF->srcipaddr), uip_ipaddr3(BUF->srcipaddr
1197:uIP/uip/uip.c **** 	goto drop;
1198:uIP/uip/uip.c **** 
1199:uIP/uip/uip.c **** udp_found:
1200:uIP/uip/uip.c **** 	DEBUG_PRINTF("udp_found:\r\n");
1201:uIP/uip/uip.c **** 	uip_conn = NULL;
1202:uIP/uip/uip.c **** 	uip_flags = UIP_NEWDATA;
1203:uIP/uip/uip.c **** 	uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
1204:uIP/uip/uip.c **** 	uip_slen = 0;
1205:uIP/uip/uip.c **** 	DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1206:uIP/uip/uip.c **** 	UIP_UDP_APPCALL();
1207:uIP/uip/uip.c **** 
1208:uIP/uip/uip.c **** udp_send:
1209:uIP/uip/uip.c **** 	DEBUG_PRINTF("udp_send:\r\n");
1210:uIP/uip/uip.c **** 	if(uip_slen == 0)
1211:uIP/uip/uip.c **** 	{
1212:uIP/uip/uip.c **** 		goto drop;
1213:uIP/uip/uip.c **** 	}
1214:uIP/uip/uip.c **** 	uip_len = uip_slen + UIP_IPUDPH_LEN;
1215:uIP/uip/uip.c **** 
1216:uIP/uip/uip.c ****   #if UIP_CONF_IPV6
1217:uIP/uip/uip.c **** 	/* For IPv6, the IP length field does not include the IPv6 IP header
1218:uIP/uip/uip.c **** 	length. */
1219:uIP/uip/uip.c **** 	BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
1220:uIP/uip/uip.c **** 	BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
1221:uIP/uip/uip.c ****   #else /* UIP_CONF_IPV6 */
1222:uIP/uip/uip.c **** 	BUF->len[0] = (uip_len >> 8);
1223:uIP/uip/uip.c **** 	BUF->len[1] = (uip_len & 0xff);
1224:uIP/uip/uip.c ****   #endif /* UIP_CONF_IPV6 */
1225:uIP/uip/uip.c **** 
1226:uIP/uip/uip.c **** 	BUF->ttl = uip_udp_conn->ttl;
1227:uIP/uip/uip.c **** 	BUF->proto = UIP_PROTO_UDP;
1228:uIP/uip/uip.c **** 
1229:uIP/uip/uip.c **** 	UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
1230:uIP/uip/uip.c **** 	UDPBUF->udpchksum = 0;
1231:uIP/uip/uip.c **** 
1232:uIP/uip/uip.c **** 	BUF->srcport  = uip_udp_conn->lport;
1233:uIP/uip/uip.c **** 	BUF->destport = uip_udp_conn->rport;
1234:uIP/uip/uip.c **** 
1235:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1236:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
1237:uIP/uip/uip.c **** 
1238:uIP/uip/uip.c **** 	uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
1239:uIP/uip/uip.c **** 
1240:uIP/uip/uip.c ****   #if UIP_UDP_CHECKSUMS
1241:uIP/uip/uip.c **** 	/* Calculate UDP checksum. */
1242:uIP/uip/uip.c **** 	UDPBUF->udpchksum = ~(uip_udpchksum());
1243:uIP/uip/uip.c **** 	if(UDPBUF->udpchksum == 0)
1244:uIP/uip/uip.c **** 	{
1245:uIP/uip/uip.c **** 	 UDPBUF->udpchksum = 0xffff;
1246:uIP/uip/uip.c **** 	}
1247:uIP/uip/uip.c ****   #endif /* UIP_UDP_CHECKSUMS */
1248:uIP/uip/uip.c **** 
1249:uIP/uip/uip.c **** 	goto ip_send_nolen;
1250:uIP/uip/uip.c **** 
1251:uIP/uip/uip.c **** #endif /* UIP_UDP */
1252:uIP/uip/uip.c **** 
1253:uIP/uip/uip.c ****   /* TCP input processing. */
1254:uIP/uip/uip.c **** tcp_input:
1255:uIP/uip/uip.c **** 
1256:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_input:\r\n");
1257:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.tcp.recv);
1258:uIP/uip/uip.c **** 
1259:uIP/uip/uip.c **** 	/* Start of TCP input header processing code. */
1260:uIP/uip/uip.c **** 
1261:uIP/uip/uip.c **** 	if(uip_tcpchksum() != 0xffff)
1262:uIP/uip/uip.c **** 	{   /* Compute and check the TCP checksum. */
1263:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.tcp.drop);
1264:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.tcp.chkerr);
1265:uIP/uip/uip.c **** 		UIP_LOG("tcp: bad checksum.\r\n");
1266:uIP/uip/uip.c **** 		goto drop;
1267:uIP/uip/uip.c **** 	}
1268:uIP/uip/uip.c **** 
1269:uIP/uip/uip.c **** 
1270:uIP/uip/uip.c **** 	/* Demultiplex this segment. */
1271:uIP/uip/uip.c **** 	/* First check any active connections. */
1272:uIP/uip/uip.c **** 	for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr)
1273:uIP/uip/uip.c **** 	{
1274:uIP/uip/uip.c **** 		if(uip_connr->tcpstateflags != UIP_CLOSED && BUF->destport == uip_connr->lport && BUF->srcport ==
1275:uIP/uip/uip.c **** 		{
1276:uIP/uip/uip.c **** 			goto found;
1277:uIP/uip/uip.c **** 		}
1278:uIP/uip/uip.c **** 	}
1279:uIP/uip/uip.c **** 
1280:uIP/uip/uip.c **** 	/* If we didn't find and active connection that expected the packet,
1281:uIP/uip/uip.c **** 	either this packet is an old duplicate, or this is a SYN packet
1282:uIP/uip/uip.c **** 	destined for a connection in LISTEN. If the SYN flag isn't set,
1283:uIP/uip/uip.c **** 	it is an old packet and we send a RST. */
1284:uIP/uip/uip.c **** 	if((BUF->flags & TCP_CTL) != TCP_SYN)
1285:uIP/uip/uip.c **** 	{
1286:uIP/uip/uip.c **** 		goto reset;
1287:uIP/uip/uip.c **** 	}
1288:uIP/uip/uip.c **** 
1289:uIP/uip/uip.c **** 	tmp16 = BUF->destport;
1290:uIP/uip/uip.c **** 	/* Next, check listening connections. */
1291:uIP/uip/uip.c **** 	for(c = 0; c < UIP_LISTENPORTS; ++c)
1292:uIP/uip/uip.c **** 	{
1293:uIP/uip/uip.c **** 		if(tmp16 == uip_listenports[c])
1294:uIP/uip/uip.c **** 			goto found_listen;
1295:uIP/uip/uip.c **** 	}
1296:uIP/uip/uip.c **** 
1297:uIP/uip/uip.c **** 	/* No matching connection found, so we send a RST packet. */
1298:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.tcp.synrst);
1299:uIP/uip/uip.c **** reset:
1300:uIP/uip/uip.c **** 
1301:uIP/uip/uip.c **** 	DEBUG_PRINTF("reset:\r\n");
1302:uIP/uip/uip.c **** 	/* We do not send resets in response to resets. */
1303:uIP/uip/uip.c **** 	if(BUF->flags & TCP_RST)
1304:uIP/uip/uip.c **** 	{
1305:uIP/uip/uip.c **** 		goto drop;
1306:uIP/uip/uip.c **** 	}
1307:uIP/uip/uip.c **** 
1308:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.tcp.rst);
1309:uIP/uip/uip.c **** 
1310:uIP/uip/uip.c **** 	BUF->flags = TCP_RST | TCP_ACK;
1311:uIP/uip/uip.c **** 	uip_len = UIP_IPTCPH_LEN;
1312:uIP/uip/uip.c **** 	BUF->tcpoffset = 5 << 4;
1313:uIP/uip/uip.c **** 
1314:uIP/uip/uip.c **** 	/* Flip the seqno and ackno fields in the TCP header. */
1315:uIP/uip/uip.c **** 	c = BUF->seqno[3];
1316:uIP/uip/uip.c **** 	BUF->seqno[3] = BUF->ackno[3];
1317:uIP/uip/uip.c **** 	BUF->ackno[3] = c;
1318:uIP/uip/uip.c **** 
1319:uIP/uip/uip.c **** 	c = BUF->seqno[2];
1320:uIP/uip/uip.c **** 	BUF->seqno[2] = BUF->ackno[2];
1321:uIP/uip/uip.c **** 	BUF->ackno[2] = c;
1322:uIP/uip/uip.c **** 
1323:uIP/uip/uip.c **** 	c = BUF->seqno[1];
1324:uIP/uip/uip.c **** 	BUF->seqno[1] = BUF->ackno[1];
1325:uIP/uip/uip.c **** 	BUF->ackno[1] = c;
1326:uIP/uip/uip.c **** 
1327:uIP/uip/uip.c **** 	c = BUF->seqno[0];
1328:uIP/uip/uip.c **** 	BUF->seqno[0] = BUF->ackno[0];
1329:uIP/uip/uip.c **** 	BUF->ackno[0] = c;
1330:uIP/uip/uip.c **** 
1331:uIP/uip/uip.c **** 	/* We also have to increase the sequence number we are
1332:uIP/uip/uip.c **** 	acknowledging. If the least significant byte overflowed, we need
1333:uIP/uip/uip.c **** 	to propagate the carry to the other bytes as well. */
1334:uIP/uip/uip.c **** 	if(++BUF->ackno[3] == 0)
1335:uIP/uip/uip.c **** 	{
1336:uIP/uip/uip.c **** 		if(++BUF->ackno[2] == 0)
1337:uIP/uip/uip.c **** 		{
1338:uIP/uip/uip.c **** 			if(++BUF->ackno[1] == 0)
1339:uIP/uip/uip.c **** 			{
1340:uIP/uip/uip.c **** 				++BUF->ackno[0];
1341:uIP/uip/uip.c **** 			}
1342:uIP/uip/uip.c **** 		}
1343:uIP/uip/uip.c **** 	}
1344:uIP/uip/uip.c **** 
1345:uIP/uip/uip.c **** 	/* Swap port numbers. */
1346:uIP/uip/uip.c **** 	tmp16 = BUF->srcport;
1347:uIP/uip/uip.c **** 	BUF->srcport = BUF->destport;
1348:uIP/uip/uip.c **** 	BUF->destport = tmp16;
1349:uIP/uip/uip.c **** 
1350:uIP/uip/uip.c **** 	/* Swap IP addresses. */
1351:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
1352:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1353:uIP/uip/uip.c **** 
1354:uIP/uip/uip.c **** 	/* And send out the RST packet! */
1355:uIP/uip/uip.c **** 	goto tcp_send_noconn;
1356:uIP/uip/uip.c **** 
1357:uIP/uip/uip.c **** /* This label will be jumped to if we matched the incoming packet
1358:uIP/uip/uip.c **** with a connection in LISTEN. In that case, we should create a new
1359:uIP/uip/uip.c **** connection and send a SYNACK in return. */
1360:uIP/uip/uip.c **** found_listen:
1361:uIP/uip/uip.c **** 
1362:uIP/uip/uip.c **** 	DEBUG_PRINTF("found_listen:\r\n");
1363:uIP/uip/uip.c **** 	/* First we check if there are any connections avaliable. Unused
1364:uIP/uip/uip.c **** 	connections are kept in the same table as used connections, but
1365:uIP/uip/uip.c **** 	unused ones have the tcpstate set to CLOSED. Also, connections in
1366:uIP/uip/uip.c **** 	TIME_WAIT are kept track of and we'll use the oldest one if no
1367:uIP/uip/uip.c **** 	CLOSED connections are found. Thanks to Eddie C. Dost for a very
1368:uIP/uip/uip.c **** 	nice algorithm for the TIME_WAIT search. */
1369:uIP/uip/uip.c **** 	uip_connr = 0;
1370:uIP/uip/uip.c **** 	for(c = 0; c < UIP_CONNS; ++c)
1371:uIP/uip/uip.c **** 	{
1372:uIP/uip/uip.c **** 		if(uip_conns[c].tcpstateflags == UIP_CLOSED)
1373:uIP/uip/uip.c **** 		{
1374:uIP/uip/uip.c **** 			uip_connr = &uip_conns[c];
1375:uIP/uip/uip.c **** 			break;
1376:uIP/uip/uip.c **** 		}
1377:uIP/uip/uip.c **** 		if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT)
1378:uIP/uip/uip.c **** 		{
1379:uIP/uip/uip.c **** 			if(uip_connr == 0 ||uip_conns[c].timer > uip_connr->timer)
1380:uIP/uip/uip.c **** 			{
1381:uIP/uip/uip.c **** 				uip_connr = &uip_conns[c];
1382:uIP/uip/uip.c **** 			}
1383:uIP/uip/uip.c **** 		}
1384:uIP/uip/uip.c **** 	}
1385:uIP/uip/uip.c **** 
1386:uIP/uip/uip.c **** 	if(uip_connr == 0)
1387:uIP/uip/uip.c **** 	{
1388:uIP/uip/uip.c **** 		/* All connections are used already, we drop packet and hope that
1389:uIP/uip/uip.c **** 		the remote end will retransmit the packet at a time when we
1390:uIP/uip/uip.c **** 		have more spare connections. */
1391:uIP/uip/uip.c **** 		UIP_STAT(++uip_stat.tcp.syndrop);
1392:uIP/uip/uip.c **** 		UIP_LOG("tcp: found no unused connections.\r\n");
1393:uIP/uip/uip.c **** 		goto drop;
1394:uIP/uip/uip.c **** 	}
1395:uIP/uip/uip.c **** 
1396:uIP/uip/uip.c **** 	uip_conn = uip_connr;
1397:uIP/uip/uip.c **** 
1398:uIP/uip/uip.c **** 	/* Fill in the necessary fields for the new connection. */
1399:uIP/uip/uip.c **** 	uip_connr->rto = uip_connr->timer = UIP_RTO;
1400:uIP/uip/uip.c **** 	uip_connr->sa = 0;
1401:uIP/uip/uip.c **** 	uip_connr->sv = 4;
1402:uIP/uip/uip.c **** 	uip_connr->nrtx = 0;
1403:uIP/uip/uip.c **** 	uip_connr->lport = BUF->destport;
1404:uIP/uip/uip.c **** 	uip_connr->rport = BUF->srcport;
1405:uIP/uip/uip.c **** 	uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
1406:uIP/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_SYN_RCVD;
1407:uIP/uip/uip.c **** 
1408:uIP/uip/uip.c **** 	uip_connr->snd_nxt[0] = iss[0];
1409:uIP/uip/uip.c **** 	uip_connr->snd_nxt[1] = iss[1];
1410:uIP/uip/uip.c **** 	uip_connr->snd_nxt[2] = iss[2];
1411:uIP/uip/uip.c **** 	uip_connr->snd_nxt[3] = iss[3];
1412:uIP/uip/uip.c **** 	uip_connr->len = 1;
1413:uIP/uip/uip.c **** 
1414:uIP/uip/uip.c **** 	/* rcv_nxt should be the seqno from the incoming packet + 1. */
1415:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[3] = BUF->seqno[3];
1416:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[2] = BUF->seqno[2];
1417:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[1] = BUF->seqno[1];
1418:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[0] = BUF->seqno[0];
1419:uIP/uip/uip.c **** 	uip_add_rcv_nxt(1);
1420:uIP/uip/uip.c **** 
1421:uIP/uip/uip.c **** 	/* Parse the TCP MSS option, if present. */
1422:uIP/uip/uip.c **** 	if((BUF->tcpoffset & 0xf0) > 0x50)
1423:uIP/uip/uip.c **** 	{
1424:uIP/uip/uip.c **** 		for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
1425:uIP/uip/uip.c **** 		{
1426:uIP/uip/uip.c **** 			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
1427:uIP/uip/uip.c **** 			if(opt == TCP_OPT_END)
1428:uIP/uip/uip.c **** 			{
1429:uIP/uip/uip.c **** 				/* End of options. */
1430:uIP/uip/uip.c **** 				break;
1431:uIP/uip/uip.c **** 			}
1432:uIP/uip/uip.c **** 			else if(opt == TCP_OPT_NOOP)
1433:uIP/uip/uip.c **** 			{
1434:uIP/uip/uip.c **** 				++c;
1435:uIP/uip/uip.c **** 				/* NOP option. */
1436:uIP/uip/uip.c **** 			}
1437:uIP/uip/uip.c **** 			else if(opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN)
1438:uIP/uip/uip.c **** 			{
1439:uIP/uip/uip.c **** 				/* An MSS option with the right option length. */
1440:uIP/uip/uip.c **** 				tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) | (u16_t)uip_buf[UIP_IPTCPH
1441:uIP/uip/uip.c **** 				uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
1442:uIP/uip/uip.c **** 
1443:uIP/uip/uip.c **** 				/* And we are done processing options. */
1444:uIP/uip/uip.c **** 				break;
1445:uIP/uip/uip.c **** 			}
1446:uIP/uip/uip.c **** 			else
1447:uIP/uip/uip.c **** 			{
1448:uIP/uip/uip.c **** 				/* All other options have a length field, so that we easily
1449:uIP/uip/uip.c **** 				can skip past them. */
1450:uIP/uip/uip.c **** 				if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0)
1451:uIP/uip/uip.c **** 				{
1452:uIP/uip/uip.c **** 				/* If the length field is zero, the options are malformed
1453:uIP/uip/uip.c **** 					and we don't process them further. */
1454:uIP/uip/uip.c **** 					break;
1455:uIP/uip/uip.c **** 				}
1456:uIP/uip/uip.c **** 
1457:uIP/uip/uip.c **** 				c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
1458:uIP/uip/uip.c **** 			}
1459:uIP/uip/uip.c **** 		}
1460:uIP/uip/uip.c **** 	}
1461:uIP/uip/uip.c **** 
1462:uIP/uip/uip.c **** /* Our response will be a SYNACK. */
1463:uIP/uip/uip.c **** #if UIP_ACTIVE_OPEN
1464:uIP/uip/uip.c **** tcp_send_synack:
1465:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_synack:\r\n");
1466:uIP/uip/uip.c **** 	BUF->flags = TCP_ACK;
1467:uIP/uip/uip.c **** 
1468:uIP/uip/uip.c **** tcp_send_syn:
1469:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_syn:\r\n");
1470:uIP/uip/uip.c **** 	BUF->flags |= TCP_SYN;
1471:uIP/uip/uip.c **** #else /* UIP_ACTIVE_OPEN */
1472:uIP/uip/uip.c **** tcp_send_synack:
1473:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_synack (!UIP_ACTIVE_OPEN):\r\n");
1474:uIP/uip/uip.c **** 	BUF->flags = TCP_SYN | TCP_ACK;
1475:uIP/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
1476:uIP/uip/uip.c **** 
1477:uIP/uip/uip.c **** 	/* We send out the TCP Maximum Segment Size option with our
1478:uIP/uip/uip.c **** 	SYNACK. */
1479:uIP/uip/uip.c **** 	BUF->optdata[0] = TCP_OPT_MSS;
1480:uIP/uip/uip.c **** 	BUF->optdata[1] = TCP_OPT_MSS_LEN;
1481:uIP/uip/uip.c **** 	BUF->optdata[2] = (UIP_TCP_MSS) / 256;
1482:uIP/uip/uip.c **** 	BUF->optdata[3] = (UIP_TCP_MSS) & 255;
1483:uIP/uip/uip.c **** 	uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
1484:uIP/uip/uip.c **** 	BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
1485:uIP/uip/uip.c **** 	goto tcp_send;
1486:uIP/uip/uip.c **** 
1487:uIP/uip/uip.c **** /* This label will be jumped to if we found an active connection. */
1488:uIP/uip/uip.c **** found:
1489:uIP/uip/uip.c **** 	DEBUG_PRINTF("found:\r\n");
1490:uIP/uip/uip.c **** 	uip_conn = uip_connr;
1491:uIP/uip/uip.c **** 	uip_flags = 0;
1492:uIP/uip/uip.c **** 	/* We do a very naive form of TCP reset processing; we just accept
1493:uIP/uip/uip.c **** 	any RST and kill our connection. We should in fact check if the
1494:uIP/uip/uip.c **** 	sequence number of this reset is wihtin our advertised window
1495:uIP/uip/uip.c **** 	before we accept the reset. */
1496:uIP/uip/uip.c **** 	if(BUF->flags & TCP_RST)
1497:uIP/uip/uip.c **** 	{
1498:uIP/uip/uip.c **** 		uip_connr->tcpstateflags = UIP_CLOSED;
1499:uIP/uip/uip.c **** 		UIP_LOG("tcp: got reset, aborting connection.\r\n");
1500:uIP/uip/uip.c **** 		uip_flags = UIP_ABORT;
1501:uIP/uip/uip.c **** 		DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1502:uIP/uip/uip.c **** 		UIP_APPCALL();
1503:uIP/uip/uip.c **** 		goto drop;
1504:uIP/uip/uip.c **** 	}
1505:uIP/uip/uip.c **** 	/* Calculated the length of the data, if the application has sent
1506:uIP/uip/uip.c **** 	any data to us. */
1507:uIP/uip/uip.c **** 	c = (BUF->tcpoffset >> 4) << 2;
1508:uIP/uip/uip.c **** 	/* uip_len will contain the length of the actual TCP data. This is
1509:uIP/uip/uip.c **** 	calculated by subtracing the length of the TCP header (in
1510:uIP/uip/uip.c **** 	c) and the length of the IP header (20 bytes). */
1511:uIP/uip/uip.c **** 	uip_len = uip_len - c - UIP_IPH_LEN;
1512:uIP/uip/uip.c **** 
1513:uIP/uip/uip.c **** 	/* First, check if the sequence number of the incoming packet is
1514:uIP/uip/uip.c **** 	what we're expecting next. If not, we send out an ACK with the
1515:uIP/uip/uip.c **** 	correct numbers in. */
1516:uIP/uip/uip.c **** 	if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP
1517:uIP/uip/uip.c **** 	{
1518:uIP/uip/uip.c **** 		if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
1519:uIP/uip/uip.c **** 			(BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
1520:uIP/uip/uip.c **** 			 BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
1521:uIP/uip/uip.c **** 			 BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
1522:uIP/uip/uip.c **** 			 BUF->seqno[3] != uip_connr->rcv_nxt[3]))
1523:uIP/uip/uip.c **** 		{
1524:uIP/uip/uip.c **** 			goto tcp_send_ack;
1525:uIP/uip/uip.c **** 		}
1526:uIP/uip/uip.c **** 	}
1527:uIP/uip/uip.c **** 
1528:uIP/uip/uip.c **** 	/* Next, check if the incoming segment acknowledges any outstanding
1529:uIP/uip/uip.c **** 	data. If so, we update the sequence number, reset the length of
1530:uIP/uip/uip.c **** 	the outstanding data, calculate RTT estimations, and reset the
1531:uIP/uip/uip.c **** 	retransmission timer. */
1532:uIP/uip/uip.c **** 	if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr))
1533:uIP/uip/uip.c **** 	{
1534:uIP/uip/uip.c **** 		uip_add32(uip_connr->snd_nxt, uip_connr->len);
1535:uIP/uip/uip.c **** 
1536:uIP/uip/uip.c **** 		if( BUF->ackno[0] == uip_acc32[0] &&
1537:uIP/uip/uip.c **** 			BUF->ackno[1] == uip_acc32[1] &&
1538:uIP/uip/uip.c **** 			BUF->ackno[2] == uip_acc32[2] &&
1539:uIP/uip/uip.c **** 			BUF->ackno[3] == uip_acc32[3])
1540:uIP/uip/uip.c **** 		{
1541:uIP/uip/uip.c **** 			/* Update sequence number. */
1542:uIP/uip/uip.c **** 			uip_connr->snd_nxt[0] = uip_acc32[0];
1543:uIP/uip/uip.c **** 			uip_connr->snd_nxt[1] = uip_acc32[1];
1544:uIP/uip/uip.c **** 			uip_connr->snd_nxt[2] = uip_acc32[2];
1545:uIP/uip/uip.c **** 			uip_connr->snd_nxt[3] = uip_acc32[3];
1546:uIP/uip/uip.c **** 
1547:uIP/uip/uip.c **** 
1548:uIP/uip/uip.c **** 			/* Do RTT estimation, unless we have done retransmissions. */
1549:uIP/uip/uip.c **** 			if(uip_connr->nrtx == 0)
1550:uIP/uip/uip.c **** 			{
1551:uIP/uip/uip.c **** 				signed char m;
1552:uIP/uip/uip.c **** 				m = uip_connr->rto - uip_connr->timer;
1553:uIP/uip/uip.c **** 				/* This is taken directly from VJs original code in his paper */
1554:uIP/uip/uip.c **** 				m = m - (uip_connr->sa >> 3);
1555:uIP/uip/uip.c **** 				uip_connr->sa += m;
1556:uIP/uip/uip.c **** 				if(m < 0)
1557:uIP/uip/uip.c **** 				{
1558:uIP/uip/uip.c **** 					m = -m;
1559:uIP/uip/uip.c **** 				}
1560:uIP/uip/uip.c **** 				m = m - (uip_connr->sv >> 2);
1561:uIP/uip/uip.c **** 				uip_connr->sv += m;
1562:uIP/uip/uip.c **** 				uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
1563:uIP/uip/uip.c **** 			}
1564:uIP/uip/uip.c **** 			/* Set the acknowledged flag. */
1565:uIP/uip/uip.c **** 			uip_flags = UIP_ACKDATA;
1566:uIP/uip/uip.c **** 			/* Reset the retransmission timer. */
1567:uIP/uip/uip.c **** 			uip_connr->timer = uip_connr->rto;
1568:uIP/uip/uip.c **** 
1569:uIP/uip/uip.c **** 			/* Reset length of outstanding data. */
1570:uIP/uip/uip.c **** 			uip_connr->len = 0;
1571:uIP/uip/uip.c **** 		}
1572:uIP/uip/uip.c **** 	}
1573:uIP/uip/uip.c **** 
1574:uIP/uip/uip.c **** 	/* Do different things depending on in what state the connection is. */
1575:uIP/uip/uip.c **** 	switch(uip_connr->tcpstateflags & UIP_TS_MASK)
1576:uIP/uip/uip.c **** 	{
1577:uIP/uip/uip.c **** 		/* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
1578:uIP/uip/uip.c **** 		implemented, since we force the application to close when the
1579:uIP/uip/uip.c **** 		peer sends a FIN (hence the application goes directly from
1580:uIP/uip/uip.c **** 		ESTABLISHED to LAST_ACK). */
1581:uIP/uip/uip.c **** 	case UIP_SYN_RCVD:
1582:uIP/uip/uip.c **** 		/* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
1583:uIP/uip/uip.c **** 		we are waiting for an ACK that acknowledges the data we sent
1584:uIP/uip/uip.c **** 		out the last time. Therefore, we want to have the UIP_ACKDATA
1585:uIP/uip/uip.c **** 		flag set. If so, we enter the ESTABLISHED state. */
1586:uIP/uip/uip.c **** 		if(uip_flags & UIP_ACKDATA)
1587:uIP/uip/uip.c **** 		{
1588:uIP/uip/uip.c **** 			uip_connr->tcpstateflags = UIP_ESTABLISHED;
1589:uIP/uip/uip.c **** 			uip_flags = UIP_CONNECTED;
1590:uIP/uip/uip.c **** 			uip_connr->len = 0;
1591:uIP/uip/uip.c **** 			if(uip_len > 0)
1592:uIP/uip/uip.c **** 			{
1593:uIP/uip/uip.c **** 				uip_flags |= UIP_NEWDATA;
1594:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
1595:uIP/uip/uip.c **** 			}
1596:uIP/uip/uip.c **** 			uip_slen = 0;
1597:uIP/uip/uip.c **** 			DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1598:uIP/uip/uip.c **** 			UIP_APPCALL();
1599:uIP/uip/uip.c **** 			goto appsend;
1600:uIP/uip/uip.c **** 		}
1601:uIP/uip/uip.c **** 		goto drop;
1602:uIP/uip/uip.c **** #if UIP_ACTIVE_OPEN
1603:uIP/uip/uip.c **** 		case UIP_SYN_SENT:
1604:uIP/uip/uip.c **** 			/* In SYN_SENT, we wait for a SYNACK that is sent in response to
1605:uIP/uip/uip.c **** 			our SYN. The rcv_nxt is set to sequence number in the SYNACK
1606:uIP/uip/uip.c **** 			plus one, and we send an ACK. We move into the ESTABLISHED
1607:uIP/uip/uip.c **** 			state. */
1608:uIP/uip/uip.c **** 			if((uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))
1609:uIP/uip/uip.c **** 			{
1610:uIP/uip/uip.c **** 
1611:uIP/uip/uip.c **** 				/* Parse the TCP MSS option, if present. */
1612:uIP/uip/uip.c **** 				if((BUF->tcpoffset & 0xf0) > 0x50)
1613:uIP/uip/uip.c **** 				{
1614:uIP/uip/uip.c **** 					for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
1615:uIP/uip/uip.c **** 					{
1616:uIP/uip/uip.c **** 						opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
1617:uIP/uip/uip.c **** 						if(opt == TCP_OPT_END)
1618:uIP/uip/uip.c **** 						{
1619:uIP/uip/uip.c **** 							/* End of options. */
1620:uIP/uip/uip.c **** 							break;
1621:uIP/uip/uip.c **** 						}
1622:uIP/uip/uip.c **** 						else if(opt == TCP_OPT_NOOP)
1623:uIP/uip/uip.c **** 						{
1624:uIP/uip/uip.c **** 							++c;
1625:uIP/uip/uip.c **** 							/* NOP option. */
1626:uIP/uip/uip.c **** 						}
1627:uIP/uip/uip.c **** 						else if(opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LE
1628:uIP/uip/uip.c **** 						{
1629:uIP/uip/uip.c **** 							/* An MSS option with the right option length. */
1630:uIP/uip/uip.c **** 							tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) | uip_buf[UIP_TCPIP_HLEN + UIP_
1631:uIP/uip/uip.c **** 							uip_connr->initialmss =	uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
1632:uIP/uip/uip.c **** 
1633:uIP/uip/uip.c **** 							/* And we are done processing options. */
1634:uIP/uip/uip.c **** 							break;
1635:uIP/uip/uip.c **** 						}
1636:uIP/uip/uip.c **** 						else
1637:uIP/uip/uip.c **** 						{
1638:uIP/uip/uip.c **** 							/* All other options have a length field, so that we easily
1639:uIP/uip/uip.c **** 								can skip past them. */
1640:uIP/uip/uip.c **** 							if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0)
1641:uIP/uip/uip.c **** 							{
1642:uIP/uip/uip.c **** 								/* If the length field is zero, the options are malformed
1643:uIP/uip/uip.c **** 								and we don't process them further. */
1644:uIP/uip/uip.c **** 								break;
1645:uIP/uip/uip.c **** 							}
1646:uIP/uip/uip.c **** 							c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
1647:uIP/uip/uip.c **** 						}
1648:uIP/uip/uip.c **** 					}
1649:uIP/uip/uip.c **** 				}
1650:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_ESTABLISHED;
1651:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[0] = BUF->seqno[0];
1652:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[1] = BUF->seqno[1];
1653:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[2] = BUF->seqno[2];
1654:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[3] = BUF->seqno[3];
1655:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1);
1656:uIP/uip/uip.c **** 				uip_flags = UIP_CONNECTED | UIP_NEWDATA;
1657:uIP/uip/uip.c **** 				uip_connr->len = 0;
1658:uIP/uip/uip.c **** 				uip_len = 0;
1659:uIP/uip/uip.c **** 				uip_slen = 0;
1660:uIP/uip/uip.c **** 				DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1661:uIP/uip/uip.c **** 				UIP_APPCALL();
1662:uIP/uip/uip.c **** 				goto appsend;
1663:uIP/uip/uip.c **** 			}
1664:uIP/uip/uip.c **** 			/* Inform the application that the connection failed */
1665:uIP/uip/uip.c **** 			uip_flags = UIP_ABORT;
1666:uIP/uip/uip.c **** 			DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1667:uIP/uip/uip.c **** 			UIP_APPCALL();
1668:uIP/uip/uip.c **** 			/* The connection is closed after we send the RST */
1669:uIP/uip/uip.c **** 			uip_conn->tcpstateflags = UIP_CLOSED;
1670:uIP/uip/uip.c **** 			goto reset;
1671:uIP/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
1672:uIP/uip/uip.c **** 
1673:uIP/uip/uip.c **** 		case UIP_ESTABLISHED:
1674:uIP/uip/uip.c **** 			/* In the ESTABLISHED state, we call upon the application to feed
1675:uIP/uip/uip.c **** 			data into the uip_buf. If the UIP_ACKDATA flag is set, the
1676:uIP/uip/uip.c **** 			application should put new data into the buffer, otherwise we are
1677:uIP/uip/uip.c **** 			retransmitting an old segment, and the application should put that
1678:uIP/uip/uip.c **** 			data into the buffer.
1679:uIP/uip/uip.c **** 
1680:uIP/uip/uip.c **** 			If the incoming packet is a FIN, we should close the connection on
1681:uIP/uip/uip.c **** 			this side as well, and we send out a FIN and enter the LAST_ACK
1682:uIP/uip/uip.c **** 			state. We require that there is no outstanding data; otherwise the
1683:uIP/uip/uip.c **** 			sequence numbers will be screwed up. */
1684:uIP/uip/uip.c **** 
1685:uIP/uip/uip.c **** 			if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED))
1686:uIP/uip/uip.c **** 			{
1687:uIP/uip/uip.c **** 				if(uip_outstanding(uip_connr))
1688:uIP/uip/uip.c **** 				{
1689:uIP/uip/uip.c **** 					goto drop;
1690:uIP/uip/uip.c **** 				}
1691:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1 + uip_len);
1692:uIP/uip/uip.c **** 				uip_flags |= UIP_CLOSE;
1693:uIP/uip/uip.c **** 				if(uip_len > 0)
1694:uIP/uip/uip.c **** 				{
1695:uIP/uip/uip.c **** 					uip_flags |= UIP_NEWDATA;
1696:uIP/uip/uip.c **** 				}
1697:uIP/uip/uip.c **** 				DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1698:uIP/uip/uip.c **** 				UIP_APPCALL();
1699:uIP/uip/uip.c **** 				uip_connr->len = 1;
1700:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_LAST_ACK;
1701:uIP/uip/uip.c **** 				uip_connr->nrtx = 0;
1702:uIP/uip/uip.c **** 	DEBUG_PRINTF("no ");
1703:uIP/uip/uip.c **** tcp_send_finack:
1704:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_finack: flaw!!\r\n");
1705:uIP/uip/uip.c **** 				BUF->flags = TCP_FIN | TCP_ACK;
1706:uIP/uip/uip.c **** 				goto tcp_send_nodata;
1707:uIP/uip/uip.c **** 			}
1708:uIP/uip/uip.c **** 
1709:uIP/uip/uip.c **** 			/* Check the URG flag. If this is set, the segment carries urgent
1710:uIP/uip/uip.c **** 			data that we must pass to the application. */
1711:uIP/uip/uip.c **** 			if((BUF->flags & TCP_URG) != 0)
1712:uIP/uip/uip.c **** 			{
1713:uIP/uip/uip.c **** #if UIP_URGDATA > 0
1714:uIP/uip/uip.c **** 				uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
1715:uIP/uip/uip.c **** 				if(uip_urglen > uip_len)
1716:uIP/uip/uip.c **** 				{
1717:uIP/uip/uip.c **** 					/* There is more urgent data in the next segment to come. */
1718:uIP/uip/uip.c **** 					uip_urglen = uip_len;
1719:uIP/uip/uip.c **** 				}
1720:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_urglen);
1721:uIP/uip/uip.c **** 				uip_len -= uip_urglen;
1722:uIP/uip/uip.c **** 				uip_urgdata = uip_appdata;
1723:uIP/uip/uip.c **** 				uip_appdata += uip_urglen;
1724:uIP/uip/uip.c **** 			}
1725:uIP/uip/uip.c **** 			else
1726:uIP/uip/uip.c **** 			{
1727:uIP/uip/uip.c **** 				uip_urglen = 0;
1728:uIP/uip/uip.c **** #else /* UIP_URGDATA > 0 */
1729:uIP/uip/uip.c **** 				uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
1730:uIP/uip/uip.c **** 				uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
1731:uIP/uip/uip.c **** #endif /* UIP_URGDATA > 0 */
1732:uIP/uip/uip.c **** 			}
1733:uIP/uip/uip.c **** 
1734:uIP/uip/uip.c **** 			/* If uip_len > 0 we have TCP data in the packet, and we flag this
1735:uIP/uip/uip.c **** 			by setting the UIP_NEWDATA flag and update the sequence number
1736:uIP/uip/uip.c **** 			we acknowledge. If the application has stopped the dataflow
1737:uIP/uip/uip.c **** 			using uip_stop(), we must not accept any data packets from the
1738:uIP/uip/uip.c **** 			remote host. */
1739:uIP/uip/uip.c **** 			if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED))
1740:uIP/uip/uip.c **** 			{
1741:uIP/uip/uip.c **** 				uip_flags |= UIP_NEWDATA;
1742:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
1743:uIP/uip/uip.c **** 			}
1744:uIP/uip/uip.c **** 
1745:uIP/uip/uip.c **** 			/* Check if the available buffer space advertised by the other end
1746:uIP/uip/uip.c **** 			is smaller than the initial MSS for this connection. If so, we
1747:uIP/uip/uip.c **** 			set the current MSS to the window size to ensure that the
1748:uIP/uip/uip.c **** 			application does not send more data than the other end can
1749:uIP/uip/uip.c **** 			handle.
1750:uIP/uip/uip.c **** 
1751:uIP/uip/uip.c **** 			If the remote host advertises a zero window, we set the MSS to
1752:uIP/uip/uip.c **** 			the initial MSS so that the application will send an entire MSS
1753:uIP/uip/uip.c **** 			of data. This data will not be acknowledged by the receiver,
1754:uIP/uip/uip.c **** 			and the application will retransmit it. This is called the
1755:uIP/uip/uip.c **** 			"persistent timer" and uses the retransmission mechanim.
1756:uIP/uip/uip.c **** 			*/
1757:uIP/uip/uip.c **** 			tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
1758:uIP/uip/uip.c **** 			if(tmp16 > uip_connr->initialmss || tmp16 == 0)
1759:uIP/uip/uip.c **** 			{
1760:uIP/uip/uip.c **** 				tmp16 = uip_connr->initialmss;
1761:uIP/uip/uip.c **** 			}
1762:uIP/uip/uip.c **** 			uip_connr->mss = tmp16;
1763:uIP/uip/uip.c **** 
1764:uIP/uip/uip.c **** 			/* If this packet constitutes an ACK for outstanding data (flagged
1765:uIP/uip/uip.c **** 			by the UIP_ACKDATA flag, we should call the application since it
1766:uIP/uip/uip.c **** 			might want to send more data. If the incoming packet had data
1767:uIP/uip/uip.c **** 			from the peer (as flagged by the UIP_NEWDATA flag), the
1768:uIP/uip/uip.c **** 			application must also be notified.
1769:uIP/uip/uip.c **** 
1770:uIP/uip/uip.c **** 			When the application is called, the global variable uip_len
1771:uIP/uip/uip.c **** 			contains the length of the incoming data. The application can
1772:uIP/uip/uip.c **** 			access the incoming data through the global pointer
1773:uIP/uip/uip.c **** 			uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
1774:uIP/uip/uip.c **** 			bytes into the uip_buf array.
1775:uIP/uip/uip.c **** 
1776:uIP/uip/uip.c **** 			If the application wishes to send any data, this data should be
1777:uIP/uip/uip.c **** 			put into the uip_appdata and the length of the data should be
1778:uIP/uip/uip.c **** 			put into uip_len. If the application don't have any data to
1779:uIP/uip/uip.c **** 			send, uip_len must be set to 0. */
1780:uIP/uip/uip.c **** 			if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA))
1781:uIP/uip/uip.c **** 			{
1782:uIP/uip/uip.c **** 				uip_slen = 0;
1783:uIP/uip/uip.c **** 				DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1784:uIP/uip/uip.c **** 				UIP_APPCALL();
1785:uIP/uip/uip.c **** 
1786:uIP/uip/uip.c **** 	DEBUG_PRINTF("no ");
1787:uIP/uip/uip.c **** appsend:
1788:uIP/uip/uip.c **** 	DEBUG_PRINTF("appsend: flaw!!):\r\n");
1789:uIP/uip/uip.c **** 
1790:uIP/uip/uip.c **** 				if(uip_flags & UIP_ABORT)
1791:uIP/uip/uip.c **** 				{
1792:uIP/uip/uip.c **** 					uip_slen = 0;
1793:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_CLOSED;
1794:uIP/uip/uip.c **** 					BUF->flags = TCP_RST | TCP_ACK;
1795:uIP/uip/uip.c **** 					goto tcp_send_nodata;
1796:uIP/uip/uip.c **** 				}
1797:uIP/uip/uip.c **** 
1798:uIP/uip/uip.c **** 				if(uip_flags & UIP_CLOSE)
1799:uIP/uip/uip.c **** 				{
1800:uIP/uip/uip.c **** 					uip_slen = 0;
1801:uIP/uip/uip.c **** 					uip_connr->len = 1;
1802:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
1803:uIP/uip/uip.c **** 					uip_connr->nrtx = 0;
1804:uIP/uip/uip.c **** 					BUF->flags = TCP_FIN | TCP_ACK;
1805:uIP/uip/uip.c **** 					goto tcp_send_nodata;
1806:uIP/uip/uip.c **** 				}
1807:uIP/uip/uip.c **** 
1808:uIP/uip/uip.c **** 				/* If uip_slen > 0, the application has data to be sent. */
1809:uIP/uip/uip.c **** 				if(uip_slen > 0)
1810:uIP/uip/uip.c **** 				{
1811:uIP/uip/uip.c **** 
1812:uIP/uip/uip.c **** 					/* If the connection has acknowledged data, the contents of
1813:uIP/uip/uip.c **** 					the ->len variable should be discarded. */
1814:uIP/uip/uip.c **** 					if((uip_flags & UIP_ACKDATA) != 0)
1815:uIP/uip/uip.c **** 					{
1816:uIP/uip/uip.c **** 						uip_connr->len = 0;
1817:uIP/uip/uip.c **** 					}
1818:uIP/uip/uip.c **** 
1819:uIP/uip/uip.c **** 					/* If the ->len variable is non-zero the connection has
1820:uIP/uip/uip.c **** 					already data in transit and cannot send anymore right
1821:uIP/uip/uip.c **** 					now. */
1822:uIP/uip/uip.c **** 					if(uip_connr->len == 0)
1823:uIP/uip/uip.c **** 					{
1824:uIP/uip/uip.c **** 
1825:uIP/uip/uip.c **** 						/* The application cannot send more than what is allowed by
1826:uIP/uip/uip.c **** 							the mss (the minumum of the MSS and the available
1827:uIP/uip/uip.c **** 							window). */
1828:uIP/uip/uip.c **** 						if(uip_slen > uip_connr->mss)
1829:uIP/uip/uip.c **** 						{
1830:uIP/uip/uip.c **** 							uip_slen = uip_connr->mss;
1831:uIP/uip/uip.c **** 						}
1832:uIP/uip/uip.c **** 
1833:uIP/uip/uip.c **** 						/* Remember how much data we send out now so that we know
1834:uIP/uip/uip.c **** 							when everything has been acknowledged. */
1835:uIP/uip/uip.c **** 						uip_connr->len = uip_slen;
1836:uIP/uip/uip.c **** 					}
1837:uIP/uip/uip.c **** 					else
1838:uIP/uip/uip.c **** 					{
1839:uIP/uip/uip.c **** 
1840:uIP/uip/uip.c **** 						/* If the application already had unacknowledged data, we
1841:uIP/uip/uip.c **** 							make sure that the application does not send (i.e.,
1842:uIP/uip/uip.c **** 							retransmit) out more than it previously sent out. */
1843:uIP/uip/uip.c **** 						uip_slen = uip_connr->len;
1844:uIP/uip/uip.c **** 					}
1845:uIP/uip/uip.c **** 				}
1846:uIP/uip/uip.c **** 				uip_connr->nrtx = 0;
1847:uIP/uip/uip.c **** 
1848:uIP/uip/uip.c **** 	DEBUG_PRINTF("no ");
1849:uIP/uip/uip.c **** apprexmit:
1850:uIP/uip/uip.c **** 	DEBUG_PRINTF("apprexmit: flaw!!\r\n");
1851:uIP/uip/uip.c **** 				uip_appdata = uip_sappdata;
1852:uIP/uip/uip.c **** 
1853:uIP/uip/uip.c **** 				/* If the application has data to be sent, or if the incoming
1854:uIP/uip/uip.c **** 					packet had new data in it, we must send out a packet. */
1855:uIP/uip/uip.c **** 				if(uip_slen > 0 && uip_connr->len > 0)
1856:uIP/uip/uip.c **** 				{
1857:uIP/uip/uip.c **** 					/* Add the length of the IP and TCP headers. */
1858:uIP/uip/uip.c **** 					uip_len = uip_connr->len + UIP_TCPIP_HLEN;
1859:uIP/uip/uip.c **** 					/* We always set the ACK flag in response packets. */
1860:uIP/uip/uip.c **** 					BUF->flags = TCP_ACK | TCP_PSH;
1861:uIP/uip/uip.c **** 					/* Send the packet. */
1862:uIP/uip/uip.c **** 					goto tcp_send_noopts;
1863:uIP/uip/uip.c **** 				}
1864:uIP/uip/uip.c **** 				/* If there is no data to send, just send out a pure ACK if
1865:uIP/uip/uip.c **** 				there is newdata. */
1866:uIP/uip/uip.c **** 				if(uip_flags & UIP_NEWDATA)
1867:uIP/uip/uip.c **** 				{
1868:uIP/uip/uip.c **** 					uip_len = UIP_TCPIP_HLEN;
1869:uIP/uip/uip.c **** 					BUF->flags = TCP_ACK;
1870:uIP/uip/uip.c **** 					goto tcp_send_noopts;
1871:uIP/uip/uip.c **** 				}
1872:uIP/uip/uip.c **** 			}
1873:uIP/uip/uip.c **** 			goto drop;
1874:uIP/uip/uip.c **** 
1875:uIP/uip/uip.c **** 		case UIP_LAST_ACK:
1876:uIP/uip/uip.c **** 			/* We can close this connection if the peer has acknowledged our
1877:uIP/uip/uip.c **** 			FIN. This is indicated by the UIP_ACKDATA flag. */
1878:uIP/uip/uip.c **** 			if(uip_flags & UIP_ACKDATA)
1879:uIP/uip/uip.c **** 			{
1880:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_CLOSED;
1881:uIP/uip/uip.c **** 				uip_flags = UIP_CLOSE;
1882:uIP/uip/uip.c **** 				DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1883:uIP/uip/uip.c **** 				UIP_APPCALL();
1884:uIP/uip/uip.c **** 			}
1885:uIP/uip/uip.c **** 			break;
1886:uIP/uip/uip.c **** 
1887:uIP/uip/uip.c **** 		case UIP_FIN_WAIT_1:
1888:uIP/uip/uip.c **** 			/* The application has closed the connection, but the remote host
1889:uIP/uip/uip.c **** 			hasn't closed its end yet. Thus we do nothing but wait for a
1890:uIP/uip/uip.c **** 			FIN from the other side. */
1891:uIP/uip/uip.c **** 			if(uip_len > 0)
1892:uIP/uip/uip.c **** 			{
1893:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
1894:uIP/uip/uip.c **** 			}
1895:uIP/uip/uip.c **** 			if(BUF->flags & TCP_FIN)
1896:uIP/uip/uip.c **** 			{
1897:uIP/uip/uip.c **** 				if(uip_flags & UIP_ACKDATA)
1898:uIP/uip/uip.c **** 				{
1899:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_TIME_WAIT;
1900:uIP/uip/uip.c **** 					uip_connr->timer = 0;
1901:uIP/uip/uip.c **** 					uip_connr->len = 0;
1902:uIP/uip/uip.c **** 				}
1903:uIP/uip/uip.c **** 				else
1904:uIP/uip/uip.c **** 				{
1905:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_CLOSING;
1906:uIP/uip/uip.c **** 				}
1907:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1);
1908:uIP/uip/uip.c **** 				uip_flags = UIP_CLOSE;
1909:uIP/uip/uip.c **** 				DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1910:uIP/uip/uip.c **** 				UIP_APPCALL();
1911:uIP/uip/uip.c **** 				goto tcp_send_ack;
1912:uIP/uip/uip.c **** 			}
1913:uIP/uip/uip.c **** 			else if(uip_flags & UIP_ACKDATA)
1914:uIP/uip/uip.c **** 			{
1915:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
1916:uIP/uip/uip.c **** 				uip_connr->len = 0;
1917:uIP/uip/uip.c **** 				goto drop;
1918:uIP/uip/uip.c **** 			}
1919:uIP/uip/uip.c **** 			if(uip_len > 0)
1920:uIP/uip/uip.c **** 			{
1921:uIP/uip/uip.c **** 				goto tcp_send_ack;
1922:uIP/uip/uip.c **** 			}
1923:uIP/uip/uip.c **** 			goto drop;
1924:uIP/uip/uip.c **** 
1925:uIP/uip/uip.c **** 		case UIP_FIN_WAIT_2:
1926:uIP/uip/uip.c **** 			if(uip_len > 0)
1927:uIP/uip/uip.c **** 			{
1928:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
1929:uIP/uip/uip.c **** 			}
1930:uIP/uip/uip.c **** 			if(BUF->flags & TCP_FIN)
1931:uIP/uip/uip.c **** 			{
1932:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_TIME_WAIT;
1933:uIP/uip/uip.c **** 				uip_connr->timer = 0;
1934:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1);
1935:uIP/uip/uip.c **** 				uip_flags = UIP_CLOSE;
1936:uIP/uip/uip.c **** 				DEBUG_PRINTF("About to call UIP_APPCALL()\r\n");
1937:uIP/uip/uip.c **** 				UIP_APPCALL();
1938:uIP/uip/uip.c **** 				goto tcp_send_ack;
1939:uIP/uip/uip.c **** 			}
1940:uIP/uip/uip.c **** 			if(uip_len > 0)
1941:uIP/uip/uip.c **** 			{
1942:uIP/uip/uip.c **** 				goto tcp_send_ack;
1943:uIP/uip/uip.c **** 			}
1944:uIP/uip/uip.c **** 			goto drop;
1945:uIP/uip/uip.c **** 
1946:uIP/uip/uip.c **** 		case UIP_TIME_WAIT:
1947:uIP/uip/uip.c **** 			goto tcp_send_ack;
1948:uIP/uip/uip.c **** 
1949:uIP/uip/uip.c **** 		case UIP_CLOSING:
1950:uIP/uip/uip.c **** 			if(uip_flags & UIP_ACKDATA)
1951:uIP/uip/uip.c **** 			{
1952:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_TIME_WAIT;
1953:uIP/uip/uip.c **** 				uip_connr->timer = 0;
1954:uIP/uip/uip.c **** 			}
1955:uIP/uip/uip.c **** 		}
1956:uIP/uip/uip.c **** 
1957:uIP/uip/uip.c **** 		goto drop;
1958:uIP/uip/uip.c **** 
1959:uIP/uip/uip.c **** 
1960:uIP/uip/uip.c **** 	/* We jump here when we are ready to send the packet, and just want
1961:uIP/uip/uip.c **** 	to set the appropriate TCP sequence numbers in the TCP header. */
1962:uIP/uip/uip.c **** tcp_send_ack:
1963:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_ack:\r\n");
1964:uIP/uip/uip.c **** 	BUF->flags = TCP_ACK;
1965:uIP/uip/uip.c **** 
1966:uIP/uip/uip.c **** tcp_send_nodata:
1967:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_nodata:\r\n");
1968:uIP/uip/uip.c **** 	uip_len = UIP_IPTCPH_LEN;
1969:uIP/uip/uip.c **** 
1970:uIP/uip/uip.c **** tcp_send_noopts:
1971:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_noopts:\r\n");
1972:uIP/uip/uip.c **** 	BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
1973:uIP/uip/uip.c **** 
1974:uIP/uip/uip.c **** tcp_send:
1975:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send:\r\n");
1976:uIP/uip/uip.c **** 	/* We're done with the input processing. We are now ready to send a
1977:uIP/uip/uip.c **** 	reply. Our job is to fill in all the fields of the TCP and IP
1978:uIP/uip/uip.c **** 	headers before calculating the checksum and finally send the
1979:uIP/uip/uip.c **** 	packet. */
1980:uIP/uip/uip.c **** 	BUF->ackno[0] = uip_connr->rcv_nxt[0];
1981:uIP/uip/uip.c **** 	BUF->ackno[1] = uip_connr->rcv_nxt[1];
1982:uIP/uip/uip.c **** 	BUF->ackno[2] = uip_connr->rcv_nxt[2];
1983:uIP/uip/uip.c **** 	BUF->ackno[3] = uip_connr->rcv_nxt[3];
1984:uIP/uip/uip.c **** 
1985:uIP/uip/uip.c **** 	BUF->seqno[0] = uip_connr->snd_nxt[0];
1986:uIP/uip/uip.c **** 	BUF->seqno[1] = uip_connr->snd_nxt[1];
1987:uIP/uip/uip.c **** 	BUF->seqno[2] = uip_connr->snd_nxt[2];
1988:uIP/uip/uip.c **** 	BUF->seqno[3] = uip_connr->snd_nxt[3];
1989:uIP/uip/uip.c **** 
1990:uIP/uip/uip.c **** 	BUF->proto = UIP_PROTO_TCP;
1991:uIP/uip/uip.c **** 
1992:uIP/uip/uip.c **** 	BUF->srcport  = uip_connr->lport;
1993:uIP/uip/uip.c **** 	BUF->destport = uip_connr->rport;
1994:uIP/uip/uip.c **** 
1995:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1996:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
1997:uIP/uip/uip.c **** 
1998:uIP/uip/uip.c **** 	if(uip_connr->tcpstateflags & UIP_STOPPED)
1999:uIP/uip/uip.c **** 	{
2000:uIP/uip/uip.c **** 		/* If the connection has issued uip_stop(), we advertise a zero
2001:uIP/uip/uip.c **** 		window so that the remote host will stop sending data. */
2002:uIP/uip/uip.c **** 		BUF->wnd[0] = BUF->wnd[1] = 0;
2003:uIP/uip/uip.c **** 	}
2004:uIP/uip/uip.c **** 	else
2005:uIP/uip/uip.c **** 	{
2006:uIP/uip/uip.c **** 		BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
2007:uIP/uip/uip.c **** 		BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
2008:uIP/uip/uip.c **** 	}
2009:uIP/uip/uip.c **** 
2010:uIP/uip/uip.c **** tcp_send_noconn:
2011:uIP/uip/uip.c **** 	DEBUG_PRINTF("tcp_send_noconn:\r\n");
2012:uIP/uip/uip.c **** 	BUF->ttl = UIP_TTL;
2013:uIP/uip/uip.c **** #if UIP_CONF_IPV6
2014:uIP/uip/uip.c **** 	/* For IPv6, the IP length field does not include the IPv6 IP header
2015:uIP/uip/uip.c **** 	length. */
2016:uIP/uip/uip.c **** 	BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
2017:uIP/uip/uip.c **** 	BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
2018:uIP/uip/uip.c **** #else /* UIP_CONF_IPV6 */
2019:uIP/uip/uip.c **** 	BUF->len[0] = (uip_len >> 8);
2020:uIP/uip/uip.c **** 	BUF->len[1] = (uip_len & 0xff);
2021:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
2022:uIP/uip/uip.c **** 
2023:uIP/uip/uip.c **** 	BUF->urgp[0] = BUF->urgp[1] = 0;
2024:uIP/uip/uip.c **** 
2025:uIP/uip/uip.c **** 	/* Calculate TCP checksum. */
2026:uIP/uip/uip.c **** 	BUF->tcpchksum = 0;
2027:uIP/uip/uip.c **** 	BUF->tcpchksum = ~(uip_tcpchksum());
2028:uIP/uip/uip.c **** 
2029:uIP/uip/uip.c **** ip_send_nolen:
2030:uIP/uip/uip.c **** 	DEBUG_PRINTF("ip_send_nolen:\r\n");
2031:uIP/uip/uip.c **** 
2032:uIP/uip/uip.c **** #if UIP_CONF_IPV6
2033:uIP/uip/uip.c **** 	BUF->vtc = 0x60;
2034:uIP/uip/uip.c **** 	BUF->tcflow = 0x00;
2035:uIP/uip/uip.c **** 	BUF->flow = 0x00;
2036:uIP/uip/uip.c **** #else /* UIP_CONF_IPV6 */
2037:uIP/uip/uip.c **** 	BUF->vhl = 0x45;
2038:uIP/uip/uip.c **** 	BUF->tos = 0;
2039:uIP/uip/uip.c **** 	BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
2040:uIP/uip/uip.c **** 	++ipid;
2041:uIP/uip/uip.c **** 	BUF->ipid[0] = ipid >> 8;
2042:uIP/uip/uip.c **** 	BUF->ipid[1] = ipid & 0xff;
2043:uIP/uip/uip.c **** 	/* Calculate IP checksum. */
2044:uIP/uip/uip.c **** 	BUF->ipchksum = 0;
2045:uIP/uip/uip.c **** 	BUF->ipchksum = ~(uip_ipchksum());
2046:uIP/uip/uip.c **** 	DEBUG_PRINTF("uip ip_send_nolen: chkecksum 0x%04x\r\n", uip_ipchksum());
2047:uIP/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
2048:uIP/uip/uip.c **** 
2049:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.tcp.sent);
2050:uIP/uip/uip.c **** send:
2051:uIP/uip/uip.c **** 	DEBUG_PRINTF("send:\r\n");
2052:uIP/uip/uip.c **** 	DEBUG_PRINTF("Sending packet with length %d (%d)\r\n", uip_len, (BUF->len[0] << 8) | BUF->len[1]);
2053:uIP/uip/uip.c **** 
2054:uIP/uip/uip.c **** 	UIP_STAT(++uip_stat.ip.sent);
2055:uIP/uip/uip.c **** 	/* Return and let the caller do the actual transmission. */
2056:uIP/uip/uip.c **** 	uip_flags = 0;
2057:uIP/uip/uip.c **** 	return;
2058:uIP/uip/uip.c **** 
2059:uIP/uip/uip.c **** drop:
2060:uIP/uip/uip.c **** 	DEBUG_PRINTF("drop:\r\n");
2061:uIP/uip/uip.c **** 	uip_len = 0;
2062:uIP/uip/uip.c **** 	uip_flags = 0;
2063:uIP/uip/uip.c **** 
2064:uIP/uip/uip.c **** 	return;
2065:uIP/uip/uip.c **** }
2066:uIP/uip/uip.c **** 
2067:uIP/uip/uip.c **** 
2068:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
2069:uIP/uip/uip.c **** u16_t
2070:uIP/uip/uip.c **** htons(u16_t val)
2071:uIP/uip/uip.c **** {
 74404              		.loc 1 2071 0
 74405              		# args = 0, frame = 0, pretend = 0
 74406              		# frame_needed = 0, leaf_function = 1
 74407              		# uses_anonymous_args = 0
 74408              	.LVL28:
 74409              	.LVL29:
2072:uIP/uip/uip.c ****   return HTONS(val);
2073:uIP/uip/uip.c **** }
 74410              		.loc 1 2073 0
 74411 0000 5EFC     		retal	r12
 74412              	.LFE14:
 74414              		.section	.text.uip_connect,"ax",@progbits
 74415              		.align	1
 74416              		.global	uip_connect
 74418              	uip_connect:
 74419              	.LFB8:
 418:uIP/uip/uip.c **** {
 74420              		.loc 1 418 0
 74421              		# args = 0, frame = 4, pretend = 0
 74422              		# frame_needed = 0, leaf_function = 0
 74423              		# uses_anonymous_args = 0
 74424              	.LVL30:
 74425 0000 D431     		pushm	r0-r3, r4-r7, lr
 74426              	.LCFI3:
 74427 0002 201D     		sub     sp, 4
 74428              	.LCFI4:
 74429 0004 1890     		mov	r0, r12
 74430 0006 500B     		stdsp	sp[0], r11
 74431              	.L36:
 418:uIP/uip/uip.c **** {
 74432              		.loc 1 418 0
 74433 0008 4CB8     		lda.w	r8, .LANCHOR0
 74434 000a 9017     		ld.sh	r7, r8[2]
 426:uIP/uip/uip.c **** 	if(lastport >= 32000)
 74435              		.loc 1 426 0
 74436 000c E0657CFF 		mov	r5, 31999
 74437 0010 E0611000 		mov	r1, 4096
 436:uIP/uip/uip.c **** 		if(conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport))
 74438              		.loc 1 436 0
 74439 0014 4C96     		lda.w	r6, uip_conns
 74440              	.LVL31:
 74441              	.L51:
 424:uIP/uip/uip.c **** 	++lastport;
 74442              		.loc 1 424 0
 74443 0016 2FF7     		sub     r7, -1
 74444 0018 5C87     		casts.h	r7
 426:uIP/uip/uip.c **** 	if(lastport >= 32000)
 74445              		.loc 1 426 0
 74446 001a EE051900 		cp.h	r5, r7
 74447 001e E2071730 		movlo    r7, r1
 436:uIP/uip/uip.c **** 		if(conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport))
 74448              		.loc 1 436 0
 74449 0022 0E92     		mov	r2, r7
 74450 0024 5C72     		castu.h	r2
 74451 0026 ED340019 		ld.ub	r4, r6[25]
 74452 002a 5804     		cp.w	r4, 0
 74453 002c C7E0     		breq .L47
 74454 002e C758     		rjmp    .L53
 74455              	.L54:
 74456 0030 049C     		mov	r12, r2
 74457 0032 F01F0043 		call	htons
 74458              	.LVL32:
 74459 0036 ED0800D0 		ld.sh	r8, r6[208]
 74460 003a F8081900 		cp.h	r8, r12
 74461 003e CEC0     		breq .L51
 74462              	.LVL33:
 74463              	.L49:
 74464 0040 4BD8     		lda.w	r8, .LANCHOR0
 74465 0042 B017     		st.h	r8[2], r7
 443:uIP/uip/uip.c **** 	for(c = 0; c < UIP_CONNS; ++c)
 74466              		.loc 1 443 0
 74467 0044 3009     		mov	r9, 0
 74468 0046 B0C9     		st.b	r8[4], r9
 446:uIP/uip/uip.c **** 		if(cconn->tcpstateflags == UIP_CLOSED)
 74469              		.loc 1 446 0
 74470 0048 5804     		cp.w	r4, 0
 74471 004a C031     		brne .L39
 74472 004c 4BB4     		lda.w	r4, uip_conns
 74473              	.LVL34:
 74474 004e C2D8     		rjmp    .L40
 74475              	.LVL35:
 74476              	.L39:
 451:uIP/uip/uip.c **** 		if(cconn->tcpstateflags == UIP_TIME_WAIT)
 74477              		.loc 1 451 0
 74478 0050 3078     		mov	r8, 7
 74479 0052 4BA9     		lda.w	r9, uip_conns
 74480 0054 E8081800 		cp.b	r8, r4
 74481 0058 F2041700 		moveq    r4, r9
 74482 005c F9B40100 		movne    r4, 0
 74483              	.LVL36:
 446:uIP/uip/uip.c **** 		if(cconn->tcpstateflags == UIP_CLOSED)
 74484              		.loc 1 446 0
 74485 0060 5803     		cp.w	r3, 0
 74486 0062 C081     		brne .L43
 74487 0064 3019     		mov	r9, 1
 74488 0066 4B48     		lda.w	r8, .LANCHOR0
 74489 0068 B0C9     		st.b	r8[4], r9
 74490 006a 4B44     		lda.w	r4, uip_conns
 74491              	.LVL37:
 74492 006c E8C4FF34 		sub     r4, r4, -204
 74493              	.LVL38:
 74494 0070 C1C8     		rjmp    .L40
 74495              	.L43:
 451:uIP/uip/uip.c **** 		if(cconn->tcpstateflags == UIP_TIME_WAIT)
 74496              		.loc 1 451 0
 74497 0072 3078     		mov	r8, 7
 74498 0074 F0031800 		cp.b	r3, r8
 74499 0078 C131     		brne .L44
 453:uIP/uip/uip.c **** 			if(conn == 0 || cconn->timer > conn->timer)
 74500              		.loc 1 453 0
 74501 007a 5804     		cp.w	r4, 0
 74502 007c C051     		brne .L45
 74503 007e 4AF4     		lda.w	r4, uip_conns
 74504              	.LVL39:
 74505 0080 E8C4FF34 		sub     r4, r4, -204
 74506              	.LVL40:
 74507 0084 C0D8     		rjmp    .L44
 74508              	.L45:
 74509 0086 4AD8     		lda.w	r8, uip_conns
 74510 0088 F13900E6 		ld.ub	r9, r8[230]
 74511 008c E938001A 		ld.ub	r8, r4[26]
 74512 0090 F0091800 		cp.b	r9, r8
 74513 0094 E0880005 		brls .L44
 74514 0098 4A84     		lda.w	r4, uip_conns
 74515              	.LVL41:
 74516 009a E8C4FF34 		sub     r4, r4, -204
 74517              	.LVL42:
 74518              	.L44:
 74519 009e 3029     		mov	r9, 2
 74520 00a0 4A58     		lda.w	r8, .LANCHOR0
 74521 00a2 B0C9     		st.b	r8[4], r9
 460:uIP/uip/uip.c **** 	if(conn == 0)
 74522              		.loc 1 460 0
 74523 00a4 5804     		cp.w	r4, 0
 74524 00a6 C360     		breq .L46
 74525              	.L40:
 465:uIP/uip/uip.c **** 	conn->tcpstateflags = UIP_SYN_SENT;
 74526              		.loc 1 465 0
 74527 00a8 3028     		mov	r8, 2
 74528 00aa E9680019 		st.b	r4[25], r8
 467:uIP/uip/uip.c **** 	conn->snd_nxt[0] = iss[0];
 74529              		.loc 1 467 0
 74530 00ae 4A28     		lda.w	r8, .LANCHOR0
 74531 00b0 F1390008 		ld.ub	r9, r8[8]
 74532 00b4 E969000C 		st.b	r4[12], r9
 468:uIP/uip/uip.c **** 	conn->snd_nxt[1] = iss[1];
 74533              		.loc 1 468 0
 74534 00b8 F1390009 		ld.ub	r9, r8[9]
 74535 00bc E969000D 		st.b	r4[13], r9
 469:uIP/uip/uip.c **** 	conn->snd_nxt[2] = iss[2];
 74536              		.loc 1 469 0
 74537 00c0 F139000A 		ld.ub	r9, r8[10]
 74538 00c4 E969000E 		st.b	r4[14], r9
 470:uIP/uip/uip.c **** 	conn->snd_nxt[3] = iss[3];
 74539              		.loc 1 470 0
 74540 00c8 F138000B 		ld.ub	r8, r8[11]
 74541 00cc E968000F 		st.b	r4[15], r8
 472:uIP/uip/uip.c **** 	conn->initialmss = conn->mss = UIP_TCP_MSS;
 74542              		.loc 1 472 0
 74543 00d0 E068060A 		mov	r8, 1546
 74544 00d4 E9580012 		st.h	r4[18], r8
 74545 00d8 E9580014 		st.h	r4[20], r8
 474:uIP/uip/uip.c **** 	conn->len = 1;   /* TCP length of the SYN is one. */
 74546              		.loc 1 474 0
 74547 00dc 3019     		mov	r9, 1
 74548 00de E9590010 		st.h	r4[16], r9
 475:uIP/uip/uip.c **** 	conn->nrtx = 0;
 74549              		.loc 1 475 0
 74550 00e2 3008     		mov	r8, 0
 74551 00e4 E968001B 		st.b	r4[27], r8
 476:uIP/uip/uip.c **** 	conn->timer = 1; /* Send the SYN next time around. */
 74552              		.loc 1 476 0
 74553 00e8 E969001A 		st.b	r4[26], r9
 477:uIP/uip/uip.c **** 	conn->rto = UIP_RTO;
 74554              		.loc 1 477 0
 74555 00ec 3039     		mov	r9, 3
 74556 00ee E9690018 		st.b	r4[24], r9
 478:uIP/uip/uip.c **** 	conn->sa = 0;
 74557              		.loc 1 478 0
 74558 00f2 E9680016 		st.b	r4[22], r8
 479:uIP/uip/uip.c **** 	conn->sv = 16;   /* Initial value of the RTT variance. */
 74559              		.loc 1 479 0
 74560 00f6 3108     		mov	r8, 16
 74561 00f8 E9680017 		st.b	r4[23], r8
 480:uIP/uip/uip.c **** 	conn->lport = htons(lastport);
 74562              		.loc 1 480 0
 74563 00fc 0E9C     		mov	r12, r7
 74564 00fe 5C7C     		castu.h	r12
 74565 0100 F01F000F 		call	htons
 74566              	.LVL43:
 74567 0104 A82C     		st.h	r4[4], r12
 481:uIP/uip/uip.c **** 	conn->rport = rport;
 74568              		.loc 1 481 0
 74569 0106 4008     		lddsp	r8, sp[0]
 74570 0108 A838     		st.h	r4[6], r8
 482:uIP/uip/uip.c **** 	uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 74571              		.loc 1 482 0
 74572 010a 8008     		ld.sh	r8, r0[0]
 74573 010c A808     		st.h	r4[0], r8
 74574 010e 8018     		ld.sh	r8, r0[2]
 74575 0110 A818     		st.h	r4[2], r8
 74576              	.LVL44:
 74577              	.L46:
 485:uIP/uip/uip.c **** }
 74578              		.loc 1 485 0
 74579 0112 089C     		mov	r12, r4
 74580 0114 2FFD     		sub	sp, -4 # Reset Frame Pointer
 74581 0116 D832     		popm	r0-r3, r4-r7, pc
 74582              	.LVL45:
 74583              	.L53:
 436:uIP/uip/uip.c **** 		if(conn->tcpstateflags != UIP_CLOSED && conn->lport == htons(lastport))
 74584              		.loc 1 436 0
 74585 0118 049C     		mov	r12, r2
 74586 011a F01F0009 		call	htons
 74587              	.LVL46:
 74588 011e 8C28     		ld.sh	r8, r6[4]
 74589 0120 F8081900 		cp.h	r8, r12
 74590 0124 FE90FF79 		breq .L51
 74591              	.LVL47:
 74592              	.L47:
 74593 0128 ED3300E5 		ld.ub	r3, r6[229]
 74594 012c 5803     		cp.w	r3, 0
 74595 012e C890     		breq .L49
 74596 0130 C80B     		rjmp    .L54
 74597 0132 00000000 		.cpool
 74597      00000000 
 74597      00000000 
 74597      0000
 74598              		.align	2
 74599              	.L55:
 74600              	.LFE8:
 74602              		.section	.text.uip_tcpchksum,"ax",@progbits
 74603              		.align	1
 74604              		.global	uip_tcpchksum
 74606              	uip_tcpchksum:
 74607              	.LFB6:
 370:uIP/uip/uip.c **** {
 74608              		.loc 1 370 0
 74609              		# args = 0, frame = 0, pretend = 0
 74610              		# frame_needed = 0, leaf_function = 0
 74611              		# uses_anonymous_args = 0
 74612 0000 EBCD40C0 		stm	--sp, r6, r7, lr
 74613              	.LCFI5:
 74614              	.LBB4:
 74615              	.LBB5:
 342:uIP/uip/uip.c ****   upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
 74616              		.loc 1 342 0
 74617 0004 4916     		lda.w	r6, uip_buf
 74618 0006 6C0B     		ld.w	r11, r6[0]
 74619 0008 F6C8FFF2 		sub     r8, r11, -14
 74620 000c 11B7     		ld.ub	r7, r8[3]
 74621 000e 2147     		sub     r7, 20
 74622 0010 11A8     		ld.ub	r8, r8[2]
 74623 0012 A968     		lsl     r8, 8
 74624 0014 1007     		add     r7, r8
 74625 0016 5C87     		casts.h	r7
 74626              	.LVL48:
 350:uIP/uip/uip.c ****   sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
 74627              		.loc 1 350 0
 74628 0018 0E9C     		mov	r12, r7
 74629              	.LVL49:
 74630 001a 2FAC     		sub     r12, -6
 74631 001c 308A     		mov	r10, 8
 74632 001e 2E6B     		sub     r11, -26
 74633 0020 5C7C     		castu.h	r12
 74634 0022 F01F000B 		call	chksum
 353:uIP/uip/uip.c ****   sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
 74635              		.loc 1 353 0
 74636 0026 6C0B     		ld.w	r11, r6[0]
 74637 0028 0E9A     		mov	r10, r7
 74638 002a 5C7A     		castu.h	r10
 74639 002c 2DEB     		sub     r11, -34
 74640 002e 5C7C     		castu.h	r12
 74641 0030 F01F0007 		call	chksum
 74642 0034 5C8C     		casts.h	r12
 74643              	.LVL50:
 356:uIP/uip/uip.c ****   return (sum == 0) ? 0xffff : htons(sum);
 74644              		.loc 1 356 0
 74645 0036 C031     		brne .L57
 74646              	.LVL51:
 74647 0038 E3CFC0C0 		ldm	sp++, r6, r7, pc, r12=-1
 74648              	.LVL52:
 74649              	.L57:
 74650 003c 5C7C     		castu.h	r12
 74651              	.LVL53:
 74652 003e F01F0005 		call	htons
 74653 0042 5C8C     		casts.h	r12
 74654              	.LBE5:
 74655              	.LBE4:
 372:uIP/uip/uip.c **** }
 74656              		.loc 1 372 0
 74657 0044 E3CD80C0 		ldm	sp++, r6, r7, pc
 74658 0048 00000000 		.cpool
 74658      00000000 
 74658      00000000 
 74659              		.align	2
 74660              	.L60:
 74661              	.LFE6:
 74663              		.section	.text.uip_ipchksum,"ax",@progbits
 74664              		.align	1
 74665              		.global	uip_ipchksum
 74667              	uip_ipchksum:
 74668              	.LFB4:
 324:uIP/uip/uip.c **** {
 74669              		.loc 1 324 0
 74670              		# args = 0, frame = 0, pretend = 0
 74671              		# frame_needed = 0, leaf_function = 0
 74672              		# uses_anonymous_args = 0
 74673 0000 D401     		pushm	lr
 74674              	.LCFI6:
 327:uIP/uip/uip.c ****   sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
 74675              		.loc 1 327 0
 74676 0002 4888     		lda.w	r8, uip_buf
 74677 0004 700B     		ld.w	r11, r8[0]
 74678 0006 314A     		mov	r10, 20
 74679 0008 2F2B     		sub     r11, -14
 74680 000a 300C     		mov	r12, 0
 74681 000c F01F0006 		call	chksum
 74682 0010 5C8C     		casts.h	r12
 74683              	.LVL54:
 329:uIP/uip/uip.c ****   return (sum == 0) ? 0xffff : htons(sum);
 74684              		.loc 1 329 0
 74685 0012 C021     		brne .L62
 74686              	.LVL55:
 74687 0014 DC0A     		popm	pc, r12=-1
 74688              	.LVL56:
 74689              	.L62:
 74690 0016 5C7C     		castu.h	r12
 74691              	.LVL57:
 74692 0018 F01F0004 		call	htons
 74693 001c 5C8C     		casts.h	r12
 330:uIP/uip/uip.c **** }
 74694              		.loc 1 330 0
 74695 001e D802     		popm	pc
 74696 0020 00000000 		.cpool
 74696      00000000 
 74696      00000000 
 74697              		.align	2
 74698              	.L65:
 74699              	.LFE4:
 74701              		.section	.text.uip_chksum,"ax",@progbits
 74702              		.align	1
 74703              		.global	uip_chksum
 74705              	uip_chksum:
 74706              	.LFB3:
 317:uIP/uip/uip.c **** {
 74707              		.loc 1 317 0
 74708              		# args = 0, frame = 0, pretend = 0
 74709              		# frame_needed = 0, leaf_function = 0
 74710              		# uses_anonymous_args = 0
 74711              	.LVL58:
 74712 0000 D401     		pushm	lr
 74713              	.LCFI7:
 318:uIP/uip/uip.c ****   return htons(chksum(0, (u8_t *)data, len));
 74714              		.loc 1 318 0
 74715 0002 F5DBC010 		bfextu	r10, r11, 0, 16
 74716 0006 189B     		mov	r11, r12
 74717              	.LVL59:
 74718 0008 300C     		mov	r12, 0
 74719              	.LVL60:
 74720 000a F01F0004 		call	chksum
 74721 000e 5C7C     		castu.h	r12
 74722 0010 F01F0003 		call	htons
 319:uIP/uip/uip.c **** }
 74723              		.loc 1 319 0
 74724 0014 5C8C     		casts.h	r12
 74725 0016 D802     		popm	pc
 74726 0018 00000000 		.cpool
 74726      00000000 
 74727              		.align	2
 74728              	.L68:
 74729              	.LFE3:
 74731              		.section	.text.uip_send_P,"ax",@progbits
 74732              		.align	1
 74733              		.global	uip_send_P
 74735              	uip_send_P:
 74736              	.LFB16:
2074:uIP/uip/uip.c **** /*---------------------------------------------------------------------------*/
2075:uIP/uip/uip.c **** void
2076:uIP/uip/uip.c **** uip_send(const void *data, int len)
2077:uIP/uip/uip.c **** {
2078:uIP/uip/uip.c ****   uip_slen = len;
2079:uIP/uip/uip.c ****   if(len > 0) {
2080:uIP/uip/uip.c ****     if(data != uip_sappdata) {
2081:uIP/uip/uip.c ****       memcpy(uip_sappdata, (data), uip_slen);
2082:uIP/uip/uip.c ****     }
2083:uIP/uip/uip.c ****   }
2084:uIP/uip/uip.c **** }
2085:uIP/uip/uip.c **** 
2086:uIP/uip/uip.c **** // send data from the program memory
2087:uIP/uip/uip.c **** void uip_send_P( PGM_VOID_P data, int len)
2088:uIP/uip/uip.c **** {
 74737              		.loc 1 2088 0
 74738              		# args = 0, frame = 0, pretend = 0
 74739              		# frame_needed = 0, leaf_function = 0
 74740              		# uses_anonymous_args = 0
 74741              	.LVL61:
 74742 0000 D401     		pushm	lr
 74743              	.LCFI8:
2089:uIP/uip/uip.c ****   if(len > 0) {
 74744              		.loc 1 2089 0
 74745 0002 580B     		cp.w	r11, 0
 74746 0004 E08A000F 		brle .L71
2090:uIP/uip/uip.c ****     uip_slen = len;
 74747              		.loc 1 2090 0
 74748 0008 5C8B     		casts.h	r11
 74749              	.LVL62:
 74750 000a 4878     		lda.w	r8, uip_slen
 74751 000c B00B     		st.h	r8[0], r11
2091:uIP/uip/uip.c ****     if(data != uip_sappdata) {
 74752              		.loc 1 2091 0
 74753 000e 4878     		lda.w	r8, uip_sappdata
 74754 0010 7008     		ld.w	r8, r8[0]
 74755 0012 103C     		cp.w	r12, r8
 74756 0014 C070     		breq .L71
2092:uIP/uip/uip.c ****       memcpy_P(uip_sappdata, (data), uip_slen);
 74757              		.loc 1 2092 0
 74758 0016 F5DBC010 		bfextu	r10, r11, 0, 16
 74759 001a 189B     		mov	r11, r12
 74760 001c 109C     		mov	r12, r8
 74761              	.LVL63:
 74762 001e F01F0004 		call	memcpy
 74763              	.LVL64:
 74764              	.L71:
 74765 0022 D802     		popm	pc
 74766 0024 00000000 		.cpool
 74766      00000000 
 74766      00000000 
 74767              		.align	2
 74768              	.L72:
 74769              	.LFE16:
 74771              		.section	.text.uip_send,"ax",@progbits
 74772              		.align	1
 74773              		.global	uip_send
 74775              	uip_send:
 74776              	.LFB15:
2077:uIP/uip/uip.c **** {
 74777              		.loc 1 2077 0
 74778              		# args = 0, frame = 0, pretend = 0
 74779              		# frame_needed = 0, leaf_function = 0
 74780              		# uses_anonymous_args = 0
 74781              	.LVL65:
 74782 0000 D401     		pushm	lr
 74783              	.LCFI9:
2078:uIP/uip/uip.c ****   uip_slen = len;
 74784              		.loc 1 2078 0
 74785 0002 F5DBB010 		bfexts	r10, r11, 0, 16
 74786              	.LVL66:
 74787 0006 4888     		lda.w	r8, uip_slen
 74788 0008 B00A     		st.h	r8[0], r10
2079:uIP/uip/uip.c ****   if(len > 0) {
 74789              		.loc 1 2079 0
 74790 000a 580B     		cp.w	r11, 0
 74791 000c E08A000B 		brle .L75
2080:uIP/uip/uip.c ****     if(data != uip_sappdata) {
 74792              		.loc 1 2080 0
 74793 0010 4868     		lda.w	r8, uip_sappdata
 74794 0012 7008     		ld.w	r8, r8[0]
 74795 0014 103C     		cp.w	r12, r8
 74796 0016 C060     		breq .L75
2081:uIP/uip/uip.c ****       memcpy(uip_sappdata, (data), uip_slen);
 74797              		.loc 1 2081 0
 74798 0018 5C7A     		castu.h	r10
 74799 001a 189B     		mov	r11, r12
 74800              	.LVL67:
 74801 001c 109C     		mov	r12, r8
 74802              	.LVL68:
 74803 001e F01F0004 		call	memcpy
 74804              	.LVL69:
 74805              	.L75:
 74806 0022 D802     		popm	pc
 74807 0024 00000000 		.cpool
 74807      00000000 
 74807      00000000 
 74808              		.align	2
 74809              	.L76:
 74810              	.LFE15:
 74812              		.section	.text.uip_process,"ax",@progbits
 74813              		.align	1
 74814              		.global	uip_process
 74816              	uip_process:
 74817              	.LFB13:
 712:uIP/uip/uip.c **** {
 74818              		.loc 1 712 0
 74819              		# args = 0, frame = 0, pretend = 0
 74820              		# frame_needed = 0, leaf_function = 0
 74821              		# uses_anonymous_args = 0
 74822              	.LVL70:
 74823 0000 D421     		pushm	r4-r7, lr
 74824              	.LCFI10:
 718:uIP/uip/uip.c **** 	if(flag == UIP_UDP_SEND_CONN)
 74825              		.loc 1 718 0
 74826 0002 3048     		mov	r8, 4
 74827 0004 F00C1800 		cp.b	r12, r8
 74828 0008 E0800228 		breq .L78
 724:uIP/uip/uip.c **** 	uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
 74829              		.loc 1 724 0
 74830 000c FEF81208 		lda.w	r8, uip_buf
 74831 0010 7008     		ld.w	r8, r8[0]
 74832 0012 2CA8     		sub     r8, -54
 74833 0014 FEF91204 		lda.w	r9, uip_appdata
 74834 0018 9308     		st.w	r9[0], r8
 74835 001a FEF91202 		lda.w	r9, uip_sappdata
 74836 001e 9308     		st.w	r9[0], r8
 727:uIP/uip/uip.c **** 	if(flag == UIP_POLL_REQUEST)
 74837              		.loc 1 727 0
 74838 0020 3038     		mov	r8, 3
 74839 0022 F00C1800 		cp.b	r12, r8
 74840 0026 C1A1     		brne .L79
 729:uIP/uip/uip.c **** 		if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED && !uip_outstanding(uip_connr))
 74841              		.loc 1 729 0
 74842 0028 FEF811F8 		lda.w	r8, uip_connr
 74843 002c 7008     		ld.w	r8, r8[0]
 74844 002e F1390019 		ld.ub	r9, r8[25]
 74845 0032 F3D9C004 		bfextu	r9, r9, 0, 4
 74846 0036 5839     		cp.w	r9, 3
 74847 0038 E08108E7 		brne .L80
 74848 003c F1090010 		ld.sh	r9, r8[16]
 74849 0040 3008     		mov	r8, 0
 74850 0042 F0091900 		cp.h	r9, r8
 74851 0046 E08108E0 		brne .L80
 731:uIP/uip/uip.c **** 			uip_flags = UIP_POLL;
 74852              		.loc 1 731 0
 74853 004a 3089     		mov	r9, 8
 74854 004c FEF811D8 		lda.w	r8, uip_flags
 74855 0050 B089     		st.b	r8[0], r9
 733:uIP/uip/uip.c **** 			UIP_APPCALL();
 74856              		.loc 1 733 0
 74857 0052 F01F0476 		call	NetSDR_appcall
 74858              	.LVL71:
 734:uIP/uip/uip.c **** 			goto appsend;
 74859              		.loc 1 734 0
 74860 0056 E08F06E4 		bral    .L81
 74861              	.LVL72:
 74862              	.L79:
 740:uIP/uip/uip.c **** 	else if(flag == UIP_TIMER)
 74863              		.loc 1 740 0
 74864 005a 3028     		mov	r8, 2
 74865 005c F00C1800 		cp.b	r12, r8
 74866 0060 E08100D1 		brne .L82
 749:uIP/uip/uip.c **** 		if(++iss[3] == 0)
 74867              		.loc 1 749 0
 74868 0064 FEF911C8 		lda.w	r9, .LANCHOR0
 74869 0068 F338000B 		ld.ub	r8, r9[11]
 74870 006c 2FF8     		sub     r8, -1
 74871 006e 5C58     		castu.b	r8
 74872 0070 F368000B 		st.b	r9[11], r8
 74873 0074 C161     		brne .L83
 751:uIP/uip/uip.c **** 			if(++iss[2] == 0)
 74874              		.loc 1 751 0
 74875 0076 F338000A 		ld.ub	r8, r9[10]
 74876 007a 2FF8     		sub     r8, -1
 74877 007c 5C58     		castu.b	r8
 74878 007e F368000A 		st.b	r9[10], r8
 74879 0082 C0F1     		brne .L83
 753:uIP/uip/uip.c **** 				if(++iss[1] == 0)
 74880              		.loc 1 753 0
 74881 0084 F3380009 		ld.ub	r8, r9[9]
 74882 0088 2FF8     		sub     r8, -1
 74883 008a 5C58     		castu.b	r8
 74884 008c F3680009 		st.b	r9[9], r8
 755:uIP/uip/uip.c **** 					++iss[0];
 74885              		.loc 1 755 0
 74886 0090 F2081700 		 moveq	r8, r9
 74887 0094 F1F90808 		 ld.ubeq	r9, r8[8]
 74888 0098 F7B900FF 		 subeq	r9, -1
 74889 009c F1F90E08 		 st.beq	r8[8], r9
 74890              	.L83:
 761:uIP/uip/uip.c **** 		uip_len = 0;
 74891              		.loc 1 761 0
 74892 00a0 3008     		mov	r8, 0
 74893 00a2 FEF9118E 		lda.w	r9, uip_len
 74894 00a6 B208     		st.h	r9[0], r8
 762:uIP/uip/uip.c **** 		uip_slen = 0;
 74895              		.loc 1 762 0
 74896 00a8 FEF9118C 		lda.w	r9, uip_slen
 74897 00ac B208     		st.h	r9[0], r8
 768:uIP/uip/uip.c **** 		if(uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2)
 74898              		.loc 1 768 0
 74899 00ae FEF91172 		lda.w	r9, uip_connr
 74900 00b2 720A     		ld.w	r10, r9[0]
 74901 00b4 F5390019 		ld.ub	r9, r10[25]
 74902 00b8 307B     		mov	r11, 7
 74903 00ba F6091800 		cp.b	r9, r11
 74904 00be 5F0C     		sreq	r12
 74905              	.LVL73:
 74906 00c0 305B     		mov	r11, 5
 74907 00c2 F6091800 		cp.b	r9, r11
 74908 00c6 5F0B     		sreq	r11
 74909 00c8 F9EB100B 		or	r11, r12, r11
 74910 00cc F00B1800 		cp.b	r11, r8
 74911 00d0 C150     		breq .L84
 770:uIP/uip/uip.c **** 			++(uip_connr->timer);
 74912              		.loc 1 770 0
 74913 00d2 F538001A 		ld.ub	r8, r10[26]
 74914 00d6 2FF8     		sub     r8, -1
 74915 00d8 F568001A 		st.b	r10[26], r8
 771:uIP/uip/uip.c **** 			if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT)
 74916              		.loc 1 771 0
 74917 00dc FEF81144 		lda.w	r8, uip_connr
 74918 00e0 7008     		ld.w	r8, r8[0]
 74919 00e2 F13A001A 		ld.ub	r10, r8[26]
 74920 00e6 3789     		mov	r9, 120
 74921 00e8 F20A1800 		cp.b	r10, r9
 74922 00ec E081088D 		brne .L80
 773:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_CLOSED;
 74923              		.loc 1 773 0
 74924 00f0 3009     		mov	r9, 0
 74925 00f2 F1690019 		st.b	r8[25], r9
 74926 00f6 E08F0888 		bral    .L80
 74927              	.L84:
 776:uIP/uip/uip.c **** 		else if(uip_connr->tcpstateflags != UIP_CLOSED)
 74928              		.loc 1 776 0
 74929 00fa 5809     		cp.w	r9, 0
 74930 00fc E0800885 		breq .L80
 781:uIP/uip/uip.c **** 			if(uip_outstanding(uip_connr))
 74931              		.loc 1 781 0
 74932 0100 F50B0010 		ld.sh	r11, r10[16]
 74933 0104 3008     		mov	r8, 0
 74934 0106 F00B1900 		cp.h	r11, r8
 74935 010a C6F0     		breq .L85
 783:uIP/uip/uip.c **** 				if(uip_connr->timer-- == 0)
 74936              		.loc 1 783 0
 74937 010c F538001A 		ld.ub	r8, r10[26]
 74938 0110 F0C90001 		sub     r9, r8, 1
 74939 0114 F569001A 		st.b	r10[26], r9
 74940 0118 5808     		cp.w	r8, 0
 74941 011a E0810876 		brne .L80
 785:uIP/uip/uip.c **** 					if(uip_connr->nrtx == UIP_MAXRTX || ((uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->t
 74942              		.loc 1 785 0
 74943 011e FEF81102 		lda.w	r8, uip_connr
 74944 0122 7008     		ld.w	r8, r8[0]
 74945 0124 F139001B 		ld.ub	r9, r8[27]
 74946 0128 308A     		mov	r10, 8
 74947 012a F4091800 		cp.b	r9, r10
 74948 012e C0D0     		breq .L86
 74949 0130 F13B0019 		ld.ub	r11, r8[25]
 74950 0134 201B     		sub     r11, 1
 74951 0136 301A     		mov	r10, 1
 74952 0138 F40B1800 		cp.b	r11, r10
 74953 013c E08B0017 		brhi .L87
 74954 0140 305A     		mov	r10, 5
 74955 0142 F4091800 		cp.b	r9, r10
 74956 0146 C121     		brne .L87
 74957              	.L86:
 787:uIP/uip/uip.c **** 						uip_connr->tcpstateflags = UIP_CLOSED;
 74958              		.loc 1 787 0
 74959 0148 3009     		mov	r9, 0
 74960 014a F1690019 		st.b	r8[25], r9
 792:uIP/uip/uip.c **** 						uip_flags = UIP_TIMEDOUT;
 74961              		.loc 1 792 0
 74962 014e 3809     		mov	r9, -128
 74963 0150 FEF810D4 		lda.w	r8, uip_flags
 74964 0154 B089     		st.b	r8[0], r9
 794:uIP/uip/uip.c **** 						UIP_APPCALL();
 74965              		.loc 1 794 0
 74966 0156 F01F0435 		call	NetSDR_appcall
 797:uIP/uip/uip.c **** 						BUF->flags = TCP_RST | TCP_ACK;
 74967              		.loc 1 797 0
 74968 015a FEF810BA 		lda.w	r8, uip_buf
 74969 015e 7008     		ld.w	r8, r8[0]
 74970 0160 3149     		mov	r9, 20
 74971 0162 F169002F 		st.b	r8[47], r9
 798:uIP/uip/uip.c **** 						goto tcp_send_nodata;
 74972              		.loc 1 798 0
 74973 0166 E08F0794 		bral    .L88
 74974              	.L87:
 802:uIP/uip/uip.c **** 					uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4? 4:uip_connr->nrtx);
 74975              		.loc 1 802 0
 74976 016a 304A     		mov	r10, 4
 74977 016c F4091800 		cp.b	r9, r10
 74978 0170 E0880004 		brls .L89
 74979 0174 3309     		mov	r9, 48
 74980 0176 C048     		rjmp    .L90
 74981              	.L89:
 74982 0178 303A     		mov	r10, 3
 74983 017a F4090949 		lsl     r9, r10, r9
 74984              	.L90:
 74985 017e F169001A 		st.b	r8[26], r9
 803:uIP/uip/uip.c **** 					++(uip_connr->nrtx);
 74986              		.loc 1 803 0
 74987 0182 FEF8109E 		lda.w	r8, uip_connr
 74988 0186 7009     		ld.w	r9, r8[0]
 74989 0188 F33A001B 		ld.ub	r10, r9[27]
 74990 018c 2FFA     		sub     r10, -1
 74991 018e F36A001B 		st.b	r9[27], r10
 812:uIP/uip/uip.c **** 					switch(uip_connr->tcpstateflags & UIP_TS_MASK)
 74992              		.loc 1 812 0
 74993 0192 7008     		ld.w	r8, r8[0]
 74994 0194 F1380019 		ld.ub	r8, r8[25]
 74995 0198 F1D8C004 		bfextu	r8, r8, 0, 4
 74996 019c 5838     		cp.w	r8, 3
 74997 019e C1D0     		breq .L93
 74998 01a0 E0890009 		brgt .L95
 74999 01a4 5818     		cp.w	r8, 1
 75000 01a6 E08003A4 		breq .L91
 75001 01aa 5828     		cp.w	r8, 2
 75002 01ac E081082D 		brne .L80
 75003 01b0 C0C8     		rjmp    .L181
 75004              	.L95:
 75005 01b2 5868     		cp.w	r8, 6
 75006 01b4 E08005C5 		breq .L94
 75007 01b8 5888     		cp.w	r8, 8
 75008 01ba E08005C2 		breq .L94
 75009 01be 5848     		cp.w	r8, 4
 75010 01c0 E0810823 		brne .L80
 75011 01c4 E08F05BD 		bral    .L94
 75012              	.L181:
 821:uIP/uip/uip.c **** 						BUF->flags = 0;
 75013              		.loc 1 821 0
 75014 01c8 FEF8104C 		lda.w	r8, uip_buf
 75015 01cc 7008     		ld.w	r8, r8[0]
 75016 01ce 3009     		mov	r9, 0
 75017 01d0 F169002F 		st.b	r8[47], r9
 822:uIP/uip/uip.c **** 						goto tcp_send_syn;
 75018              		.loc 1 822 0
 75019 01d4 E08F0393 		bral    .L96
 75020              	.L93:
 830:uIP/uip/uip.c **** 						uip_flags = UIP_REXMIT;
 75021              		.loc 1 830 0
 75022 01d8 3049     		mov	r9, 4
 75023 01da FEF8104A 		lda.w	r8, uip_flags
 75024 01de B089     		st.b	r8[0], r9
 832:uIP/uip/uip.c **** 						UIP_APPCALL();
 75025              		.loc 1 832 0
 75026 01e0 F01F0412 		call	NetSDR_appcall
 833:uIP/uip/uip.c **** 						goto apprexmit;
 75027              		.loc 1 833 0
 75028 01e4 E08F0689 		bral    .L97
 75029              	.L85:
 844:uIP/uip/uip.c **** 			else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED)
 75030              		.loc 1 844 0
 75031 01e8 F3D9C004 		bfextu	r9, r9, 0, 4
 75032 01ec 5839     		cp.w	r9, 3
 75033 01ee E081080C 		brne .L80
 847:uIP/uip/uip.c **** 				uip_flags = UIP_POLL;
 75034              		.loc 1 847 0
 75035 01f2 3089     		mov	r9, 8
 75036 01f4 FEF81030 		lda.w	r8, uip_flags
 75037 01f8 B089     		st.b	r8[0], r9
 849:uIP/uip/uip.c **** 				UIP_APPCALL();
 75038              		.loc 1 849 0
 75039 01fa F01F040C 		call	NetSDR_appcall
 850:uIP/uip/uip.c **** 				goto appsend;
 75040              		.loc 1 850 0
 75041 01fe E08F0610 		bral    .L81
 75042              	.LVL74:
 75043              	.L82:
 856:uIP/uip/uip.c **** 	if(flag == UIP_UDP_TIMER)
 75044              		.loc 1 856 0
 75045 0202 3058     		mov	r8, 5
 75046 0204 F00C1800 		cp.b	r12, r8
 75047 0208 C251     		brne .L98
 858:uIP/uip/uip.c **** 		if(uip_udp_conn->lport != 0)
 75048              		.loc 1 858 0
 75049 020a FEF8102E 		lda.w	r8, uip_udp_conn
 75050 020e 7008     		ld.w	r8, r8[0]
 75051 0210 9029     		ld.sh	r9, r8[4]
 75052 0212 3008     		mov	r8, 0
 75053 0214 F0091900 		cp.h	r9, r8
 75054 0218 E08007F7 		breq .L80
 860:uIP/uip/uip.c **** 			uip_conn = NULL;
 75055              		.loc 1 860 0
 75056 021c 3008     		mov	r8, 0
 75057 021e FEF9101E 		lda.w	r9, uip_conn
 75058 0222 9308     		st.w	r9[0], r8
 861:uIP/uip/uip.c **** 			uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 75059              		.loc 1 861 0
 75060 0224 FEF90FF0 		lda.w	r9, uip_buf
 75061 0228 7209     		ld.w	r9, r9[0]
 75062 022a 2D69     		sub     r9, -42
 75063 022c FEFA0FEC 		lda.w	r10, uip_appdata
 75064 0230 9509     		st.w	r10[0], r9
 75065 0232 FEFA0FEA 		lda.w	r10, uip_sappdata
 75066 0236 9509     		st.w	r10[0], r9
 862:uIP/uip/uip.c **** 			uip_len = uip_slen = 0;
 75067              		.loc 1 862 0
 75068 0238 FEF90FFC 		lda.w	r9, uip_slen
 75069 023c B208     		st.h	r9[0], r8
 75070 023e FEF90FF2 		lda.w	r9, uip_len
 75071 0242 B208     		st.h	r9[0], r8
 863:uIP/uip/uip.c **** 			uip_flags = UIP_POLL;
 75072              		.loc 1 863 0
 75073 0244 3089     		mov	r9, 8
 75074 0246 FEF80FDE 		lda.w	r8, uip_flags
 75075 024a B089     		st.b	r8[0], r9
 865:uIP/uip/uip.c **** 			UIP_UDP_APPCALL();
 75076              		.loc 1 865 0
 75077 024c F01F03FD 		call	NetSDR_UDP_appcall
 75078              	.LVL75:
 866:uIP/uip/uip.c **** 			goto udp_send;
 75079              		.loc 1 866 0
 75080 0250 C049     		rjmp    .L78
 75081              	.LVL76:
 75082              	.L98:
 891:uIP/uip/uip.c **** 	if(BUF->vhl != 0x45)
 75083              		.loc 1 891 0
 75084 0252 FEF80FC2 		lda.w	r8, uip_buf
 75085 0256 7008     		ld.w	r8, r8[0]
 75086 0258 2F28     		sub     r8, -14
 75087 025a 118A     		ld.ub	r10, r8[0]
 75088 025c 3459     		mov	r9, 69
 75089 025e F20A1800 		cp.b	r10, r9
 75090 0262 E08107D2 		brne .L80
 907:uIP/uip/uip.c **** 	if((BUF->len[0] << 8) + BUF->len[1] <= uip_len)
 75091              		.loc 1 907 0
 75092 0266 11A9     		ld.ub	r9, r8[2]
 75093 0268 11B8     		ld.ub	r8, r8[3]
 75094 026a F20B1508 		lsl     r11, r9, 8
 75095 026e 100B     		add     r11, r8
 75096 0270 FEFA0FC0 		lda.w	r10, uip_len
 75097 0274 948A     		ld.uh	r10, r10[0]
 75098 0276 143B     		cp.w	r11, r10
 75099 0278 E08907C7 		brgt .L80
 909:uIP/uip/uip.c **** 		uip_len = (BUF->len[0] << 8) + BUF->len[1];
 75100              		.loc 1 909 0
 75101 027c A969     		lsl     r9, 8
 75102 027e F2080008 		add     r8, r9, r8
 75103 0282 FEFA0FAE 		lda.w	r10, uip_len
 75104 0286 B408     		st.h	r10[0], r8
 930:uIP/uip/uip.c **** 	if((BUF->ipoffset[0] & 0x3f) != 0 || BUF->ipoffset[1] != 0)
 75105              		.loc 1 930 0
 75106 0288 FEF80F8C 		lda.w	r8, uip_buf
 75107 028c 7008     		ld.w	r8, r8[0]
 75108 028e 2F28     		sub     r8, -14
 75109 0290 11E9     		ld.ub	r9, r8[6]
 75110 0292 F3D9C006 		bfextu	r9, r9, 0, 6
 75111 0296 E08107B8 		brne .L80
 75112 029a 11FA     		ld.ub	r10, r8[7]
 75113 029c F20A1800 		cp.b	r10, r9
 75114 02a0 E08107B3 		brne .L80
 947:uIP/uip/uip.c **** 	if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr))
 75115              		.loc 1 947 0
 75116 02a4 FEF90FA0 		lda.w	r9, uip_hostaddr
 75117 02a8 9209     		ld.sh	r9, r9[0]
 75118 02aa 5809     		cp.w	r9, 0
 75119 02ac C081     		brne .L99
 75120 02ae FEFA0F96 		lda.w	r10, uip_hostaddr
 75121 02b2 941B     		ld.sh	r11, r10[2]
 75122 02b4 300A     		mov	r10, 0
 75123 02b6 F40B1900 		cp.h	r11, r10
 75124 02ba C210     		breq .L100
 75125              	.L99:
 972:uIP/uip/uip.c **** 		if(BUF->proto == UIP_PROTO_UDP && uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr) /*&& uip_ipchksu
 75126              		.loc 1 972 0
 75127 02bc F13B0009 		ld.ub	r11, r8[9]
 75128 02c0 311A     		mov	r10, 17
 75129 02c2 F40B1800 		cp.b	r11, r10
 75130 02c6 C0C1     		brne .L101
 75131 02c8 F10B0010 		ld.sh	r11, r8[16]
 75132 02cc 3FFA     		mov	r10, -1
 75133 02ce F40B1900 		cp.h	r11, r10
 75134 02d2 C061     		brne .L101
 75135 02d4 F10B0012 		ld.sh	r11, r8[18]
 75136 02d8 F40B1900 		cp.h	r11, r10
 75137 02dc C620     		breq .L102
 75138              	.L101:
 980:uIP/uip/uip.c **** 		if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr))
 75139              		.loc 1 980 0
 75140 02de F10A0010 		ld.sh	r10, r8[16]
 75141 02e2 F20A1900 		cp.h	r10, r9
 75142 02e6 E0810790 		brne .L80
 75143 02ea F1090012 		ld.sh	r9, r8[18]
 75144 02ee FEF80F56 		lda.w	r8, uip_hostaddr
 75145 02f2 9018     		ld.sh	r8, r8[2]
 75146 02f4 F0091900 		cp.h	r9, r8
 75147 02f8 E0810787 		brne .L80
 75148              	.L100:
1000:uIP/uip/uip.c **** 	if(uip_ipchksum() != 0xffff)
 75149              		.loc 1 1000 0
 75150 02fc F01F03D3 		call	uip_ipchksum
 75151              	.LVL77:
 75152 0300 3FF8     		mov	r8, -1
 75153 0302 F00C1900 		cp.h	r12, r8
 75154 0306 E0810780 		brne .L80
1009:uIP/uip/uip.c **** 	if(BUF->proto == UIP_PROTO_TCP)
 75155              		.loc 1 1009 0
 75156 030a FEF80F0A 		lda.w	r8, uip_buf
 75157 030e 7009     		ld.w	r9, r8[0]
 75158 0310 F3380017 		ld.ub	r8, r9[23]
 75159 0314 306A     		mov	r10, 6
 75160 0316 F4081800 		cp.b	r8, r10
 75161 031a E08000F2 		breq .L103
1015:uIP/uip/uip.c **** 	if(BUF->proto == UIP_PROTO_UDP)
 75162              		.loc 1 1015 0
 75163 031e 311A     		mov	r10, 17
 75164 0320 F4081800 		cp.b	r8, r10
 75165 0324 C3E0     		breq .L102
1023:uIP/uip/uip.c **** 	if(BUF->proto != UIP_PROTO_ICMP)
 75166              		.loc 1 1023 0
 75167 0326 301A     		mov	r10, 1
 75168 0328 F4081800 		cp.b	r8, r10
 75169 032c E081076D 		brne .L80
1040:uIP/uip/uip.c **** 	if(ICMPBUF->type != ICMP_ECHO)
 75170              		.loc 1 1040 0
 75171 0330 F2C8FFF2 		sub     r8, r9, -14
 75172 0334 F13A0014 		ld.ub	r10, r8[20]
 75173 0338 3089     		mov	r9, 8
 75174 033a F20A1800 		cp.b	r10, r9
 75175 033e E0810764 		brne .L80
1059:uIP/uip/uip.c **** 	ICMPBUF->type = ICMP_ECHO_REPLY;
 75176              		.loc 1 1059 0
 75177 0342 3009     		mov	r9, 0
 75178 0344 F1690014 		st.b	r8[20], r9
1061:uIP/uip/uip.c **** 	if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8)))
 75179              		.loc 1 1061 0
 75180 0348 FEF80ECC 		lda.w	r8, uip_buf
 75181 034c 7008     		ld.w	r8, r8[0]
 75182 034e 2F28     		sub     r8, -14
 75183 0350 F1090016 		ld.sh	r9, r8[22]
1063:uIP/uip/uip.c **** 		ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
 75184              		.loc 1 1063 0
 75185 0354 F2CAF7FF 		sub     r10, r9, -2049
1061:uIP/uip/uip.c **** 	if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8)))
 75186              		.loc 1 1061 0
 75187 0358 FE7BF7FE 		mov	r11, -2050
1063:uIP/uip/uip.c **** 		ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
 75188              		.loc 1 1063 0
 75189 035c F6091900 			cp.h	r9, r11
 75190 0360 F1FABC0B 	 st.hhi	r8[22], r10
1067:uIP/uip/uip.c **** 		ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
 75191              		.loc 1 1067 0
 75192 0364 E06A0800 		 mov	r10, 2048
 75193 0368 F3DAE809 		addls	r9, r9, r10
 75194 036c F1F98C0B 		 st.hls	r8[22], r9
1071:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
 75195              		.loc 1 1071 0
 75196 0370 FEF80EA4 		lda.w	r8, uip_buf
 75197 0374 7009     		ld.w	r9, r8[0]
 75198 0376 2F29     		sub     r9, -14
 75199 0378 926A     		ld.sh	r10, r9[12]
 75200 037a F35A0010 		st.h	r9[16], r10
 75201 037e 7009     		ld.w	r9, r8[0]
 75202 0380 2F29     		sub     r9, -14
 75203 0382 927A     		ld.sh	r10, r9[14]
 75204 0384 F35A0012 		st.h	r9[18], r10
1072:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 75205              		.loc 1 1072 0
 75206 0388 700A     		ld.w	r10, r8[0]
 75207 038a FEF90EBA 		lda.w	r9, uip_hostaddr
 75208 038e 920B     		ld.sh	r11, r9[0]
 75209 0390 F55B001A 		st.h	r10[26], r11
 75210 0394 7008     		ld.w	r8, r8[0]
 75211 0396 9219     		ld.sh	r9, r9[2]
 75212 0398 F159001C 		st.h	r8[28], r9
1075:uIP/uip/uip.c **** 	goto send;
 75213              		.loc 1 1075 0
 75214 039c E08F0731 		bral    .L106
 75215              	.LVL78:
 75216              	.L102:
1173:uIP/uip/uip.c **** 	uip_len = uip_len - UIP_IPUDPH_LEN;
 75217              		.loc 1 1173 0
 75218 03a0 FEF80E90 		lda.w	r8, uip_len
 75219 03a4 9009     		ld.sh	r9, r8[0]
 75220 03a6 21C9     		sub     r9, 28
 75221 03a8 B009     		st.h	r8[0], r9
1176:uIP/uip/uip.c **** 	for(uip_udp_conn = &uip_udp_conns[0]; uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];	++uip_udp_conn
 75222              		.loc 1 1176 0
 75223 03aa FEF80EA2 		lda.w	r8, uip_udp_conns
 75224 03ae FEF90E8A 		lda.w	r9, uip_udp_conn
 75225 03b2 9308     		st.w	r9[0], r8
 75226 03b4 F0C9FFD0 		sub     r9, r8, -48
 75227 03b8 1039     		cp.w	r9, r8
 75228 03ba E0880726 		brls .L80
1186:uIP/uip/uip.c **** 			(UDPBUF->destport == uip_udp_conn->lport) && 
 75229              		.loc 1 1186 0
 75230 03be FEF80E56 		lda.w	r8, uip_buf
 75231 03c2 700E     		ld.w	lr, r8[0]
 75232 03c4 2F2E     		sub     lr, -14
1188:uIP/uip/uip.c **** 			(uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) || uip_ipaddr_cmp(uip_udp_conn->ripaddr,
 75233              		.loc 1 1188 0
 75234 03c6 1C95     		mov	r5, lr
 75235 03c8 FEF90E84 		lda.w	r9, uip_udp_conns
 75236 03cc F2C8FFFE 		sub     r8, r9, -2
 711:uIP/uip/uip.c **** void uip_process(u8_t flag)
 75237              		.loc 1 711 0
 75238 03d0 F2CCFFCE 		sub     r12, r9, -50
 75239              	.LVL79:
1185:uIP/uip/uip.c **** 		if(	(uip_udp_conn->lport != 0) && 
 75240              		.loc 1 1185 0
 75241 03d4 3FF6     		mov	r6, -1
 75242 03d6 3004     		mov	r4, 0
1176:uIP/uip/uip.c **** 	for(uip_udp_conn = &uip_udp_conns[0]; uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];	++uip_udp_conn
 75243              		.loc 1 1176 0
 75244 03d8 FEFB0E60 		lda.w	r11, uip_udp_conn
 75245              	.L111:
1185:uIP/uip/uip.c **** 		if(	(uip_udp_conn->lport != 0) && 
 75246              		.loc 1 1185 0
 75247 03dc 901A     		ld.sh	r10, r8[2]
 75248 03de 580A     		cp.w	r10, 0
 75249 03e0 C1E0     		breq .L107
1186:uIP/uip/uip.c **** 			(UDPBUF->destport == uip_udp_conn->lport) && 
 75250              		.loc 1 1186 0
 75251 03e2 FD070016 		ld.sh	r7, lr[22]
 75252 03e6 F4071900 		cp.h	r7, r10
 75253 03ea C191     		brne .L107
1188:uIP/uip/uip.c **** 			(uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) || uip_ipaddr_cmp(uip_udp_conn->ripaddr,
 75254              		.loc 1 1188 0
 75255 03ec 920A     		ld.sh	r10, r9[0]
1185:uIP/uip/uip.c **** 		if(	(uip_udp_conn->lport != 0) && 
 75256              		.loc 1 1185 0
 75257 03ee 580A     		cp.w	r10, 0
 75258 03f0 C061     		brne .L108
 75259 03f2 9007     		ld.sh	r7, r8[0]
 75260 03f4 E8071900 		cp.h	r7, r4
 75261 03f8 C091     		brne .L110
 75262 03fa C188     		rjmp    .L109
 75263              	.L108:
 75264 03fc EC0A1900 		cp.h	r10, r6
 75265 0400 C051     		brne .L110
 75266 0402 9007     		ld.sh	r7, r8[0]
 75267 0404 EC071900 		cp.h	r7, r6
 75268 0408 C110     		breq .L109
 75269              	.L110:
1188:uIP/uip/uip.c **** 			(uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) || uip_ipaddr_cmp(uip_udp_conn->ripaddr,
 75270              		.loc 1 1188 0
 75271 040a 8A67     		ld.sh	r7, r5[12]
 75272 040c F4071900 		cp.h	r7, r10
 75273 0410 C061     		brne .L107
1185:uIP/uip/uip.c **** 		if(	(uip_udp_conn->lport != 0) && 
 75274              		.loc 1 1185 0
 75275 0412 8A77     		ld.sh	r7, r5[14]
 75276 0414 900A     		ld.sh	r10, r8[0]
 75277 0416 F4071900 		cp.h	r7, r10
 75278 041a C080     		breq .L109
 75279              	.L107:
1176:uIP/uip/uip.c **** 	for(uip_udp_conn = &uip_udp_conns[0]; uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];	++uip_udp_conn
 75280              		.loc 1 1176 0
 75281 041c 2F09     		sub     r9, -16
 75282 041e 9709     		st.w	r11[0], r9
 75283 0420 2F08     		sub     r8, -16
 75284 0422 1838     		cp.w	r8, r12
 75285 0424 CDC1     		brne .L111
 75286 0426 E08F06F0 		bral    .L80
 75287              	.L109:
1201:uIP/uip/uip.c **** 	uip_conn = NULL;
 75288              		.loc 1 1201 0
 75289 042a 3008     		mov	r8, 0
 75290 042c FEF90E10 		lda.w	r9, uip_conn
 75291 0430 9308     		st.w	r9[0], r8
1202:uIP/uip/uip.c **** 	uip_flags = UIP_NEWDATA;
 75292              		.loc 1 1202 0
 75293 0432 302A     		mov	r10, 2
 75294 0434 FEF90DF0 		lda.w	r9, uip_flags
 75295 0438 B28A     		st.b	r9[0], r10
1203:uIP/uip/uip.c **** 	uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 75296              		.loc 1 1203 0
 75297 043a FEF90DDA 		lda.w	r9, uip_buf
 75298 043e 7209     		ld.w	r9, r9[0]
 75299 0440 2D69     		sub     r9, -42
 75300 0442 FEFA0DD6 		lda.w	r10, uip_appdata
 75301 0446 9509     		st.w	r10[0], r9
 75302 0448 FEFA0DD4 		lda.w	r10, uip_sappdata
 75303 044c 9509     		st.w	r10[0], r9
1204:uIP/uip/uip.c **** 	uip_slen = 0;
 75304              		.loc 1 1204 0
 75305 044e FEF90DE6 		lda.w	r9, uip_slen
 75306 0452 B208     		st.h	r9[0], r8
1206:uIP/uip/uip.c **** 	UIP_UDP_APPCALL();
 75307              		.loc 1 1206 0
 75308 0454 F01F037B 		call	NetSDR_UDP_appcall
 75309              	.LVL80:
 75310              	.L78:
1210:uIP/uip/uip.c **** 	if(uip_slen == 0)
 75311              		.loc 1 1210 0
 75312 0458 FEF80DDC 		lda.w	r8, uip_slen
 75313 045c 9008     		ld.sh	r8, r8[0]
 75314 045e 5808     		cp.w	r8, 0
 75315 0460 E08006D3 		breq .L80
1214:uIP/uip/uip.c **** 	uip_len = uip_slen + UIP_IPUDPH_LEN;
 75316              		.loc 1 1214 0
 75317 0464 2E48     		sub     r8, -28
 75318 0466 F5D8B010 		bfexts	r10, r8, 0, 16
 75319 046a FEF90DC6 		lda.w	r9, uip_len
 75320 046e B20A     		st.h	r9[0], r10
1222:uIP/uip/uip.c **** 	BUF->len[0] = (uip_len >> 8);
 75321              		.loc 1 1222 0
 75322 0470 FEF80DA4 		lda.w	r8, uip_buf
 75323 0474 700B     		ld.w	r11, r8[0]
 75324 0476 F5DAC108 		bfextu	r10, r10, 8, 8
 75325 047a F76A0010 		st.b	r11[16], r10
1223:uIP/uip/uip.c **** 	BUF->len[1] = (uip_len & 0xff);
 75326              		.loc 1 1223 0
 75327 047e 700A     		ld.w	r10, r8[0]
 75328 0480 9209     		ld.sh	r9, r9[0]
 75329 0482 F5690011 		st.b	r10[17], r9
1226:uIP/uip/uip.c **** 	BUF->ttl = uip_udp_conn->ttl;
 75330              		.loc 1 1226 0
 75331 0486 700A     		ld.w	r10, r8[0]
 75332 0488 FEF90DB0 		lda.w	r9, uip_udp_conn
 75333 048c 720B     		ld.w	r11, r9[0]
 75334 048e F73B0008 		ld.ub	r11, r11[8]
 75335 0492 F56B0016 		st.b	r10[22], r11
1227:uIP/uip/uip.c **** 	BUF->proto = UIP_PROTO_UDP;
 75336              		.loc 1 1227 0
 75337 0496 700A     		ld.w	r10, r8[0]
 75338 0498 311B     		mov	r11, 17
 75339 049a F56B0017 		st.b	r10[23], r11
1229:uIP/uip/uip.c **** 	UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
 75340              		.loc 1 1229 0
 75341 049e 700A     		ld.w	r10, r8[0]
 75342 04a0 FEFB0D94 		lda.w	r11, uip_slen
 75343 04a4 960B     		ld.sh	r11, r11[0]
 75344 04a6 2F8B     		sub     r11, -8
 75345 04a8 F55B0026 		st.h	r10[38], r11
1230:uIP/uip/uip.c **** 	UDPBUF->udpchksum = 0;
 75346              		.loc 1 1230 0
 75347 04ac 700A     		ld.w	r10, r8[0]
 75348 04ae 300B     		mov	r11, 0
 75349 04b0 F55B0028 		st.h	r10[40], r11
1232:uIP/uip/uip.c **** 	BUF->srcport  = uip_udp_conn->lport;
 75350              		.loc 1 1232 0
 75351 04b4 700A     		ld.w	r10, r8[0]
 75352 04b6 720B     		ld.w	r11, r9[0]
 75353 04b8 962B     		ld.sh	r11, r11[4]
 75354 04ba F55B0022 		st.h	r10[34], r11
1233:uIP/uip/uip.c **** 	BUF->destport = uip_udp_conn->rport;
 75355              		.loc 1 1233 0
 75356 04be 700A     		ld.w	r10, r8[0]
 75357 04c0 720B     		ld.w	r11, r9[0]
 75358 04c2 963B     		ld.sh	r11, r11[6]
 75359 04c4 F55B0024 		st.h	r10[36], r11
1235:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 75360              		.loc 1 1235 0
 75361 04c8 700B     		ld.w	r11, r8[0]
 75362 04ca FEFA0D7A 		lda.w	r10, uip_hostaddr
 75363 04ce 940C     		ld.sh	r12, r10[0]
 75364              	.LVL81:
 75365 04d0 F75C001A 		st.h	r11[26], r12
 75366 04d4 700B     		ld.w	r11, r8[0]
 75367 04d6 941A     		ld.sh	r10, r10[2]
 75368 04d8 F75A001C 		st.h	r11[28], r10
1236:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
 75369              		.loc 1 1236 0
 75370 04dc 700A     		ld.w	r10, r8[0]
 75371 04de 720B     		ld.w	r11, r9[0]
 75372 04e0 960B     		ld.sh	r11, r11[0]
 75373 04e2 F55B001E 		st.h	r10[30], r11
 75374 04e6 700A     		ld.w	r10, r8[0]
 75375 04e8 7209     		ld.w	r9, r9[0]
 75376 04ea 9219     		ld.sh	r9, r9[2]
 75377 04ec F5590020 		st.h	r10[32], r9
1238:uIP/uip/uip.c **** 	uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
 75378              		.loc 1 1238 0
 75379 04f0 7009     		ld.w	r9, r8[0]
 75380 04f2 2CA9     		sub     r9, -54
 75381 04f4 FEF80D24 		lda.w	r8, uip_appdata
 75382 04f8 9109     		st.w	r8[0], r9
1249:uIP/uip/uip.c **** 	goto ip_send_nolen;
 75383              		.loc 1 1249 0
 75384 04fa E08F065D 		bral    .L112
 75385              	.L103:
1261:uIP/uip/uip.c **** 	if(uip_tcpchksum() != 0xffff)
 75386              		.loc 1 1261 0
 75387 04fe F01F0355 		call	uip_tcpchksum
 75388 0502 3FF8     		mov	r8, -1
 75389 0504 F00C1900 		cp.h	r12, r8
 75390 0508 E081067F 		brne .L80
1272:uIP/uip/uip.c **** 	for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr)
 75391              		.loc 1 1272 0
 75392 050c FEF90D48 		lda.w	r9, uip_conns
 75393 0510 FEF80D10 		lda.w	r8, uip_connr
 75394 0514 9109     		st.w	r8[0], r9
1274:uIP/uip/uip.c **** 		if(uip_connr->tcpstateflags != UIP_CLOSED && BUF->destport == uip_connr->lport && BUF->srcport ==
 75395              		.loc 1 1274 0
 75396 0516 FEF80CFE 		lda.w	r8, uip_buf
 75397 051a 7009     		ld.w	r9, r8[0]
 75398 051c 2F29     		sub     r9, -14
1272:uIP/uip/uip.c **** 	for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr)
 75399              		.loc 1 1272 0
 75400 051e FEFA0D02 		lda.w	r10, uip_connr
 75401 0522 FEFC0D32 		lda.w	r12, uip_conns
 75402 0526 F8CCFF34 		sub     r12, r12, -204
1274:uIP/uip/uip.c **** 		if(uip_connr->tcpstateflags != UIP_CLOSED && BUF->destport == uip_connr->lport && BUF->srcport ==
 75403              		.loc 1 1274 0
 75404 052a 300B     		mov	r11, 0
1272:uIP/uip/uip.c **** 	for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr)
 75405              		.loc 1 1272 0
 75406 052c C208     		rjmp    .L113
 75407              	.L116:
1274:uIP/uip/uip.c **** 		if(uip_connr->tcpstateflags != UIP_CLOSED && BUF->destport == uip_connr->lport && BUF->srcport ==
 75408              		.loc 1 1274 0
 75409 052e F13E0019 		ld.ub	lr, r8[25]
 75410 0532 F60E1800 		cp.b	lr, r11
 75411 0536 C180     		breq .L114
 75412 0538 F3070016 		ld.sh	r7, r9[22]
 75413 053c 902E     		ld.sh	lr, r8[4]
 75414 053e FC071900 		cp.h	r7, lr
 75415 0542 C121     		brne .L114
 75416 0544 F3070014 		ld.sh	r7, r9[20]
 75417 0548 903E     		ld.sh	lr, r8[6]
 75418 054a FC071900 		cp.h	r7, lr
 75419 054e C0C1     		brne .L114
 75420 0550 9267     		ld.sh	r7, r9[12]
 75421 0552 900E     		ld.sh	lr, r8[0]
 75422 0554 FC071900 		cp.h	r7, lr
 75423 0558 C071     		brne .L114
 75424 055a 9277     		ld.sh	r7, r9[14]
 75425 055c 901E     		ld.sh	lr, r8[2]
 75426 055e FC071900 		cp.h	r7, lr
 75427 0562 E08001EF 		breq .L115
 75428              	.L114:
1272:uIP/uip/uip.c **** 	for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr)
 75429              		.loc 1 1272 0
 75430 0566 F0C8FF34 		sub     r8, r8, -204
 75431 056a 9508     		st.w	r10[0], r8
 75432              	.L113:
 75433 056c 7408     		ld.w	r8, r10[0]
 75434 056e 1838     		cp.w	r8, r12
 75435 0570 FE98FFDF 		brls .L116
1284:uIP/uip/uip.c **** 	if((BUF->flags & TCP_CTL) != TCP_SYN)
 75436              		.loc 1 1284 0
 75437 0574 FEF80CA0 		lda.w	r8, uip_buf
 75438 0578 7008     		ld.w	r8, r8[0]
 75439 057a 2F28     		sub     r8, -14
 75440 057c F1390021 		ld.ub	r9, r8[33]
 75441 0580 F3D9C006 		bfextu	r9, r9, 0, 6
 75442 0584 5829     		cp.w	r9, 2
 75443 0586 C111     		brne .L117
1289:uIP/uip/uip.c **** 	tmp16 = BUF->destport;
 75444              		.loc 1 1289 0
 75445 0588 F1080016 		ld.sh	r8, r8[22]
 75446 058c FEF90CA0 		lda.w	r9, .LANCHOR0
 75447 0590 B268     		st.h	r9[12], r8
1293:uIP/uip/uip.c **** 		if(tmp16 == uip_listenports[c])
 75448              		.loc 1 1293 0
 75449 0592 FEF90CC6 		lda.w	r9, uip_listenports
 75450 0596 9209     		ld.sh	r9, r9[0]
 75451 0598 F0091900 		cp.h	r9, r8
 75452 059c E08000A2 		breq .L118
 75453 05a0 3019     		mov	r9, 1
 75454 05a2 FEF80C8A 		lda.w	r8, .LANCHOR0
 75455 05a6 B0C9     		st.b	r8[4], r9
 75456              	.L117:
1303:uIP/uip/uip.c **** 	if(BUF->flags & TCP_RST)
 75457              		.loc 1 1303 0
 75458 05a8 FEF80C6C 		lda.w	r8, uip_buf
 75459 05ac 7008     		ld.w	r8, r8[0]
 75460 05ae 2F28     		sub     r8, -14
 75461 05b0 F1390021 		ld.ub	r9, r8[33]
 75462 05b4 E2190004 		andl	r9, 4, COH
 75463 05b8 E0810627 		brne .L80
1310:uIP/uip/uip.c **** 	BUF->flags = TCP_RST | TCP_ACK;
 75464              		.loc 1 1310 0
 75465 05bc 3149     		mov	r9, 20
 75466 05be F1690021 		st.b	r8[33], r9
1311:uIP/uip/uip.c **** 	uip_len = UIP_IPTCPH_LEN;
 75467              		.loc 1 1311 0
 75468 05c2 3289     		mov	r9, 40
 75469 05c4 FEF80C6C 		lda.w	r8, uip_len
 75470 05c8 B009     		st.h	r8[0], r9
1312:uIP/uip/uip.c **** 	BUF->tcpoffset = 5 << 4;
 75471              		.loc 1 1312 0
 75472 05ca FEF80C4A 		lda.w	r8, uip_buf
 75473 05ce 7009     		ld.w	r9, r8[0]
 75474 05d0 350A     		mov	r10, 80
 75475 05d2 F36A002E 		st.b	r9[46], r10
1315:uIP/uip/uip.c **** 	c = BUF->seqno[3];
 75476              		.loc 1 1315 0
 75477 05d6 700A     		ld.w	r10, r8[0]
 75478 05d8 2F2A     		sub     r10, -14
 75479 05da FEF90C52 		lda.w	r9, .LANCHOR0
 75480 05de F53B001B 		ld.ub	r11, r10[27]
 75481 05e2 B2CB     		st.b	r9[4], r11
1316:uIP/uip/uip.c **** 	BUF->seqno[3] = BUF->ackno[3];
 75482              		.loc 1 1316 0
 75483 05e4 F53B001F 		ld.ub	r11, r10[31]
 75484 05e8 F56B001B 		st.b	r10[27], r11
1317:uIP/uip/uip.c **** 	BUF->ackno[3] = c;
 75485              		.loc 1 1317 0
 75486 05ec 700A     		ld.w	r10, r8[0]
 75487 05ee 13CB     		ld.ub	r11, r9[4]
 75488 05f0 F56B002D 		st.b	r10[45], r11
1319:uIP/uip/uip.c **** 	c = BUF->seqno[2];
 75489              		.loc 1 1319 0
 75490 05f4 700A     		ld.w	r10, r8[0]
 75491 05f6 2F2A     		sub     r10, -14
 75492 05f8 F53B001A 		ld.ub	r11, r10[26]
 75493 05fc B2CB     		st.b	r9[4], r11
1320:uIP/uip/uip.c **** 	BUF->seqno[2] = BUF->ackno[2];
 75494              		.loc 1 1320 0
 75495 05fe F53B001E 		ld.ub	r11, r10[30]
 75496 0602 F56B001A 		st.b	r10[26], r11
1321:uIP/uip/uip.c **** 	BUF->ackno[2] = c;
 75497              		.loc 1 1321 0
 75498 0606 700A     		ld.w	r10, r8[0]
 75499 0608 13CB     		ld.ub	r11, r9[4]
 75500 060a F56B002C 		st.b	r10[44], r11
1323:uIP/uip/uip.c **** 	c = BUF->seqno[1];
 75501              		.loc 1 1323 0
 75502 060e 700A     		ld.w	r10, r8[0]
 75503 0610 2F2A     		sub     r10, -14
 75504 0612 F53B0019 		ld.ub	r11, r10[25]
 75505 0616 B2CB     		st.b	r9[4], r11
1324:uIP/uip/uip.c **** 	BUF->seqno[1] = BUF->ackno[1];
 75506              		.loc 1 1324 0
 75507 0618 F53B001D 		ld.ub	r11, r10[29]
 75508 061c F56B0019 		st.b	r10[25], r11
1325:uIP/uip/uip.c **** 	BUF->ackno[1] = c;
 75509              		.loc 1 1325 0
 75510 0620 700A     		ld.w	r10, r8[0]
 75511 0622 13CB     		ld.ub	r11, r9[4]
 75512 0624 F56B002B 		st.b	r10[43], r11
1327:uIP/uip/uip.c **** 	c = BUF->seqno[0];
 75513              		.loc 1 1327 0
 75514 0628 700A     		ld.w	r10, r8[0]
 75515 062a 2F2A     		sub     r10, -14
 75516 062c F53B0018 		ld.ub	r11, r10[24]
 75517 0630 B2CB     		st.b	r9[4], r11
1328:uIP/uip/uip.c **** 	BUF->seqno[0] = BUF->ackno[0];
 75518              		.loc 1 1328 0
 75519 0632 F53B001C 		ld.ub	r11, r10[28]
 75520 0636 F56B0018 		st.b	r10[24], r11
1329:uIP/uip/uip.c **** 	BUF->ackno[0] = c;
 75521              		.loc 1 1329 0
 75522 063a 700A     		ld.w	r10, r8[0]
 75523 063c 13C9     		ld.ub	r9, r9[4]
 75524 063e F569002A 		st.b	r10[42], r9
1334:uIP/uip/uip.c **** 	if(++BUF->ackno[3] == 0)
 75525              		.loc 1 1334 0
 75526 0642 7009     		ld.w	r9, r8[0]
 75527 0644 2F29     		sub     r9, -14
 75528 0646 F338001F 		ld.ub	r8, r9[31]
 75529 064a 2FF8     		sub     r8, -1
 75530 064c 5C58     		castu.b	r8
 75531 064e F368001F 		st.b	r9[31], r8
 75532 0652 C201     		brne .L119
1336:uIP/uip/uip.c **** 		if(++BUF->ackno[2] == 0)
 75533              		.loc 1 1336 0
 75534 0654 FEF80BC0 		lda.w	r8, uip_buf
 75535 0658 7009     		ld.w	r9, r8[0]
 75536 065a 2F29     		sub     r9, -14
 75537 065c F338001E 		ld.ub	r8, r9[30]
 75538 0660 2FF8     		sub     r8, -1
 75539 0662 5C58     		castu.b	r8
 75540 0664 F368001E 		st.b	r9[30], r8
 75541 0668 C151     		brne .L119
1338:uIP/uip/uip.c **** 			if(++BUF->ackno[1] == 0)
 75542              		.loc 1 1338 0
 75543 066a FEF80BAA 		lda.w	r8, uip_buf
 75544 066e 7009     		ld.w	r9, r8[0]
 75545 0670 2F29     		sub     r9, -14
 75546 0672 F338001D 		ld.ub	r8, r9[29]
 75547 0676 2FF8     		sub     r8, -1
 75548 0678 5C58     		castu.b	r8
 75549 067a F368001D 		st.b	r9[29], r8
 75550 067e C0A1     		brne .L119
1340:uIP/uip/uip.c **** 				++BUF->ackno[0];
 75551              		.loc 1 1340 0
 75552 0680 FEF80B94 		lda.w	r8, uip_buf
 75553 0684 7008     		ld.w	r8, r8[0]
 75554 0686 2F28     		sub     r8, -14
 75555 0688 F139001C 		ld.ub	r9, r8[28]
 75556 068c 2FF9     		sub     r9, -1
 75557 068e F169001C 		st.b	r8[28], r9
 75558              	.L119:
1346:uIP/uip/uip.c **** 	tmp16 = BUF->srcport;
 75559              		.loc 1 1346 0
 75560 0692 FEF90B9A 		lda.w	r9, .LANCHOR0
 75561 0696 FEF80B7E 		lda.w	r8, uip_buf
 75562 069a 700A     		ld.w	r10, r8[0]
 75563 069c F50B0022 		ld.sh	r11, r10[34]
 75564 06a0 B26B     		st.h	r9[12], r11
1347:uIP/uip/uip.c **** 	BUF->srcport = BUF->destport;
 75565              		.loc 1 1347 0
 75566 06a2 2F2A     		sub     r10, -14
 75567 06a4 F50B0016 		ld.sh	r11, r10[22]
 75568 06a8 F55B0014 		st.h	r10[20], r11
1348:uIP/uip/uip.c **** 	BUF->destport = tmp16;
 75569              		.loc 1 1348 0
 75570 06ac 700A     		ld.w	r10, r8[0]
 75571 06ae 9269     		ld.sh	r9, r9[12]
 75572 06b0 F5590024 		st.h	r10[36], r9
1351:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
 75573              		.loc 1 1351 0
 75574 06b4 7009     		ld.w	r9, r8[0]
 75575 06b6 2F29     		sub     r9, -14
 75576 06b8 926A     		ld.sh	r10, r9[12]
 75577 06ba F35A0010 		st.h	r9[16], r10
 75578 06be 7009     		ld.w	r9, r8[0]
 75579 06c0 2F29     		sub     r9, -14
 75580 06c2 927A     		ld.sh	r10, r9[14]
 75581 06c4 F35A0012 		st.h	r9[18], r10
1352:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 75582              		.loc 1 1352 0
 75583 06c8 700A     		ld.w	r10, r8[0]
 75584 06ca FEF90B7A 		lda.w	r9, uip_hostaddr
 75585 06ce 920B     		ld.sh	r11, r9[0]
 75586 06d0 F55B001A 		st.h	r10[26], r11
 75587 06d4 7008     		ld.w	r8, r8[0]
 75588 06d6 9219     		ld.sh	r9, r9[2]
 75589 06d8 F159001C 		st.h	r8[28], r9
1355:uIP/uip/uip.c **** 	goto tcp_send_noconn;
 75590              		.loc 1 1355 0
 75591 06dc E08F054C 		bral    .L120
 75592              	.L118:
1369:uIP/uip/uip.c **** 	uip_connr = 0;
 75593              		.loc 1 1369 0
 75594 06e0 3008     		mov	r8, 0
 75595 06e2 FEF90B3E 		lda.w	r9, uip_connr
 75596 06e6 9308     		st.w	r9[0], r8
1370:uIP/uip/uip.c **** 	for(c = 0; c < UIP_CONNS; ++c)
 75597              		.loc 1 1370 0
 75598 06e8 300A     		mov	r10, 0
 75599 06ea FEF90B42 		lda.w	r9, .LANCHOR0
 75600 06ee B2CA     		st.b	r9[4], r10
1372:uIP/uip/uip.c **** 		if(uip_conns[c].tcpstateflags == UIP_CLOSED)
 75601              		.loc 1 1372 0
 75602 06f0 FEFA0B64 		lda.w	r10, uip_conns
 75603 06f4 E06900CC 		mov	r9, 204
1377:uIP/uip/uip.c **** 		if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT)
 75604              		.loc 1 1377 0
 75605 06f8 3076     		mov	r6, 7
1379:uIP/uip/uip.c **** 			if(uip_connr == 0 ||uip_conns[c].timer > uip_connr->timer)
 75606              		.loc 1 1379 0
 75607 06fa FEFC0B26 		lda.w	r12, uip_connr
1370:uIP/uip/uip.c **** 	for(c = 0; c < UIP_CONNS; ++c)
 75608              		.loc 1 1370 0
 75609 06fe FEFB0B2E 		lda.w	r11, .LANCHOR0
 75610 0702 3017     		mov	r7, 1
 75611              	.L125:
1372:uIP/uip/uip.c **** 		if(uip_conns[c].tcpstateflags == UIP_CLOSED)
 75612              		.loc 1 1372 0
 75613 0704 1095     		mov	r5, r8
 75614 0706 F009024E 		mul     lr, r8, r9
 75615 070a F40E000E 		add     lr, r10, lr
 75616 070e FD3E0019 		ld.ub	lr, lr[25]
 75617 0712 580E     		cp.w	lr, 0
 75618 0714 C0C1     		brne .L121
1374:uIP/uip/uip.c **** 			uip_connr = &uip_conns[c];
 75619              		.loc 1 1374 0
 75620 0716 E06900CC 		mov	r9, 204
 75621 071a B338     		mul     r8, r9
 75622 071c FEF90B38 		lda.w	r9, uip_conns
 75623 0720 F0090009 		add     r9, r8, r9
 75624 0724 FEF80AFC 		lda.w	r8, uip_connr
 75625 0728 9109     		st.w	r8[0], r9
1375:uIP/uip/uip.c **** 			break;
 75626              		.loc 1 1375 0
 75627 072a C1D8     		rjmp    .L122
 75628              	.L121:
1377:uIP/uip/uip.c **** 		if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT)
 75629              		.loc 1 1377 0
 75630 072c EC0E1800 		cp.b	lr, r6
 75631 0730 C121     		brne .L123
1379:uIP/uip/uip.c **** 			if(uip_connr == 0 ||uip_conns[c].timer > uip_connr->timer)
 75632              		.loc 1 1379 0
 75633 0732 780E     		ld.w	lr, r12[0]
 75634 0734 580E     		cp.w	lr, 0
 75635 0736 C0C0     		breq .L124
 75636 0738 B335     		mul     r5, r9
 75637 073a F4050005 		add     r5, r10, r5
 75638 073e EB35001A 		ld.ub	r5, r5[26]
 75639 0742 FD3E001A 		ld.ub	lr, lr[26]
 75640 0746 FC051800 		cp.b	r5, lr
 75641 074a E0880005 		brls .L123
 75642              	.L124:
1381:uIP/uip/uip.c **** 				uip_connr = &uip_conns[c];
 75643              		.loc 1 1381 0
 75644 074e B338     		mul     r8, r9
 75645 0750 1408     		add     r8, r10
 75646 0752 9908     		st.w	r12[0], r8
 75647              	.L123:
1370:uIP/uip/uip.c **** 	for(c = 0; c < UIP_CONNS; ++c)
 75648              		.loc 1 1370 0
 75649 0754 17C8     		ld.ub	r8, r11[4]
 75650 0756 2FF8     		sub     r8, -1
 75651 0758 5C58     		castu.b	r8
 75652 075a B6C8     		st.b	r11[4], r8
 75653 075c EE081800 		cp.b	r8, r7
 75654 0760 FE98FFD2 		brls .L125
 75655              	.L122:
1386:uIP/uip/uip.c **** 	if(uip_connr == 0)
 75656              		.loc 1 1386 0
 75657 0764 FEF80ABC 		lda.w	r8, uip_connr
 75658 0768 7008     		ld.w	r8, r8[0]
 75659 076a 5808     		cp.w	r8, 0
 75660 076c E080054D 		breq .L80
1396:uIP/uip/uip.c **** 	uip_conn = uip_connr;
 75661              		.loc 1 1396 0
 75662 0770 FEF90ACC 		lda.w	r9, uip_conn
 75663 0774 9308     		st.w	r9[0], r8
1399:uIP/uip/uip.c **** 	uip_connr->rto = uip_connr->timer = UIP_RTO;
 75664              		.loc 1 1399 0
 75665 0776 FEF80AAA 		lda.w	r8, uip_connr
 75666 077a 7009     		ld.w	r9, r8[0]
 75667 077c 303A     		mov	r10, 3
 75668 077e F36A001A 		st.b	r9[26], r10
 75669 0782 F36A0018 		st.b	r9[24], r10
1400:uIP/uip/uip.c **** 	uip_connr->sa = 0;
 75670              		.loc 1 1400 0
 75671 0786 700A     		ld.w	r10, r8[0]
 75672 0788 3009     		mov	r9, 0
 75673 078a F5690016 		st.b	r10[22], r9
1401:uIP/uip/uip.c **** 	uip_connr->sv = 4;
 75674              		.loc 1 1401 0
 75675 078e 700A     		ld.w	r10, r8[0]
 75676 0790 304B     		mov	r11, 4
 75677 0792 F56B0017 		st.b	r10[23], r11
1402:uIP/uip/uip.c **** 	uip_connr->nrtx = 0;
 75678              		.loc 1 1402 0
 75679 0796 700A     		ld.w	r10, r8[0]
 75680 0798 F569001B 		st.b	r10[27], r9
1403:uIP/uip/uip.c **** 	uip_connr->lport = BUF->destport;
 75681              		.loc 1 1403 0
 75682 079c 7009     		ld.w	r9, r8[0]
 75683 079e FEF70A76 		lda.w	r7, uip_buf
 75684 07a2 6E0A     		ld.w	r10, r7[0]
 75685 07a4 F50A0024 		ld.sh	r10, r10[36]
 75686 07a8 B22A     		st.h	r9[4], r10
1404:uIP/uip/uip.c **** 	uip_connr->rport = BUF->srcport;
 75687              		.loc 1 1404 0
 75688 07aa 7009     		ld.w	r9, r8[0]
 75689 07ac 6E0A     		ld.w	r10, r7[0]
 75690 07ae F50A0022 		ld.sh	r10, r10[34]
 75691 07b2 B23A     		st.h	r9[6], r10
1405:uIP/uip/uip.c **** 	uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
 75692              		.loc 1 1405 0
 75693 07b4 7009     		ld.w	r9, r8[0]
 75694 07b6 6E0A     		ld.w	r10, r7[0]
 75695 07b8 F50A001A 		ld.sh	r10, r10[26]
 75696 07bc B20A     		st.h	r9[0], r10
 75697 07be 7009     		ld.w	r9, r8[0]
 75698 07c0 6E0A     		ld.w	r10, r7[0]
 75699 07c2 F50A001C 		ld.sh	r10, r10[28]
 75700 07c6 B21A     		st.h	r9[2], r10
1406:uIP/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_SYN_RCVD;
 75701              		.loc 1 1406 0
 75702 07c8 7009     		ld.w	r9, r8[0]
 75703 07ca 301A     		mov	r10, 1
 75704 07cc F36A0019 		st.b	r9[25], r10
1408:uIP/uip/uip.c **** 	uip_connr->snd_nxt[0] = iss[0];
 75705              		.loc 1 1408 0
 75706 07d0 700A     		ld.w	r10, r8[0]
 75707 07d2 FEF90A5A 		lda.w	r9, .LANCHOR0
 75708 07d6 F33B0008 		ld.ub	r11, r9[8]
 75709 07da F56B000C 		st.b	r10[12], r11
1409:uIP/uip/uip.c **** 	uip_connr->snd_nxt[1] = iss[1];
 75710              		.loc 1 1409 0
 75711 07de 700A     		ld.w	r10, r8[0]
 75712 07e0 F33B0009 		ld.ub	r11, r9[9]
 75713 07e4 F56B000D 		st.b	r10[13], r11
1410:uIP/uip/uip.c **** 	uip_connr->snd_nxt[2] = iss[2];
 75714              		.loc 1 1410 0
 75715 07e8 700A     		ld.w	r10, r8[0]
 75716 07ea F33B000A 		ld.ub	r11, r9[10]
 75717 07ee F56B000E 		st.b	r10[14], r11
1411:uIP/uip/uip.c **** 	uip_connr->snd_nxt[3] = iss[3];
 75718              		.loc 1 1411 0
 75719 07f2 700A     		ld.w	r10, r8[0]
 75720 07f4 F339000B 		ld.ub	r9, r9[11]
 75721 07f8 F569000F 		st.b	r10[15], r9
1412:uIP/uip/uip.c **** 	uip_connr->len = 1;
 75722              		.loc 1 1412 0
 75723 07fc 7009     		ld.w	r9, r8[0]
 75724 07fe 301A     		mov	r10, 1
 75725 0800 F35A0010 		st.h	r9[16], r10
1415:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[3] = BUF->seqno[3];
 75726              		.loc 1 1415 0
 75727 0804 7009     		ld.w	r9, r8[0]
 75728 0806 6E0A     		ld.w	r10, r7[0]
 75729 0808 F53A0029 		ld.ub	r10, r10[41]
 75730 080c F36A000B 		st.b	r9[11], r10
1416:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[2] = BUF->seqno[2];
 75731              		.loc 1 1416 0
 75732 0810 7009     		ld.w	r9, r8[0]
 75733 0812 6E0A     		ld.w	r10, r7[0]
 75734 0814 F53A0028 		ld.ub	r10, r10[40]
 75735 0818 F36A000A 		st.b	r9[10], r10
1417:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[1] = BUF->seqno[1];
 75736              		.loc 1 1417 0
 75737 081c 7009     		ld.w	r9, r8[0]
 75738 081e 6E0A     		ld.w	r10, r7[0]
 75739 0820 F53A0027 		ld.ub	r10, r10[39]
 75740 0824 F36A0009 		st.b	r9[9], r10
1418:uIP/uip/uip.c **** 	uip_connr->rcv_nxt[0] = BUF->seqno[0];
 75741              		.loc 1 1418 0
 75742 0828 7008     		ld.w	r8, r8[0]
 75743 082a 6E09     		ld.w	r9, r7[0]
 75744 082c F3390026 		ld.ub	r9, r9[38]
 75745 0830 F1690008 		st.b	r8[8], r9
1419:uIP/uip/uip.c **** 	uip_add_rcv_nxt(1);
 75746              		.loc 1 1419 0
 75747 0834 301C     		mov	r12, 1
 75748 0836 F01F028A 		call	uip_add_rcv_nxt
1422:uIP/uip/uip.c **** 	if((BUF->tcpoffset & 0xf0) > 0x50)
 75749              		.loc 1 1422 0
 75750 083a 6E08     		ld.w	r8, r7[0]
 75751 083c F138002E 		ld.ub	r8, r8[46]
 75752 0840 E21800F0 		andl	r8, 240, COH
 75753 0844 E0480050 		cp.w	r8, 80
 75754 0848 E08A0053 		brle .L91
1424:uIP/uip/uip.c **** 		for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
 75755              		.loc 1 1424 0
 75756 084c 3009     		mov	r9, 0
 75757 084e FEF809DE 		lda.w	r8, .LANCHOR0
 75758 0852 B0C9     		st.b	r8[4], r9
 75759 0854 6E09     		ld.w	r9, r7[0]
 75760 0856 F2C6FFF2 		sub     r6, r9, -14
 75761 085a FEF809D2 		lda.w	r8, .LANCHOR0
1432:uIP/uip/uip.c **** 			else if(opt == TCP_OPT_NOOP)
 75762              		.loc 1 1432 0
 75763 085e 3017     		mov	r7, 1
1437:uIP/uip/uip.c **** 			else if(opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN)
 75764              		.loc 1 1437 0
 75765 0860 302E     		mov	lr, 2
 75766 0862 304C     		mov	r12, 4
1424:uIP/uip/uip.c **** 		for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
 75767              		.loc 1 1424 0
 75768 0864 C3D8     		rjmp    .L179
 75769              	.L129:
1426:uIP/uip/uip.c **** 			opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
 75770              		.loc 1 1426 0
 75771 0866 F20A000A 		add     r10, r9, r10
 75772 086a F53A0036 		ld.ub	r10, r10[54]
 75773 086e F16A000E 		st.b	r8[14], r10
1427:uIP/uip/uip.c **** 			if(opt == TCP_OPT_END)
 75774              		.loc 1 1427 0
 75775 0872 580A     		cp.w	r10, 0
 75776 0874 C3D0     		breq .L91
1432:uIP/uip/uip.c **** 			else if(opt == TCP_OPT_NOOP)
 75777              		.loc 1 1432 0
 75778 0876 EE0A1800 		cp.b	r10, r7
 75779 087a C051     		brne .L127
1434:uIP/uip/uip.c **** 				++c;
 75780              		.loc 1 1434 0
 75781 087c 11CA     		ld.ub	r10, r8[4]
 75782 087e 2FFA     		sub     r10, -1
 75783 0880 B0CA     		st.b	r8[4], r10
 75784 0882 C2E8     		rjmp    .L179
 75785              	.L127:
1437:uIP/uip/uip.c **** 			else if(opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN)
 75786              		.loc 1 1437 0
 75787 0884 FC0A1800 		cp.b	r10, lr
 75788 0888 C211     		brne .L128
 75789 088a 11CA     		ld.ub	r10, r8[4]
 75790 088c F20A000B 		add     r11, r9, r10
 75791 0890 F73B0037 		ld.ub	r11, r11[55]
 75792 0894 F80B1800 		cp.b	r11, r12
 75793 0898 C191     		brne .L128
1440:uIP/uip/uip.c **** 				tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) | (u16_t)uip_buf[UIP_IPTCPH
 75794              		.loc 1 1440 0
 75795 089a 1409     		add     r9, r10
 75796 089c F33A0038 		ld.ub	r10, r9[56]
 75797 08a0 F3380039 		ld.ub	r8, r9[57]
 75798 08a4 F1EA1088 		or	r8, r8, r10 << 8
 75799 08a8 FEF90984 		lda.w	r9, .LANCHOR0
 75800 08ac B268     		st.h	r9[12], r8
1441:uIP/uip/uip.c **** 				uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
 75801              		.loc 1 1441 0
 75802 08ae FEF90972 		lda.w	r9, uip_connr
 75803 08b2 7209     		ld.w	r9, r9[0]
 75804 08b4 E06A060A 		mov	r10, 1546
 75805 08b8 F4081900 		cp.h	r8, r10
 75806 08bc F40817B0 		movhi    r8, r10
 75807 08c0 F3580012 		st.h	r9[18], r8
 75808 08c4 F3580014 		st.h	r9[20], r8
1444:uIP/uip/uip.c **** 				break;
 75809              		.loc 1 1444 0
 75810 08c8 C138     		rjmp    .L91
 75811              	.L128:
1450:uIP/uip/uip.c **** 				if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0)
 75812              		.loc 1 1450 0
 75813 08ca 11CA     		ld.ub	r10, r8[4]
 75814 08cc F20A000B 		add     r11, r9, r10
 75815 08d0 F73B0037 		ld.ub	r11, r11[55]
 75816 08d4 580B     		cp.w	r11, 0
 75817 08d6 C0C0     		breq .L91
1457:uIP/uip/uip.c **** 				c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
 75818              		.loc 1 1457 0
 75819 08d8 F60A000A 		add     r10, r11, r10
 75820 08dc B0CA     		st.b	r8[4], r10
 75821              	.L179:
1424:uIP/uip/uip.c **** 		for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
 75822              		.loc 1 1424 0
 75823 08de 11CA     		ld.ub	r10, r8[4]
 75824 08e0 ED3B0020 		ld.ub	r11, r6[32]
 75825 08e4 A58B     		lsr     r11, 4
 75826 08e6 205B     		sub     r11, 5
 75827 08e8 A36B     		lsl     r11, 2
 75828 08ea 163A     		cp.w	r10, r11
 75829 08ec CBD5     		brlt .L129
 75830              	.L91:
1466:uIP/uip/uip.c **** 	BUF->flags = TCP_ACK;
 75831              		.loc 1 1466 0
 75832 08ee FEF80926 		lda.w	r8, uip_buf
 75833 08f2 7008     		ld.w	r8, r8[0]
 75834 08f4 3109     		mov	r9, 16
 75835 08f6 F169002F 		st.b	r8[47], r9
 75836              	.L96:
1470:uIP/uip/uip.c **** 	BUF->flags |= TCP_SYN;
 75837              		.loc 1 1470 0
 75838 08fa FEF8091A 		lda.w	r8, uip_buf
 75839 08fe 7009     		ld.w	r9, r8[0]
 75840 0900 2F29     		sub     r9, -14
 75841 0902 F33A0021 		ld.ub	r10, r9[33]
 75842 0906 A1BA     		sbr	r10, 1
 75843 0908 F36A0021 		st.b	r9[33], r10
1479:uIP/uip/uip.c **** 	BUF->optdata[0] = TCP_OPT_MSS;
 75844              		.loc 1 1479 0
 75845 090c 7009     		ld.w	r9, r8[0]
 75846 090e 302A     		mov	r10, 2
 75847 0910 F36A0036 		st.b	r9[54], r10
1480:uIP/uip/uip.c **** 	BUF->optdata[1] = TCP_OPT_MSS_LEN;
 75848              		.loc 1 1480 0
 75849 0914 7009     		ld.w	r9, r8[0]
 75850 0916 304A     		mov	r10, 4
 75851 0918 F36A0037 		st.b	r9[55], r10
1481:uIP/uip/uip.c **** 	BUF->optdata[2] = (UIP_TCP_MSS) / 256;
 75852              		.loc 1 1481 0
 75853 091c 7009     		ld.w	r9, r8[0]
 75854 091e 306A     		mov	r10, 6
 75855 0920 F36A0038 		st.b	r9[56], r10
1482:uIP/uip/uip.c **** 	BUF->optdata[3] = (UIP_TCP_MSS) & 255;
 75856              		.loc 1 1482 0
 75857 0924 7009     		ld.w	r9, r8[0]
 75858 0926 30AA     		mov	r10, 10
 75859 0928 F36A0039 		st.b	r9[57], r10
1483:uIP/uip/uip.c **** 	uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
 75860              		.loc 1 1483 0
 75861 092c 32CA     		mov	r10, 44
 75862 092e FEF90902 		lda.w	r9, uip_len
 75863 0932 B20A     		st.h	r9[0], r10
1484:uIP/uip/uip.c **** 	BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
 75864              		.loc 1 1484 0
 75865 0934 7008     		ld.w	r8, r8[0]
 75866 0936 3609     		mov	r9, 96
 75867 0938 F169002E 		st.b	r8[46], r9
1485:uIP/uip/uip.c **** 	goto tcp_send;
 75868              		.loc 1 1485 0
 75869 093c E08F03B1 		bral    .L130
 75870              	.L115:
1490:uIP/uip/uip.c **** 	uip_conn = uip_connr;
 75871              		.loc 1 1490 0
 75872 0940 FEF908FC 		lda.w	r9, uip_conn
 75873 0944 9308     		st.w	r9[0], r8
1491:uIP/uip/uip.c **** 	uip_flags = 0;
 75874              		.loc 1 1491 0
 75875 0946 3009     		mov	r9, 0
 75876 0948 FEF808DC 		lda.w	r8, uip_flags
 75877 094c B089     		st.b	r8[0], r9
1496:uIP/uip/uip.c **** 	if(BUF->flags & TCP_RST)
 75878              		.loc 1 1496 0
 75879 094e FEF808C6 		lda.w	r8, uip_buf
 75880 0952 7008     		ld.w	r8, r8[0]
 75881 0954 2F28     		sub     r8, -14
 75882 0956 F1390021 		ld.ub	r9, r8[33]
 75883 095a E2190004 		andl	r9, 4, COH
 75884 095e C0F0     		breq .L131
1498:uIP/uip/uip.c **** 		uip_connr->tcpstateflags = UIP_CLOSED;
 75885              		.loc 1 1498 0
 75886 0960 FEF808C0 		lda.w	r8, uip_connr
 75887 0964 7008     		ld.w	r8, r8[0]
 75888 0966 3009     		mov	r9, 0
 75889 0968 F1690019 		st.b	r8[25], r9
1500:uIP/uip/uip.c **** 		uip_flags = UIP_ABORT;
 75890              		.loc 1 1500 0
 75891 096c 3209     		mov	r9, 32
 75892 096e FEF808B6 		lda.w	r8, uip_flags
 75893 0972 B089     		st.b	r8[0], r9
1502:uIP/uip/uip.c **** 		UIP_APPCALL();
 75894              		.loc 1 1502 0
 75895 0974 F01F022D 		call	NetSDR_appcall
1503:uIP/uip/uip.c **** 		goto drop;
 75896              		.loc 1 1503 0
 75897 0978 E08F0447 		bral    .L80
 75898              	.L131:
1507:uIP/uip/uip.c **** 	c = (BUF->tcpoffset >> 4) << 2;
 75899              		.loc 1 1507 0
 75900 097c F1380020 		ld.ub	r8, r8[32]
 75901 0980 A388     		lsr     r8, 2
 75902 0982 E218003C 		andl	r8, 60, COH
 75903 0986 FEF908A6 		lda.w	r9, .LANCHOR0
 75904 098a B2C8     		st.b	r9[4], r8
1511:uIP/uip/uip.c **** 	uip_len = uip_len - c - UIP_IPH_LEN;
 75905              		.loc 1 1511 0
 75906 098c FEF908A4 		lda.w	r9, uip_len
 75907 0990 920A     		ld.sh	r10, r9[0]
 75908 0992 214A     		sub     r10, 20
 75909 0994 F4080108 		sub     r8, r10, r8
 75910 0998 5C88     		casts.h	r8
 75911 099a B208     		st.h	r9[0], r8
1516:uIP/uip/uip.c **** 	if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((BUF->flags & TCP_CTL) == (TCP
 75912              		.loc 1 1516 0
 75913 099c FEF90884 		lda.w	r9, uip_connr
 75914 09a0 720C     		ld.w	r12, r9[0]
 75915 09a2 F9390019 		ld.ub	r9, r12[25]
 75916 09a6 F3D9C004 		bfextu	r9, r9, 0, 4
 75917 09aa 5829     		cp.w	r9, 2
 75918 09ac C0A1     		brne .L132
 75919 09ae FEF90866 		lda.w	r9, uip_buf
 75920 09b2 7209     		ld.w	r9, r9[0]
 75921 09b4 F339002F 		ld.ub	r9, r9[47]
 75922 09b8 F3D9C006 		bfextu	r9, r9, 0, 6
 75923 09bc 5929     		cp.w	r9, 18
 75924 09be C1D0     		breq .L133
 75925              	.L132:
1518:uIP/uip/uip.c **** 		if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
 75926              		.loc 1 1518 0
 75927 09c0 5808     		cp.w	r8, 0
 75928 09c2 C091     		brne .L134
 75929 09c4 FEF80850 		lda.w	r8, uip_buf
 75930 09c8 7008     		ld.w	r8, r8[0]
 75931 09ca F138002F 		ld.ub	r8, r8[47]
 75932 09ce F1D8C002 		bfextu	r8, r8, 0, 2
 75933 09d2 C130     		breq .L133
 75934              	.L134:
1519:uIP/uip/uip.c **** 			(BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
 75935              		.loc 1 1519 0
 75936 09d4 FEF80840 		lda.w	r8, uip_buf
 75937 09d8 7008     		ld.w	r8, r8[0]
 75938 09da 2F28     		sub     r8, -14
 75939 09dc F10A0018 		ld.sh	r10, r8[24]
 75940 09e0 9849     		ld.sh	r9, r12[8]
 75941 09e2 F20A1900 		cp.h	r10, r9
 75942 09e6 E081034F 		brne .L135
1521:uIP/uip/uip.c **** 			 BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
 75943              		.loc 1 1521 0
 75944 09ea F109001A 		ld.sh	r9, r8[26]
 75945 09ee 9858     		ld.sh	r8, r12[10]
 75946 09f0 F0091900 		cp.h	r9, r8
 75947 09f4 E0810348 		brne .L135
 75948              	.L133:
1532:uIP/uip/uip.c **** 	if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr))
 75949              		.loc 1 1532 0
 75950 09f8 FEF8081C 		lda.w	r8, uip_buf
 75951 09fc 7008     		ld.w	r8, r8[0]
 75952 09fe F138002F 		ld.ub	r8, r8[47]
 75953 0a02 E2180010 		andl	r8, 16, COH
 75954 0a06 C7D0     		breq .L136
 75955 0a08 F90B0010 		ld.sh	r11, r12[16]
 75956 0a0c 580B     		cp.w	r11, 0
 75957 0a0e C790     		breq .L136
1534:uIP/uip/uip.c **** 		uip_add32(uip_connr->snd_nxt, uip_connr->len);
 75958              		.loc 1 1534 0
 75959 0a10 5C7B     		castu.h	r11
 75960 0a12 2F4C     		sub     r12, -12
 75961 0a14 F01F0213 		call	uip_add32
1536:uIP/uip/uip.c **** 		if( BUF->ackno[0] == uip_acc32[0] &&
 75962              		.loc 1 1536 0
 75963 0a18 FEF807FC 		lda.w	r8, uip_buf
 75964 0a1c 7008     		ld.w	r8, r8[0]
 75965 0a1e 2F28     		sub     r8, -14
 75966 0a20 F139001C 		ld.ub	r9, r8[28]
 75967 0a24 FEFA0840 		lda.w	r10, uip_acc32
 75968 0a28 158A     		ld.ub	r10, r10[0]
 75969 0a2a F20A1800 		cp.b	r10, r9
 75970 0a2e C691     		brne .L136
1537:uIP/uip/uip.c **** 			BUF->ackno[1] == uip_acc32[1] &&
 75971              		.loc 1 1537 0
 75972 0a30 F13B001D 		ld.ub	r11, r8[29]
 75973 0a34 FEFA0830 		lda.w	r10, uip_acc32
 75974 0a38 159A     		ld.ub	r10, r10[1]
 75975 0a3a F40B1800 		cp.b	r11, r10
 75976 0a3e C611     		brne .L136
1538:uIP/uip/uip.c **** 			BUF->ackno[2] == uip_acc32[2] &&
 75977              		.loc 1 1538 0
 75978 0a40 F13B001E 		ld.ub	r11, r8[30]
 75979 0a44 FEFA0820 		lda.w	r10, uip_acc32
 75980 0a48 15AA     		ld.ub	r10, r10[2]
 75981 0a4a F40B1800 		cp.b	r11, r10
 75982 0a4e C591     		brne .L136
1539:uIP/uip/uip.c **** 			BUF->ackno[3] == uip_acc32[3])
 75983              		.loc 1 1539 0
 75984 0a50 F13A001F 		ld.ub	r10, r8[31]
 75985 0a54 FEF80810 		lda.w	r8, uip_acc32
 75986 0a58 11B8     		ld.ub	r8, r8[3]
 75987 0a5a F00A1800 		cp.b	r10, r8
 75988 0a5e C511     		brne .L136
1542:uIP/uip/uip.c **** 			uip_connr->snd_nxt[0] = uip_acc32[0];
 75989              		.loc 1 1542 0
 75990 0a60 FEF807C0 		lda.w	r8, uip_connr
 75991 0a64 700A     		ld.w	r10, r8[0]
 75992 0a66 F569000C 		st.b	r10[12], r9
1543:uIP/uip/uip.c **** 			uip_connr->snd_nxt[1] = uip_acc32[1];
 75993              		.loc 1 1543 0
 75994 0a6a 700A     		ld.w	r10, r8[0]
 75995 0a6c FEF907F8 		lda.w	r9, uip_acc32
 75996 0a70 139B     		ld.ub	r11, r9[1]
 75997 0a72 F56B000D 		st.b	r10[13], r11
1544:uIP/uip/uip.c **** 			uip_connr->snd_nxt[2] = uip_acc32[2];
 75998              		.loc 1 1544 0
 75999 0a76 700A     		ld.w	r10, r8[0]
 76000 0a78 13AB     		ld.ub	r11, r9[2]
 76001 0a7a F56B000E 		st.b	r10[14], r11
1545:uIP/uip/uip.c **** 			uip_connr->snd_nxt[3] = uip_acc32[3];
 76002              		.loc 1 1545 0
 76003 0a7e 700A     		ld.w	r10, r8[0]
 76004 0a80 13B9     		ld.ub	r9, r9[3]
 76005 0a82 F569000F 		st.b	r10[15], r9
1549:uIP/uip/uip.c **** 			if(uip_connr->nrtx == 0)
 76006              		.loc 1 1549 0
 76007 0a86 7008     		ld.w	r8, r8[0]
 76008 0a88 F13A001B 		ld.ub	r10, r8[27]
 76009 0a8c 3009     		mov	r9, 0
 76010 0a8e F20A1800 		cp.b	r10, r9
 76011 0a92 C281     		brne .L137
 76012              	.LBB6:
1554:uIP/uip/uip.c **** 				m = m - (uip_connr->sa >> 3);
 76013              		.loc 1 1554 0
 76014 0a94 F1390016 		ld.ub	r9, r8[22]
 76015 0a98 F13B0018 		ld.ub	r11, r8[24]
 76016 0a9c F13A001A 		ld.ub	r10, r8[26]
 76017 0aa0 141B     		sub     r11, r10
 76018 0aa2 F20A1603 		lsr     r10, r9, 3
 76019 0aa6 F60A010A 		sub     r10, r11, r10
1555:uIP/uip/uip.c **** 				uip_connr->sa += m;
 76020              		.loc 1 1555 0
 76021 0aaa F4090009 		add     r9, r10, r9
 76022 0aae F1690016 		st.b	r8[22], r9
1560:uIP/uip/uip.c **** 				m = m - (uip_connr->sv >> 2);
 76023              		.loc 1 1560 0
 76024 0ab2 FEF8076E 		lda.w	r8, uip_connr
 76025 0ab6 7009     		ld.w	r9, r8[0]
 76026 0ab8 F33B0017 		ld.ub	r11, r9[23]
1561:uIP/uip/uip.c **** 				uip_connr->sv += m;
 76027              		.loc 1 1561 0
 76028 0abc F60C1602 		lsr     r12, r11, 2
 76029 0ac0 181B     		sub     r11, r12
 76030 0ac2 5C6A     		casts.b	r10
 76031              	.LVL82:
 76032 0ac4 5C4A     		abs	r10
 76033              	.LVL83:
 76034 0ac6 F60A000A 		add     r10, r11, r10
 76035 0aca F36A0017 		st.b	r9[23], r10
1562:uIP/uip/uip.c **** 				uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
 76036              		.loc 1 1562 0
 76037 0ace 7008     		ld.w	r8, r8[0]
 76038 0ad0 F1390016 		ld.ub	r9, r8[22]
 76039 0ad4 A399     		lsr     r9, 3
 76040 0ad6 F13A0017 		ld.ub	r10, r8[23]
 76041 0ada F4090009 		add     r9, r10, r9
 76042 0ade F1690018 		st.b	r8[24], r9
 76043              	.L137:
 76044              	.LBE6:
1565:uIP/uip/uip.c **** 			uip_flags = UIP_ACKDATA;
 76045              		.loc 1 1565 0
 76046 0ae2 3019     		mov	r9, 1
 76047 0ae4 FEF80740 		lda.w	r8, uip_flags
 76048 0ae8 B089     		st.b	r8[0], r9
1567:uIP/uip/uip.c **** 			uip_connr->timer = uip_connr->rto;
 76049              		.loc 1 1567 0
 76050 0aea FEF80736 		lda.w	r8, uip_connr
 76051 0aee 7009     		ld.w	r9, r8[0]
 76052 0af0 F33A0018 		ld.ub	r10, r9[24]
 76053 0af4 F36A001A 		st.b	r9[26], r10
1570:uIP/uip/uip.c **** 			uip_connr->len = 0;
 76054              		.loc 1 1570 0
 76055 0af8 7008     		ld.w	r8, r8[0]
 76056 0afa 3009     		mov	r9, 0
 76057 0afc F1590010 		st.h	r8[16], r9
 76058              	.L136:
1575:uIP/uip/uip.c **** 	switch(uip_connr->tcpstateflags & UIP_TS_MASK)
 76059              		.loc 1 1575 0
 76060 0b00 FEF80720 		lda.w	r8, uip_connr
 76061 0b04 7008     		ld.w	r8, r8[0]
 76062 0b06 F13B0019 		ld.ub	r11, r8[25]
 76063 0b0a F3DBC004 		bfextu	r9, r11, 0, 4
 76064 0b0e 2019     		sub     r9, 1
 76065 0b10 5879     		cp.w	r9, 7
 76066 0b12 E08B037A 		brhi .L80
 76067 0b16 FEFA0752 		lda.w	r10, .L145
 76068 0b1a F409032F 		ld.w	pc, r10[r9 << 2]
 76069              		.text
 76070              		.align	2
 76071              		.align	2
 76072              	.L145:
 76073 0000 00000000 		.long .L138
 76074 0004 00000000 		.long .L139
 76075 0008 00000000 		.long .L140
 76076 000c 00000000 		.long .L141
 76077 0010 00000000 		.long .L142
 76078 0014 00000000 		.long .L143
 76079 0018 00000000 		.long .L135
 76080 001c 00000000 		.long .L144
 76081              		.section	.text.uip_process
 76082              	.L138:
1586:uIP/uip/uip.c **** 		if(uip_flags & UIP_ACKDATA)
 76083              		.loc 1 1586 0
 76084 0b1e FEF90706 		lda.w	r9, uip_flags
 76085 0b22 1389     		ld.ub	r9, r9[0]
 76086 0b24 F3D9C001 		bfextu	r9, r9, 0, 1
 76087 0b28 E080036F 		breq .L80
1588:uIP/uip/uip.c **** 			uip_connr->tcpstateflags = UIP_ESTABLISHED;
 76088              		.loc 1 1588 0
 76089 0b2c 3039     		mov	r9, 3
 76090 0b2e F1690019 		st.b	r8[25], r9
1589:uIP/uip/uip.c **** 			uip_flags = UIP_CONNECTED;
 76091              		.loc 1 1589 0
 76092 0b32 3409     		mov	r9, 64
 76093 0b34 FEF806F0 		lda.w	r8, uip_flags
 76094 0b38 B089     		st.b	r8[0], r9
1590:uIP/uip/uip.c **** 			uip_connr->len = 0;
 76095              		.loc 1 1590 0
 76096 0b3a FEF806E6 		lda.w	r8, uip_connr
 76097 0b3e 7008     		ld.w	r8, r8[0]
 76098 0b40 3009     		mov	r9, 0
 76099 0b42 F1590010 		st.h	r8[16], r9
1591:uIP/uip/uip.c **** 			if(uip_len > 0)
 76100              		.loc 1 1591 0
 76101 0b46 FEF806EA 		lda.w	r8, uip_len
 76102 0b4a 900C     		ld.sh	r12, r8[0]
 76103 0b4c 580C     		cp.w	r12, 0
 76104 0b4e C090     		breq .L146
1593:uIP/uip/uip.c **** 				uip_flags |= UIP_NEWDATA;
 76105              		.loc 1 1593 0
 76106 0b50 FEF806D4 		lda.w	r8, uip_flags
 76107 0b54 1189     		ld.ub	r9, r8[0]
 76108 0b56 A1B9     		sbr	r9, 1
 76109 0b58 B089     		st.b	r8[0], r9
1594:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
 76110              		.loc 1 1594 0
 76111 0b5a 5C7C     		castu.h	r12
 76112 0b5c F01F01C0 		call	uip_add_rcv_nxt
 76113              	.L146:
1596:uIP/uip/uip.c **** 			uip_slen = 0;
 76114              		.loc 1 1596 0
 76115 0b60 3009     		mov	r9, 0
 76116 0b62 FEF806D2 		lda.w	r8, uip_slen
 76117 0b66 B009     		st.h	r8[0], r9
1598:uIP/uip/uip.c **** 			UIP_APPCALL();
 76118              		.loc 1 1598 0
 76119 0b68 F01F01B0 		call	NetSDR_appcall
1599:uIP/uip/uip.c **** 			goto appsend;
 76120              		.loc 1 1599 0
 76121 0b6c C599     		rjmp    .L81
 76122              	.L139:
1608:uIP/uip/uip.c **** 			if((uip_flags & UIP_ACKDATA) && (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))
 76123              		.loc 1 1608 0
 76124 0b6e FEF806B6 		lda.w	r8, uip_flags
 76125 0b72 1188     		ld.ub	r8, r8[0]
 76126 0b74 F1D8C001 		bfextu	r8, r8, 0, 1
 76127 0b78 E080009C 		breq .L147
 76128 0b7c FEF80698 		lda.w	r8, uip_buf
 76129 0b80 7008     		ld.w	r8, r8[0]
 76130 0b82 2F28     		sub     r8, -14
 76131 0b84 F1390021 		ld.ub	r9, r8[33]
 76132 0b88 F3D9C006 		bfextu	r9, r9, 0, 6
 76133 0b8c 5929     		cp.w	r9, 18
 76134 0b8e E0810091 		brne .L147
1612:uIP/uip/uip.c **** 				if((BUF->tcpoffset & 0xf0) > 0x50)
 76135              		.loc 1 1612 0
 76136 0b92 F1380020 		ld.ub	r8, r8[32]
 76137 0b96 E21800F0 		andl	r8, 240, COH
 76138 0b9a E0480050 		cp.w	r8, 80
 76139 0b9e E08A0055 		brle .L148
1614:uIP/uip/uip.c **** 					for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
 76140              		.loc 1 1614 0
 76141 0ba2 3009     		mov	r9, 0
 76142 0ba4 FEF80688 		lda.w	r8, .LANCHOR0
 76143 0ba8 B0C9     		st.b	r8[4], r9
 76144 0baa FEF8066A 		lda.w	r8, uip_buf
 76145 0bae 7009     		ld.w	r9, r8[0]
 76146 0bb0 F2C6FFF2 		sub     r6, r9, -14
 76147 0bb4 FEF80678 		lda.w	r8, .LANCHOR0
1622:uIP/uip/uip.c **** 						else if(opt == TCP_OPT_NOOP)
 76148              		.loc 1 1622 0
 76149 0bb8 3017     		mov	r7, 1
1627:uIP/uip/uip.c **** 						else if(opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LE
 76150              		.loc 1 1627 0
 76151 0bba 302E     		mov	lr, 2
 76152 0bbc 304C     		mov	r12, 4
1614:uIP/uip/uip.c **** 					for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
 76153              		.loc 1 1614 0
 76154 0bbe C3D8     		rjmp    .L180
 76155              	.L152:
1616:uIP/uip/uip.c **** 						opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
 76156              		.loc 1 1616 0
 76157 0bc0 F20A000A 		add     r10, r9, r10
 76158 0bc4 F53A0036 		ld.ub	r10, r10[54]
 76159 0bc8 F16A000E 		st.b	r8[14], r10
1617:uIP/uip/uip.c **** 						if(opt == TCP_OPT_END)
 76160              		.loc 1 1617 0
 76161 0bcc 580A     		cp.w	r10, 0
 76162 0bce C3D0     		breq .L148
1622:uIP/uip/uip.c **** 						else if(opt == TCP_OPT_NOOP)
 76163              		.loc 1 1622 0
 76164 0bd0 EE0A1800 		cp.b	r10, r7
 76165 0bd4 C051     		brne .L150
1624:uIP/uip/uip.c **** 							++c;
 76166              		.loc 1 1624 0
 76167 0bd6 11CA     		ld.ub	r10, r8[4]
 76168 0bd8 2FFA     		sub     r10, -1
 76169 0bda B0CA     		st.b	r8[4], r10
 76170 0bdc C2E8     		rjmp    .L180
 76171              	.L150:
1627:uIP/uip/uip.c **** 						else if(opt == TCP_OPT_MSS && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LE
 76172              		.loc 1 1627 0
 76173 0bde FC0A1800 		cp.b	r10, lr
 76174 0be2 C211     		brne .L151
 76175 0be4 11CA     		ld.ub	r10, r8[4]
 76176 0be6 F20A000B 		add     r11, r9, r10
 76177 0bea F73B0037 		ld.ub	r11, r11[55]
 76178 0bee F80B1800 		cp.b	r11, r12
 76179 0bf2 C191     		brne .L151
1630:uIP/uip/uip.c **** 							tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) | uip_buf[UIP_TCPIP_HLEN + UIP_
 76180              		.loc 1 1630 0
 76181 0bf4 1409     		add     r9, r10
 76182 0bf6 F33A0038 		ld.ub	r10, r9[56]
 76183 0bfa F3380039 		ld.ub	r8, r9[57]
 76184 0bfe F1EA1088 		or	r8, r8, r10 << 8
 76185 0c02 FEF9062A 		lda.w	r9, .LANCHOR0
 76186 0c06 B268     		st.h	r9[12], r8
1631:uIP/uip/uip.c **** 							uip_connr->initialmss =	uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
 76187              		.loc 1 1631 0
 76188 0c08 FEF90618 		lda.w	r9, uip_connr
 76189 0c0c 7209     		ld.w	r9, r9[0]
 76190 0c0e E06A060A 		mov	r10, 1546
 76191 0c12 F4081900 		cp.h	r8, r10
 76192 0c16 F40817B0 		movhi    r8, r10
 76193 0c1a F3580012 		st.h	r9[18], r8
 76194 0c1e F3580014 		st.h	r9[20], r8
1634:uIP/uip/uip.c **** 							break;
 76195              		.loc 1 1634 0
 76196 0c22 C138     		rjmp    .L148
 76197              	.L151:
1640:uIP/uip/uip.c **** 							if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0)
 76198              		.loc 1 1640 0
 76199 0c24 11CA     		ld.ub	r10, r8[4]
 76200 0c26 F20A000B 		add     r11, r9, r10
 76201 0c2a F73B0037 		ld.ub	r11, r11[55]
 76202 0c2e 580B     		cp.w	r11, 0
 76203 0c30 C0C0     		breq .L148
1646:uIP/uip/uip.c **** 							c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
 76204              		.loc 1 1646 0
 76205 0c32 F60A000A 		add     r10, r11, r10
 76206 0c36 B0CA     		st.b	r8[4], r10
 76207              	.L180:
1614:uIP/uip/uip.c **** 					for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;)
 76208              		.loc 1 1614 0
 76209 0c38 11CA     		ld.ub	r10, r8[4]
 76210 0c3a ED3B0020 		ld.ub	r11, r6[32]
 76211 0c3e A58B     		lsr     r11, 4
 76212 0c40 205B     		sub     r11, 5
 76213 0c42 A36B     		lsl     r11, 2
 76214 0c44 163A     		cp.w	r10, r11
 76215 0c46 CBD5     		brlt .L152
 76216              	.L148:
1650:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_ESTABLISHED;
 76217              		.loc 1 1650 0
 76218 0c48 FEF705D8 		lda.w	r7, uip_connr
 76219 0c4c 6E08     		ld.w	r8, r7[0]
 76220 0c4e 3039     		mov	r9, 3
 76221 0c50 F1690019 		st.b	r8[25], r9
1651:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[0] = BUF->seqno[0];
 76222              		.loc 1 1651 0
 76223 0c54 6E09     		ld.w	r9, r7[0]
 76224 0c56 FEF805BE 		lda.w	r8, uip_buf
 76225 0c5a 700A     		ld.w	r10, r8[0]
 76226 0c5c F53A0026 		ld.ub	r10, r10[38]
 76227 0c60 F36A0008 		st.b	r9[8], r10
1652:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[1] = BUF->seqno[1];
 76228              		.loc 1 1652 0
 76229 0c64 6E09     		ld.w	r9, r7[0]
 76230 0c66 700A     		ld.w	r10, r8[0]
 76231 0c68 F53A0027 		ld.ub	r10, r10[39]
 76232 0c6c F36A0009 		st.b	r9[9], r10
1653:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[2] = BUF->seqno[2];
 76233              		.loc 1 1653 0
 76234 0c70 6E09     		ld.w	r9, r7[0]
 76235 0c72 700A     		ld.w	r10, r8[0]
 76236 0c74 F53A0028 		ld.ub	r10, r10[40]
 76237 0c78 F36A000A 		st.b	r9[10], r10
1654:uIP/uip/uip.c **** 				uip_connr->rcv_nxt[3] = BUF->seqno[3];
 76238              		.loc 1 1654 0
 76239 0c7c 6E09     		ld.w	r9, r7[0]
 76240 0c7e 7008     		ld.w	r8, r8[0]
 76241 0c80 F1380029 		ld.ub	r8, r8[41]
 76242 0c84 F368000B 		st.b	r9[11], r8
1655:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1);
 76243              		.loc 1 1655 0
 76244 0c88 301C     		mov	r12, 1
 76245 0c8a F01F0175 		call	uip_add_rcv_nxt
1656:uIP/uip/uip.c **** 				uip_flags = UIP_CONNECTED | UIP_NEWDATA;
 76246              		.loc 1 1656 0
 76247 0c8e 3429     		mov	r9, 66
 76248 0c90 FEF80594 		lda.w	r8, uip_flags
 76249 0c94 B089     		st.b	r8[0], r9
1657:uIP/uip/uip.c **** 				uip_connr->len = 0;
 76250              		.loc 1 1657 0
 76251 0c96 6E09     		ld.w	r9, r7[0]
 76252 0c98 3008     		mov	r8, 0
 76253 0c9a F3580010 		st.h	r9[16], r8
1658:uIP/uip/uip.c **** 				uip_len = 0;
 76254              		.loc 1 1658 0
 76255 0c9e FEF90592 		lda.w	r9, uip_len
 76256 0ca2 B208     		st.h	r9[0], r8
1659:uIP/uip/uip.c **** 				uip_slen = 0;
 76257              		.loc 1 1659 0
 76258 0ca4 FEF90590 		lda.w	r9, uip_slen
 76259 0ca8 B208     		st.h	r9[0], r8
1661:uIP/uip/uip.c **** 				UIP_APPCALL();
 76260              		.loc 1 1661 0
 76261 0caa F01F0160 		call	NetSDR_appcall
1662:uIP/uip/uip.c **** 				goto appsend;
 76262              		.loc 1 1662 0
 76263 0cae CB88     		rjmp    .L81
 76264              	.L147:
1665:uIP/uip/uip.c **** 			uip_flags = UIP_ABORT;
 76265              		.loc 1 1665 0
 76266 0cb0 3209     		mov	r9, 32
 76267 0cb2 FEF80572 		lda.w	r8, uip_flags
 76268 0cb6 B089     		st.b	r8[0], r9
1667:uIP/uip/uip.c **** 			UIP_APPCALL();
 76269              		.loc 1 1667 0
 76270 0cb8 F01F015C 		call	NetSDR_appcall
1669:uIP/uip/uip.c **** 			uip_conn->tcpstateflags = UIP_CLOSED;
 76271              		.loc 1 1669 0
 76272 0cbc FEF80580 		lda.w	r8, uip_conn
 76273 0cc0 7008     		ld.w	r8, r8[0]
 76274 0cc2 3009     		mov	r9, 0
 76275 0cc4 F1690019 		st.b	r8[25], r9
1670:uIP/uip/uip.c **** 			goto reset;
 76276              		.loc 1 1670 0
 76277 0cc8 FE9FFC70 		bral    .L117
 76278              	.L140:
1685:uIP/uip/uip.c **** 			if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED))
 76279              		.loc 1 1685 0
 76280 0ccc FEF90548 		lda.w	r9, uip_buf
 76281 0cd0 7209     		ld.w	r9, r9[0]
 76282 0cd2 2F29     		sub     r9, -14
 76283 0cd4 F33A0021 		ld.ub	r10, r9[33]
 76284 0cd8 F9DAC001 		bfextu	r12, r10, 0, 1
 76285 0cdc C390     		breq .L153
 76286 0cde E21B0010 		andl	r11, 16, COH
 76287 0ce2 C361     		brne .L153
1687:uIP/uip/uip.c **** 				if(uip_outstanding(uip_connr))
 76288              		.loc 1 1687 0
 76289 0ce4 F1090010 		ld.sh	r9, r8[16]
 76290 0ce8 3008     		mov	r8, 0
 76291 0cea F0091900 		cp.h	r9, r8
 76292 0cee E081028C 		brne .L80
1691:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1 + uip_len);
 76293              		.loc 1 1691 0
 76294 0cf2 FEF7053E 		lda.w	r7, uip_len
 76295 0cf6 8E0C     		ld.sh	r12, r7[0]
 76296 0cf8 2FFC     		sub     r12, -1
 76297 0cfa 5C7C     		castu.h	r12
 76298 0cfc F01F0158 		call	uip_add_rcv_nxt
1692:uIP/uip/uip.c **** 				uip_flags |= UIP_CLOSE;
 76299              		.loc 1 1692 0
 76300 0d00 FEF80524 		lda.w	r8, uip_flags
 76301 0d04 1189     		ld.ub	r9, r8[0]
 76302 0d06 A5A9     		sbr	r9, 4
 76303 0d08 B089     		st.b	r8[0], r9
1693:uIP/uip/uip.c **** 				if(uip_len > 0)
 76304              		.loc 1 1693 0
 76305 0d0a 8E09     		ld.sh	r9, r7[0]
 76306 0d0c 3008     		mov	r8, 0
 76307 0d0e F0091900 		cp.h	r9, r8
 76308 0d12 C060     		breq .L154
1695:uIP/uip/uip.c **** 					uip_flags |= UIP_NEWDATA;
 76309              		.loc 1 1695 0
 76310 0d14 FEF80510 		lda.w	r8, uip_flags
 76311 0d18 1189     		ld.ub	r9, r8[0]
 76312 0d1a A1B9     		sbr	r9, 1
 76313 0d1c B089     		st.b	r8[0], r9
 76314              	.L154:
1698:uIP/uip/uip.c **** 				UIP_APPCALL();
 76315              		.loc 1 1698 0
 76316 0d1e F01F0143 		call	NetSDR_appcall
1699:uIP/uip/uip.c **** 				uip_connr->len = 1;
 76317              		.loc 1 1699 0
 76318 0d22 FEF804FE 		lda.w	r8, uip_connr
 76319 0d26 7009     		ld.w	r9, r8[0]
 76320 0d28 301A     		mov	r10, 1
 76321 0d2a F35A0010 		st.h	r9[16], r10
1700:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_LAST_ACK;
 76322              		.loc 1 1700 0
 76323 0d2e 7009     		ld.w	r9, r8[0]
 76324 0d30 308A     		mov	r10, 8
 76325 0d32 F36A0019 		st.b	r9[25], r10
1701:uIP/uip/uip.c **** 				uip_connr->nrtx = 0;
 76326              		.loc 1 1701 0
 76327 0d36 7008     		ld.w	r8, r8[0]
 76328 0d38 3009     		mov	r9, 0
 76329 0d3a F169001B 		st.b	r8[27], r9
 76330              	.L94:
1705:uIP/uip/uip.c **** 				BUF->flags = TCP_FIN | TCP_ACK;
 76331              		.loc 1 1705 0
 76332 0d3e FEF804D6 		lda.w	r8, uip_buf
 76333 0d42 7008     		ld.w	r8, r8[0]
 76334 0d44 3119     		mov	r9, 17
 76335 0d46 F169002F 		st.b	r8[47], r9
1706:uIP/uip/uip.c **** 				goto tcp_send_nodata;
 76336              		.loc 1 1706 0
 76337 0d4a E08F01A2 		bral    .L88
 76338              	.L153:
1711:uIP/uip/uip.c **** 			if((BUF->flags & TCP_URG) != 0)
 76339              		.loc 1 1711 0
 76340 0d4e E21A0020 		andl	r10, 32, COH
 76341 0d52 C1C0     		breq .L155
1729:uIP/uip/uip.c **** 				uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
 76342              		.loc 1 1729 0
 76343 0d54 FEF804C4 		lda.w	r8, uip_appdata
 76344 0d58 F33A0026 		ld.ub	r10, r9[38]
 76345 0d5c F3390027 		ld.ub	r9, r9[39]
 76346 0d60 F3EA1089 		or	r9, r9, r10 << 8
 76347 0d64 700A     		ld.w	r10, r8[0]
 76348 0d66 F4090009 		add     r9, r10, r9
 76349 0d6a 9109     		st.w	r8[0], r9
1730:uIP/uip/uip.c **** 				uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
 76350              		.loc 1 1730 0
 76351 0d6c FEF804A8 		lda.w	r8, uip_buf
 76352 0d70 7009     		ld.w	r9, r8[0]
 76353 0d72 2F29     		sub     r9, -14
 76354 0d74 FEF804BC 		lda.w	r8, uip_len
 76355 0d78 F33A0026 		ld.ub	r10, r9[38]
 76356 0d7c F3390027 		ld.ub	r9, r9[39]
 76357 0d80 F3EA1089 		or	r9, r9, r10 << 8
 76358 0d84 900A     		ld.sh	r10, r8[0]
 76359 0d86 121A     		sub     r10, r9
 76360 0d88 B00A     		st.h	r8[0], r10
 76361              	.L155:
1739:uIP/uip/uip.c **** 			if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED))
 76362              		.loc 1 1739 0
 76363 0d8a FEF804A6 		lda.w	r8, uip_len
 76364 0d8e 9009     		ld.sh	r9, r8[0]
 76365 0d90 3008     		mov	r8, 0
 76366 0d92 F0091900 		cp.h	r9, r8
 76367 0d96 C130     		breq .L156
 76368 0d98 FEF80488 		lda.w	r8, uip_connr
 76369 0d9c 7008     		ld.w	r8, r8[0]
 76370 0d9e F1380019 		ld.ub	r8, r8[25]
 76371 0da2 E2180010 		andl	r8, 16, COH
 76372 0da6 C0B1     		brne .L156
1741:uIP/uip/uip.c **** 				uip_flags |= UIP_NEWDATA;
 76373              		.loc 1 1741 0
 76374 0da8 FEF8047C 		lda.w	r8, uip_flags
 76375 0dac 1189     		ld.ub	r9, r8[0]
 76376 0dae A1B9     		sbr	r9, 1
 76377 0db0 B089     		st.b	r8[0], r9
1742:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
 76378              		.loc 1 1742 0
 76379 0db2 FEF8047E 		lda.w	r8, uip_len
 76380 0db6 908C     		ld.uh	r12, r8[0]
 76381 0db8 F01F0129 		call	uip_add_rcv_nxt
 76382              	.L156:
1757:uIP/uip/uip.c **** 			tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
 76383              		.loc 1 1757 0
 76384 0dbc FEF80458 		lda.w	r8, uip_buf
 76385 0dc0 7008     		ld.w	r8, r8[0]
 76386 0dc2 2F28     		sub     r8, -14
 76387 0dc4 F1390022 		ld.ub	r9, r8[34]
 76388 0dc8 A969     		lsl     r9, 8
 76389 0dca F1380023 		ld.ub	r8, r8[35]
 76390 0dce 1208     		add     r8, r9
 76391 0dd0 5C88     		casts.h	r8
 76392 0dd2 FEF9045A 		lda.w	r9, .LANCHOR0
 76393 0dd6 B268     		st.h	r9[12], r8
1758:uIP/uip/uip.c **** 			if(tmp16 > uip_connr->initialmss || tmp16 == 0)
 76394              		.loc 1 1758 0
 76395 0dd8 FEF90448 		lda.w	r9, uip_connr
 76396 0ddc 7209     		ld.w	r9, r9[0]
 76397 0dde F3090014 		ld.sh	r9, r9[20]
 76398 0de2 F2081900 		cp.h	r8, r9
 76399 0de6 E08B0004 		brhi .L157
 76400 0dea 5808     		cp.w	r8, 0
 76401 0dec C041     		brne .L158
 76402              	.L157:
1760:uIP/uip/uip.c **** 				tmp16 = uip_connr->initialmss;
 76403              		.loc 1 1760 0
 76404 0dee FEF8043E 		lda.w	r8, .LANCHOR0
 76405 0df2 B069     		st.h	r8[12], r9
 76406              	.L158:
1762:uIP/uip/uip.c **** 			uip_connr->mss = tmp16;
 76407              		.loc 1 1762 0
 76408 0df4 FEF8042C 		lda.w	r8, uip_connr
 76409 0df8 7008     		ld.w	r8, r8[0]
 76410 0dfa FEF90432 		lda.w	r9, .LANCHOR0
 76411 0dfe 9269     		ld.sh	r9, r9[12]
 76412 0e00 F1590012 		st.h	r8[18], r9
1780:uIP/uip/uip.c **** 			if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA))
 76413              		.loc 1 1780 0
 76414 0e04 FEF80420 		lda.w	r8, uip_flags
 76415 0e08 1188     		ld.ub	r8, r8[0]
 76416 0e0a F1D8C002 		bfextu	r8, r8, 0, 2
 76417 0e0e E08001FC 		breq .L80
1782:uIP/uip/uip.c **** 				uip_slen = 0;
 76418              		.loc 1 1782 0
 76419 0e12 3009     		mov	r9, 0
 76420 0e14 FEF80420 		lda.w	r8, uip_slen
 76421 0e18 B009     		st.h	r8[0], r9
1784:uIP/uip/uip.c **** 				UIP_APPCALL();
 76422              		.loc 1 1784 0
 76423 0e1a F01F0104 		call	NetSDR_appcall
 76424              	.L81:
1790:uIP/uip/uip.c **** 				if(uip_flags & UIP_ABORT)
 76425              		.loc 1 1790 0
 76426 0e1e FEF80406 		lda.w	r8, uip_flags
 76427 0e22 1188     		ld.ub	r8, r8[0]
 76428 0e24 E2180020 		andl	r8, 32, COH
 76429 0e28 C110     		breq .L159
1792:uIP/uip/uip.c **** 					uip_slen = 0;
 76430              		.loc 1 1792 0
 76431 0e2a 3008     		mov	r8, 0
 76432 0e2c FEF90408 		lda.w	r9, uip_slen
 76433 0e30 B208     		st.h	r9[0], r8
1793:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_CLOSED;
 76434              		.loc 1 1793 0
 76435 0e32 FEF903EE 		lda.w	r9, uip_connr
 76436 0e36 7209     		ld.w	r9, r9[0]
 76437 0e38 F3680019 		st.b	r9[25], r8
1794:uIP/uip/uip.c **** 					BUF->flags = TCP_RST | TCP_ACK;
 76438              		.loc 1 1794 0
 76439 0e3c FEF803D8 		lda.w	r8, uip_buf
 76440 0e40 7008     		ld.w	r8, r8[0]
 76441 0e42 3149     		mov	r9, 20
 76442 0e44 F169002F 		st.b	r8[47], r9
1795:uIP/uip/uip.c **** 					goto tcp_send_nodata;
 76443              		.loc 1 1795 0
 76444 0e48 C239     		rjmp    .L88
 76445              	.L159:
1798:uIP/uip/uip.c **** 				if(uip_flags & UIP_CLOSE)
 76446              		.loc 1 1798 0
 76447 0e4a FEF803DA 		lda.w	r8, uip_flags
 76448 0e4e 1188     		ld.ub	r8, r8[0]
 76449 0e50 E2180010 		andl	r8, 16, COH
 76450 0e54 C190     		breq .L160
1800:uIP/uip/uip.c **** 					uip_slen = 0;
 76451              		.loc 1 1800 0
 76452 0e56 3009     		mov	r9, 0
 76453 0e58 FEF803DC 		lda.w	r8, uip_slen
 76454 0e5c B009     		st.h	r8[0], r9
1801:uIP/uip/uip.c **** 					uip_connr->len = 1;
 76455              		.loc 1 1801 0
 76456 0e5e FEF803C2 		lda.w	r8, uip_connr
 76457 0e62 700A     		ld.w	r10, r8[0]
 76458 0e64 301B     		mov	r11, 1
 76459 0e66 F55B0010 		st.h	r10[16], r11
1802:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
 76460              		.loc 1 1802 0
 76461 0e6a 700A     		ld.w	r10, r8[0]
 76462 0e6c 304B     		mov	r11, 4
 76463 0e6e F56B0019 		st.b	r10[25], r11
1803:uIP/uip/uip.c **** 					uip_connr->nrtx = 0;
 76464              		.loc 1 1803 0
 76465 0e72 7008     		ld.w	r8, r8[0]
 76466 0e74 F169001B 		st.b	r8[27], r9
1804:uIP/uip/uip.c **** 					BUF->flags = TCP_FIN | TCP_ACK;
 76467              		.loc 1 1804 0
 76468 0e78 FEF8039C 		lda.w	r8, uip_buf
 76469 0e7c 7008     		ld.w	r8, r8[0]
 76470 0e7e 3119     		mov	r9, 17
 76471 0e80 F169002F 		st.b	r8[47], r9
1805:uIP/uip/uip.c **** 					goto tcp_send_nodata;
 76472              		.loc 1 1805 0
 76473 0e84 C059     		rjmp    .L88
 76474              	.L160:
1809:uIP/uip/uip.c **** 				if(uip_slen > 0)
 76475              		.loc 1 1809 0
 76476 0e86 FEF803AE 		lda.w	r8, uip_slen
 76477 0e8a 9009     		ld.sh	r9, r8[0]
 76478 0e8c 3008     		mov	r8, 0
 76479 0e8e F0091900 		cp.h	r9, r8
 76480 0e92 C2C0     		breq .L161
1814:uIP/uip/uip.c **** 					if((uip_flags & UIP_ACKDATA) != 0)
 76481              		.loc 1 1814 0
 76482 0e94 FEF80390 		lda.w	r8, uip_flags
 76483 0e98 1188     		ld.ub	r8, r8[0]
 76484 0e9a F1D8C001 		bfextu	r8, r8, 0, 1
 76485 0e9e C070     		breq .L162
1816:uIP/uip/uip.c **** 						uip_connr->len = 0;
 76486              		.loc 1 1816 0
 76487 0ea0 FEF80380 		lda.w	r8, uip_connr
 76488 0ea4 7008     		ld.w	r8, r8[0]
 76489 0ea6 3009     		mov	r9, 0
 76490 0ea8 F1590010 		st.h	r8[16], r9
 76491              	.L162:
1822:uIP/uip/uip.c **** 					if(uip_connr->len == 0)
 76492              		.loc 1 1822 0
 76493 0eac FEF80374 		lda.w	r8, uip_connr
 76494 0eb0 7009     		ld.w	r9, r8[0]
 76495 0eb2 F3080010 		ld.sh	r8, r9[16]
 76496 0eb6 5808     		cp.w	r8, 0
 76497 0eb8 C161     		brne .L163
1828:uIP/uip/uip.c **** 						if(uip_slen > uip_connr->mss)
 76498              		.loc 1 1828 0
 76499 0eba F3080012 		ld.sh	r8, r9[18]
 76500 0ebe FEF90376 		lda.w	r9, uip_slen
 76501 0ec2 9209     		ld.sh	r9, r9[0]
 76502 0ec4 F0091900 		cp.h	r9, r8
 76503 0ec8 E0880005 		brls .L164
1830:uIP/uip/uip.c **** 							uip_slen = uip_connr->mss;
 76504              		.loc 1 1830 0
 76505 0ecc FEF90368 		lda.w	r9, uip_slen
 76506 0ed0 B208     		st.h	r9[0], r8
 76507              	.L164:
1835:uIP/uip/uip.c **** 						uip_connr->len = uip_slen;
 76508              		.loc 1 1835 0
 76509 0ed2 FEF8034E 		lda.w	r8, uip_connr
 76510 0ed6 7008     		ld.w	r8, r8[0]
 76511 0ed8 FEF9035C 		lda.w	r9, uip_slen
 76512 0edc 9209     		ld.sh	r9, r9[0]
 76513 0ede F1590010 		st.h	r8[16], r9
 76514 0ee2 C048     		rjmp    .L161
 76515              	.L163:
1843:uIP/uip/uip.c **** 						uip_slen = uip_connr->len;
 76516              		.loc 1 1843 0
 76517 0ee4 FEF90350 		lda.w	r9, uip_slen
 76518 0ee8 B208     		st.h	r9[0], r8
 76519              	.L161:
1846:uIP/uip/uip.c **** 				uip_connr->nrtx = 0;
 76520              		.loc 1 1846 0
 76521 0eea FEF80336 		lda.w	r8, uip_connr
 76522 0eee 7008     		ld.w	r8, r8[0]
 76523 0ef0 3009     		mov	r9, 0
 76524 0ef2 F169001B 		st.b	r8[27], r9
 76525              	.L97:
1851:uIP/uip/uip.c **** 				uip_appdata = uip_sappdata;
 76526              		.loc 1 1851 0
 76527 0ef6 FEF80326 		lda.w	r8, uip_sappdata
 76528 0efa 7009     		ld.w	r9, r8[0]
 76529 0efc FEF8031C 		lda.w	r8, uip_appdata
 76530 0f00 9109     		st.w	r8[0], r9
1855:uIP/uip/uip.c **** 				if(uip_slen > 0 && uip_connr->len > 0)
 76531              		.loc 1 1855 0
 76532 0f02 FEF80332 		lda.w	r8, uip_slen
 76533 0f06 9009     		ld.sh	r9, r8[0]
 76534 0f08 3008     		mov	r8, 0
 76535 0f0a F0091900 		cp.h	r9, r8
 76536 0f0e C130     		breq .L165
 76537 0f10 FEF80310 		lda.w	r8, uip_connr
 76538 0f14 7008     		ld.w	r8, r8[0]
 76539 0f16 F1080010 		ld.sh	r8, r8[16]
 76540 0f1a 5808     		cp.w	r8, 0
 76541 0f1c C0C0     		breq .L165
1858:uIP/uip/uip.c **** 					uip_len = uip_connr->len + UIP_TCPIP_HLEN;
 76542              		.loc 1 1858 0
 76543 0f1e 2D88     		sub     r8, -40
 76544 0f20 FEF90310 		lda.w	r9, uip_len
 76545 0f24 B208     		st.h	r9[0], r8
1860:uIP/uip/uip.c **** 					BUF->flags = TCP_ACK | TCP_PSH;
 76546              		.loc 1 1860 0
 76547 0f26 FEF802EE 		lda.w	r8, uip_buf
 76548 0f2a 7008     		ld.w	r8, r8[0]
 76549 0f2c 3189     		mov	r9, 24
 76550 0f2e F169002F 		st.b	r8[47], r9
1862:uIP/uip/uip.c **** 					goto tcp_send_noopts;
 76551              		.loc 1 1862 0
 76552 0f32 CB18     		rjmp    .L166
 76553              	.L165:
1866:uIP/uip/uip.c **** 				if(uip_flags & UIP_NEWDATA)
 76554              		.loc 1 1866 0
 76555 0f34 FEF802F0 		lda.w	r8, uip_flags
 76556 0f38 1188     		ld.ub	r8, r8[0]
 76557 0f3a E2180002 		andl	r8, 2, COH
 76558 0f3e E0800164 		breq .L80
1868:uIP/uip/uip.c **** 					uip_len = UIP_TCPIP_HLEN;
 76559              		.loc 1 1868 0
 76560 0f42 3289     		mov	r9, 40
 76561 0f44 FEF802EC 		lda.w	r8, uip_len
 76562 0f48 B009     		st.h	r8[0], r9
1869:uIP/uip/uip.c **** 					BUF->flags = TCP_ACK;
 76563              		.loc 1 1869 0
 76564 0f4a FEF802CA 		lda.w	r8, uip_buf
 76565 0f4e 7008     		ld.w	r8, r8[0]
 76566 0f50 3109     		mov	r9, 16
 76567 0f52 F169002F 		st.b	r8[47], r9
1870:uIP/uip/uip.c **** 					goto tcp_send_noopts;
 76568              		.loc 1 1870 0
 76569 0f56 C9F8     		rjmp    .L166
 76570              	.L144:
1878:uIP/uip/uip.c **** 			if(uip_flags & UIP_ACKDATA)
 76571              		.loc 1 1878 0
 76572 0f58 FEF902CC 		lda.w	r9, uip_flags
 76573 0f5c 1389     		ld.ub	r9, r9[0]
 76574 0f5e F3D9C001 		bfextu	r9, r9, 0, 1
 76575 0f62 E0800152 		breq .L80
1880:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_CLOSED;
 76576              		.loc 1 1880 0
 76577 0f66 3009     		mov	r9, 0
 76578 0f68 F1690019 		st.b	r8[25], r9
1881:uIP/uip/uip.c **** 				uip_flags = UIP_CLOSE;
 76579              		.loc 1 1881 0
 76580 0f6c 3109     		mov	r9, 16
 76581 0f6e FEF802B6 		lda.w	r8, uip_flags
 76582 0f72 B089     		st.b	r8[0], r9
1883:uIP/uip/uip.c **** 				UIP_APPCALL();
 76583              		.loc 1 1883 0
 76584 0f74 F01F00AD 		call	NetSDR_appcall
 76585 0f78 C479     		rjmp    .L80
 76586              	.L141:
1891:uIP/uip/uip.c **** 			if(uip_len > 0)
 76587              		.loc 1 1891 0
 76588 0f7a FEF802B6 		lda.w	r8, uip_len
 76589 0f7e 900C     		ld.sh	r12, r8[0]
 76590 0f80 580C     		cp.w	r12, 0
 76591 0f82 C040     		breq .L167
1893:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
 76592              		.loc 1 1893 0
 76593 0f84 5C7C     		castu.h	r12
 76594 0f86 F01F00B6 		call	uip_add_rcv_nxt
 76595              	.L167:
1895:uIP/uip/uip.c **** 			if(BUF->flags & TCP_FIN)
 76596              		.loc 1 1895 0
 76597 0f8a FEF8028A 		lda.w	r8, uip_buf
 76598 0f8e 7008     		ld.w	r8, r8[0]
 76599 0f90 F138002F 		ld.ub	r8, r8[47]
 76600 0f94 F1D8C001 		bfextu	r8, r8, 0, 1
 76601 0f98 C260     		breq .L168
1897:uIP/uip/uip.c **** 				if(uip_flags & UIP_ACKDATA)
 76602              		.loc 1 1897 0
 76603 0f9a FEF8028A 		lda.w	r8, uip_flags
 76604 0f9e 1188     		ld.ub	r8, r8[0]
 76605 0fa0 F1D8C001 		bfextu	r8, r8, 0, 1
 76606 0fa4 C100     		breq .L169
1899:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_TIME_WAIT;
 76607              		.loc 1 1899 0
 76608 0fa6 FEF8027A 		lda.w	r8, uip_connr
 76609 0faa 7009     		ld.w	r9, r8[0]
 76610 0fac 307A     		mov	r10, 7
 76611 0fae F36A0019 		st.b	r9[25], r10
1900:uIP/uip/uip.c **** 					uip_connr->timer = 0;
 76612              		.loc 1 1900 0
 76613 0fb2 7009     		ld.w	r9, r8[0]
 76614 0fb4 300A     		mov	r10, 0
 76615 0fb6 F36A001A 		st.b	r9[26], r10
1901:uIP/uip/uip.c **** 					uip_connr->len = 0;
 76616              		.loc 1 1901 0
 76617 0fba 7008     		ld.w	r8, r8[0]
 76618 0fbc 3009     		mov	r9, 0
 76619 0fbe F1590010 		st.h	r8[16], r9
 76620 0fc2 C078     		rjmp    .L170
 76621              	.L169:
1905:uIP/uip/uip.c **** 					uip_connr->tcpstateflags = UIP_CLOSING;
 76622              		.loc 1 1905 0
 76623 0fc4 FEF8025C 		lda.w	r8, uip_connr
 76624 0fc8 7008     		ld.w	r8, r8[0]
 76625 0fca 3069     		mov	r9, 6
 76626 0fcc F1690019 		st.b	r8[25], r9
 76627              	.L170:
1907:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1);
 76628              		.loc 1 1907 0
 76629 0fd0 301C     		mov	r12, 1
 76630 0fd2 F01F00A3 		call	uip_add_rcv_nxt
1908:uIP/uip/uip.c **** 				uip_flags = UIP_CLOSE;
 76631              		.loc 1 1908 0
 76632 0fd6 3109     		mov	r9, 16
 76633 0fd8 FEF8024C 		lda.w	r8, uip_flags
 76634 0fdc B089     		st.b	r8[0], r9
1910:uIP/uip/uip.c **** 				UIP_APPCALL();
 76635              		.loc 1 1910 0
 76636 0fde F01F0093 		call	NetSDR_appcall
1911:uIP/uip/uip.c **** 				goto tcp_send_ack;
 76637              		.loc 1 1911 0
 76638 0fe2 C518     		rjmp    .L135
 76639              	.L168:
1913:uIP/uip/uip.c **** 			else if(uip_flags & UIP_ACKDATA)
 76640              		.loc 1 1913 0
 76641 0fe4 FEF80240 		lda.w	r8, uip_flags
 76642 0fe8 1188     		ld.ub	r8, r8[0]
 76643 0fea F1D8C001 		bfextu	r8, r8, 0, 1
 76644 0fee C0C0     		breq .L171
1915:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
 76645              		.loc 1 1915 0
 76646 0ff0 FEF80230 		lda.w	r8, uip_connr
 76647 0ff4 7009     		ld.w	r9, r8[0]
 76648 0ff6 305A     		mov	r10, 5
 76649 0ff8 F36A0019 		st.b	r9[25], r10
1916:uIP/uip/uip.c **** 				uip_connr->len = 0;
 76650              		.loc 1 1916 0
 76651 0ffc 7008     		ld.w	r8, r8[0]
 76652 0ffe 3009     		mov	r9, 0
 76653 1000 F1590010 		st.h	r8[16], r9
1917:uIP/uip/uip.c **** 				goto drop;
 76654              		.loc 1 1917 0
 76655 1004 C019     		rjmp    .L80
 76656              	.L171:
1919:uIP/uip/uip.c **** 			if(uip_len > 0)
 76657              		.loc 1 1919 0
 76658 1006 FEF8022A 		lda.w	r8, uip_len
 76659 100a 9009     		ld.sh	r9, r8[0]
 76660 100c 3008     		mov	r8, 0
 76661 100e F0091900 		cp.h	r9, r8
 76662 1012 C391     		brne .L135
 76663 1014 CF98     		rjmp    .L80
 76664              	.L142:
1926:uIP/uip/uip.c **** 			if(uip_len > 0)
 76665              		.loc 1 1926 0
 76666 1016 FEF8021A 		lda.w	r8, uip_len
 76667 101a 900C     		ld.sh	r12, r8[0]
 76668 101c 580C     		cp.w	r12, 0
 76669 101e C040     		breq .L172
1928:uIP/uip/uip.c **** 				uip_add_rcv_nxt(uip_len);
 76670              		.loc 1 1928 0
 76671 1020 5C7C     		castu.h	r12
 76672 1022 F01F008F 		call	uip_add_rcv_nxt
 76673              	.L172:
1930:uIP/uip/uip.c **** 			if(BUF->flags & TCP_FIN)
 76674              		.loc 1 1930 0
 76675 1026 4FC8     		lda.w	r8, uip_buf
 76676 1028 7008     		ld.w	r8, r8[0]
 76677 102a F138002F 		ld.ub	r8, r8[47]
 76678 102e F1D8C001 		bfextu	r8, r8, 0, 1
 76679 1032 C130     		breq .L173
1932:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_TIME_WAIT;
 76680              		.loc 1 1932 0
 76681 1034 4FB8     		lda.w	r8, uip_connr
 76682 1036 7009     		ld.w	r9, r8[0]
 76683 1038 307A     		mov	r10, 7
 76684 103a F36A0019 		st.b	r9[25], r10
1933:uIP/uip/uip.c **** 				uip_connr->timer = 0;
 76685              		.loc 1 1933 0
 76686 103e 7008     		ld.w	r8, r8[0]
 76687 1040 3009     		mov	r9, 0
 76688 1042 F169001A 		st.b	r8[26], r9
1934:uIP/uip/uip.c **** 				uip_add_rcv_nxt(1);
 76689              		.loc 1 1934 0
 76690 1046 301C     		mov	r12, 1
 76691 1048 F01F0085 		call	uip_add_rcv_nxt
1935:uIP/uip/uip.c **** 				uip_flags = UIP_CLOSE;
 76692              		.loc 1 1935 0
 76693 104c 3109     		mov	r9, 16
 76694 104e 4F68     		lda.w	r8, uip_flags
 76695 1050 B089     		st.b	r8[0], r9
1937:uIP/uip/uip.c **** 				UIP_APPCALL();
 76696              		.loc 1 1937 0
 76697 1052 F01F0076 		call	NetSDR_appcall
1938:uIP/uip/uip.c **** 				goto tcp_send_ack;
 76698              		.loc 1 1938 0
 76699 1056 C178     		rjmp    .L135
 76700              	.L173:
1940:uIP/uip/uip.c **** 			if(uip_len > 0)
 76701              		.loc 1 1940 0
 76702 1058 4F68     		lda.w	r8, uip_len
 76703 105a 9009     		ld.sh	r9, r8[0]
 76704 105c 3008     		mov	r8, 0
 76705 105e F0091900 		cp.h	r9, r8
 76706 1062 C111     		brne .L135
 76707 1064 CD18     		rjmp    .L80
 76708              	.L143:
1950:uIP/uip/uip.c **** 			if(uip_flags & UIP_ACKDATA)
 76709              		.loc 1 1950 0
 76710 1066 4F09     		lda.w	r9, uip_flags
 76711 1068 1389     		ld.ub	r9, r9[0]
 76712 106a F3D9C001 		bfextu	r9, r9, 0, 1
 76713 106e E08000CC 		breq .L80
1952:uIP/uip/uip.c **** 				uip_connr->tcpstateflags = UIP_TIME_WAIT;
 76714              		.loc 1 1952 0
 76715 1072 3079     		mov	r9, 7
 76716 1074 F1690019 		st.b	r8[25], r9
1953:uIP/uip/uip.c **** 				uip_connr->timer = 0;
 76717              		.loc 1 1953 0
 76718 1078 4EA8     		lda.w	r8, uip_connr
 76719 107a 7008     		ld.w	r8, r8[0]
 76720 107c 3009     		mov	r9, 0
 76721 107e F169001A 		st.b	r8[26], r9
 76722 1082 CC28     		rjmp    .L80
 76723              	.L135:
1964:uIP/uip/uip.c **** 	BUF->flags = TCP_ACK;
 76724              		.loc 1 1964 0
 76725 1084 4E48     		lda.w	r8, uip_buf
 76726 1086 7008     		ld.w	r8, r8[0]
 76727 1088 3109     		mov	r9, 16
 76728 108a F169002F 		st.b	r8[47], r9
 76729              	.L88:
1968:uIP/uip/uip.c **** 	uip_len = UIP_IPTCPH_LEN;
 76730              		.loc 1 1968 0
 76731 108e 3289     		mov	r9, 40
 76732 1090 4E88     		lda.w	r8, uip_len
 76733 1092 B009     		st.h	r8[0], r9
 76734              	.L166:
1972:uIP/uip/uip.c **** 	BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
 76735              		.loc 1 1972 0
 76736 1094 4E08     		lda.w	r8, uip_buf
 76737 1096 7008     		ld.w	r8, r8[0]
 76738 1098 3509     		mov	r9, 80
 76739 109a F169002E 		st.b	r8[46], r9
 76740              	.L130:
1980:uIP/uip/uip.c **** 	BUF->ackno[0] = uip_connr->rcv_nxt[0];
 76741              		.loc 1 1980 0
 76742 109e 4DE8     		lda.w	r8, uip_buf
 76743 10a0 700A     		ld.w	r10, r8[0]
 76744 10a2 4E09     		lda.w	r9, uip_connr
 76745 10a4 720B     		ld.w	r11, r9[0]
 76746 10a6 F73B0008 		ld.ub	r11, r11[8]
 76747 10aa F56B002A 		st.b	r10[42], r11
1981:uIP/uip/uip.c **** 	BUF->ackno[1] = uip_connr->rcv_nxt[1];
 76748              		.loc 1 1981 0
 76749 10ae 700A     		ld.w	r10, r8[0]
 76750 10b0 720B     		ld.w	r11, r9[0]
 76751 10b2 F73B0009 		ld.ub	r11, r11[9]
 76752 10b6 F56B002B 		st.b	r10[43], r11
1982:uIP/uip/uip.c **** 	BUF->ackno[2] = uip_connr->rcv_nxt[2];
 76753              		.loc 1 1982 0
 76754 10ba 700A     		ld.w	r10, r8[0]
 76755 10bc 720B     		ld.w	r11, r9[0]
 76756 10be F73B000A 		ld.ub	r11, r11[10]
 76757 10c2 F56B002C 		st.b	r10[44], r11
1983:uIP/uip/uip.c **** 	BUF->ackno[3] = uip_connr->rcv_nxt[3];
 76758              		.loc 1 1983 0
 76759 10c6 700A     		ld.w	r10, r8[0]
 76760 10c8 720B     		ld.w	r11, r9[0]
 76761 10ca F73B000B 		ld.ub	r11, r11[11]
 76762 10ce F56B002D 		st.b	r10[45], r11
1985:uIP/uip/uip.c **** 	BUF->seqno[0] = uip_connr->snd_nxt[0];
 76763              		.loc 1 1985 0
 76764 10d2 700A     		ld.w	r10, r8[0]
 76765 10d4 720B     		ld.w	r11, r9[0]
 76766 10d6 F73B000C 		ld.ub	r11, r11[12]
 76767 10da F56B0026 		st.b	r10[38], r11
1986:uIP/uip/uip.c **** 	BUF->seqno[1] = uip_connr->snd_nxt[1];
 76768              		.loc 1 1986 0
 76769 10de 700A     		ld.w	r10, r8[0]
 76770 10e0 720B     		ld.w	r11, r9[0]
 76771 10e2 F73B000D 		ld.ub	r11, r11[13]
 76772 10e6 F56B0027 		st.b	r10[39], r11
1987:uIP/uip/uip.c **** 	BUF->seqno[2] = uip_connr->snd_nxt[2];
 76773              		.loc 1 1987 0
 76774 10ea 700A     		ld.w	r10, r8[0]
 76775 10ec 720B     		ld.w	r11, r9[0]
 76776 10ee F73B000E 		ld.ub	r11, r11[14]
 76777 10f2 F56B0028 		st.b	r10[40], r11
1988:uIP/uip/uip.c **** 	BUF->seqno[3] = uip_connr->snd_nxt[3];
 76778              		.loc 1 1988 0
 76779 10f6 700A     		ld.w	r10, r8[0]
 76780 10f8 720B     		ld.w	r11, r9[0]
 76781 10fa F73B000F 		ld.ub	r11, r11[15]
 76782 10fe F56B0029 		st.b	r10[41], r11
1990:uIP/uip/uip.c **** 	BUF->proto = UIP_PROTO_TCP;
 76783              		.loc 1 1990 0
 76784 1102 700A     		ld.w	r10, r8[0]
 76785 1104 306B     		mov	r11, 6
 76786 1106 F56B0017 		st.b	r10[23], r11
1992:uIP/uip/uip.c **** 	BUF->srcport  = uip_connr->lport;
 76787              		.loc 1 1992 0
 76788 110a 700A     		ld.w	r10, r8[0]
 76789 110c 720B     		ld.w	r11, r9[0]
 76790 110e 962B     		ld.sh	r11, r11[4]
 76791 1110 F55B0022 		st.h	r10[34], r11
1993:uIP/uip/uip.c **** 	BUF->destport = uip_connr->rport;
 76792              		.loc 1 1993 0
 76793 1114 700A     		ld.w	r10, r8[0]
 76794 1116 720B     		ld.w	r11, r9[0]
 76795 1118 963B     		ld.sh	r11, r11[6]
 76796 111a F55B0024 		st.h	r10[36], r11
1995:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 76797              		.loc 1 1995 0
 76798 111e 700B     		ld.w	r11, r8[0]
 76799 1120 4C9A     		lda.w	r10, uip_hostaddr
 76800 1122 940C     		ld.sh	r12, r10[0]
 76801 1124 F75C001A 		st.h	r11[26], r12
 76802 1128 700B     		ld.w	r11, r8[0]
 76803 112a 941A     		ld.sh	r10, r10[2]
 76804 112c F75A001C 		st.h	r11[28], r10
1996:uIP/uip/uip.c **** 	uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
 76805              		.loc 1 1996 0
 76806 1130 700A     		ld.w	r10, r8[0]
 76807 1132 720B     		ld.w	r11, r9[0]
 76808 1134 960B     		ld.sh	r11, r11[0]
 76809 1136 F55B001E 		st.h	r10[30], r11
 76810 113a 7008     		ld.w	r8, r8[0]
 76811 113c 720A     		ld.w	r10, r9[0]
 76812 113e 941A     		ld.sh	r10, r10[2]
 76813 1140 F15A0020 		st.h	r8[32], r10
1998:uIP/uip/uip.c **** 	if(uip_connr->tcpstateflags & UIP_STOPPED)
 76814              		.loc 1 1998 0
 76815 1144 7208     		ld.w	r8, r9[0]
 76816 1146 F1380019 		ld.ub	r8, r8[25]
 76817 114a E2180010 		andl	r8, 16, COH
 76818 114e C0A0     		breq .L174
2002:uIP/uip/uip.c **** 		BUF->wnd[0] = BUF->wnd[1] = 0;
 76819              		.loc 1 2002 0
 76820 1150 4B18     		lda.w	r8, uip_buf
 76821 1152 7008     		ld.w	r8, r8[0]
 76822 1154 2F28     		sub     r8, -14
 76823 1156 3009     		mov	r9, 0
 76824 1158 F1690023 		st.b	r8[35], r9
 76825 115c F1690022 		st.b	r8[34], r9
 76826 1160 C0A8     		rjmp    .L120
 76827              	.L174:
2006:uIP/uip/uip.c **** 		BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
 76828              		.loc 1 2006 0
 76829 1162 4AD8     		lda.w	r8, uip_buf
 76830 1164 7009     		ld.w	r9, r8[0]
 76831 1166 306A     		mov	r10, 6
 76832 1168 F36A0030 		st.b	r9[48], r10
2007:uIP/uip/uip.c **** 		BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
 76833              		.loc 1 2007 0
 76834 116c 7008     		ld.w	r8, r8[0]
 76835 116e 30A9     		mov	r9, 10
 76836 1170 F1690031 		st.b	r8[49], r9
 76837              	.L120:
2012:uIP/uip/uip.c **** 	BUF->ttl = UIP_TTL;
 76838              		.loc 1 2012 0
 76839 1174 4A88     		lda.w	r8, uip_buf
 76840 1176 7009     		ld.w	r9, r8[0]
 76841 1178 340A     		mov	r10, 64
 76842 117a F36A0016 		st.b	r9[22], r10
2019:uIP/uip/uip.c **** 	BUF->len[0] = (uip_len >> 8);
 76843              		.loc 1 2019 0
 76844 117e 700A     		ld.w	r10, r8[0]
 76845 1180 4AC9     		lda.w	r9, uip_len
 76846 1182 138B     		ld.ub	r11, r9[0]
 76847 1184 F56B0010 		st.b	r10[16], r11
2020:uIP/uip/uip.c **** 	BUF->len[1] = (uip_len & 0xff);
 76848              		.loc 1 2020 0
 76849 1188 700A     		ld.w	r10, r8[0]
 76850 118a 9209     		ld.sh	r9, r9[0]
 76851 118c F5690011 		st.b	r10[17], r9
2023:uIP/uip/uip.c **** 	BUF->urgp[0] = BUF->urgp[1] = 0;
 76852              		.loc 1 2023 0
 76853 1190 7009     		ld.w	r9, r8[0]
 76854 1192 2F29     		sub     r9, -14
 76855 1194 300A     		mov	r10, 0
 76856 1196 F36A0027 		st.b	r9[39], r10
 76857 119a F36A0026 		st.b	r9[38], r10
2026:uIP/uip/uip.c **** 	BUF->tcpchksum = 0;
 76858              		.loc 1 2026 0
 76859 119e 7009     		ld.w	r9, r8[0]
 76860 11a0 300A     		mov	r10, 0
 76861 11a2 F35A0032 		st.h	r9[50], r10
2027:uIP/uip/uip.c **** 	BUF->tcpchksum = ~(uip_tcpchksum());
 76862              		.loc 1 2027 0
 76863 11a6 7007     		ld.w	r7, r8[0]
 76864 11a8 2F27     		sub     r7, -14
 76865 11aa F01F002A 		call	uip_tcpchksum
 76866 11ae 5CDC     		com	r12
 76867 11b0 EF5C0024 		st.h	r7[36], r12
 76868              	.L112:
2037:uIP/uip/uip.c **** 	BUF->vhl = 0x45;
 76869              		.loc 1 2037 0
 76870 11b4 4988     		lda.w	r8, uip_buf
 76871 11b6 7009     		ld.w	r9, r8[0]
 76872 11b8 345A     		mov	r10, 69
 76873 11ba F36A000E 		st.b	r9[14], r10
2038:uIP/uip/uip.c **** 	BUF->tos = 0;
 76874              		.loc 1 2038 0
 76875 11be 700A     		ld.w	r10, r8[0]
 76876 11c0 3009     		mov	r9, 0
 76877 11c2 F569000F 		st.b	r10[15], r9
2039:uIP/uip/uip.c **** 	BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
 76878              		.loc 1 2039 0
 76879 11c6 700A     		ld.w	r10, r8[0]
 76880 11c8 2F2A     		sub     r10, -14
 76881 11ca B4F9     		st.b	r10[7], r9
 76882 11cc B4E9     		st.b	r10[6], r9
2040:uIP/uip/uip.c **** 	++ipid;
 76883              		.loc 1 2040 0
 76884 11ce 4989     		lda.w	r9, .LANCHOR0
 76885 11d0 920A     		ld.sh	r10, r9[0]
 76886 11d2 2FFA     		sub     r10, -1
 76887 11d4 5C8A     		casts.h	r10
 76888 11d6 B20A     		st.h	r9[0], r10
2041:uIP/uip/uip.c **** 	BUF->ipid[0] = ipid >> 8;
 76889              		.loc 1 2041 0
 76890 11d8 700B     		ld.w	r11, r8[0]
 76891 11da F5DAC108 		bfextu	r10, r10, 8, 8
 76892 11de F76A0012 		st.b	r11[18], r10
2042:uIP/uip/uip.c **** 	BUF->ipid[1] = ipid & 0xff;
 76893              		.loc 1 2042 0
 76894 11e2 700A     		ld.w	r10, r8[0]
 76895 11e4 9209     		ld.sh	r9, r9[0]
 76896 11e6 F5690013 		st.b	r10[19], r9
2044:uIP/uip/uip.c **** 	BUF->ipchksum = 0;
 76897              		.loc 1 2044 0
 76898 11ea 7009     		ld.w	r9, r8[0]
 76899 11ec 300A     		mov	r10, 0
 76900 11ee F35A0018 		st.h	r9[24], r10
2045:uIP/uip/uip.c **** 	BUF->ipchksum = ~(uip_ipchksum());
 76901              		.loc 1 2045 0
 76902 11f2 7007     		ld.w	r7, r8[0]
 76903 11f4 2F27     		sub     r7, -14
 76904 11f6 F01F0015 		call	uip_ipchksum
 76905 11fa 5CDC     		com	r12
 76906 11fc AE5C     		st.h	r7[10], r12
 76907              	.L106:
2056:uIP/uip/uip.c **** 	uip_flags = 0;
 76908              		.loc 1 2056 0
 76909 11fe 3009     		mov	r9, 0
 76910 1200 4898     		lda.w	r8, uip_flags
 76911 1202 B089     		st.b	r8[0], r9
2057:uIP/uip/uip.c **** 	return;
 76912              		.loc 1 2057 0
 76913 1204 D822     		popm	r4-r7, pc
 76914              	.LVL84:
 76915              	.L80:
2061:uIP/uip/uip.c **** 	uip_len = 0;
 76916              		.loc 1 2061 0
 76917 1206 3008     		mov	r8, 0
 76918 1208 48A9     		lda.w	r9, uip_len
 76919 120a B208     		st.h	r9[0], r8
2062:uIP/uip/uip.c **** 	uip_flags = 0;
 76920              		.loc 1 2062 0
 76921 120c 4869     		lda.w	r9, uip_flags
 76922 120e B288     		st.b	r9[0], r8
 76923 1210 D822     		popm	r4-r7, pc
 76924 1212 00000000 		.cpool
 76924      00000000 
 76924      00000000 
 76924      00000000 
 76924      00000000 
 76925              		.align	2
 76926              	.L182:
 76927              	.LFE13:
 76929              		.section	.text.uip_udp_new,"ax",@progbits
 76930              		.align	1
 76931              		.global	uip_udp_new
 76933              	uip_udp_new:
 76934              	.LFB9:
 490:uIP/uip/uip.c **** {
 76935              		.loc 1 490 0
 76936              		# args = 0, frame = 0, pretend = 0
 76937              		# frame_needed = 0, leaf_function = 0
 76938              		# uses_anonymous_args = 0
 76939              	.LVL85:
 76940 0000 EBCD40FC 		stm	--sp, r2, r3, r4, r5, r6, r7, lr
 76941              	.LCFI11:
 76942 0004 1893     		mov	r3, r12
 76943 0006 1692     		mov	r2, r11
 76944              	.L184:
 490:uIP/uip/uip.c **** {
 76945              		.loc 1 490 0
 76946 0008 4AB8     		lda.w	r8, .LANCHOR0
 76947 000a 9017     		ld.sh	r7, r8[2]
 497:uIP/uip/uip.c **** 	if(lastport >= 32000)
 76948              		.loc 1 497 0
 76949 000c E0667CFF 		mov	r6, 31999
 76950 0010 E0641000 		mov	r4, 4096
 504:uIP/uip/uip.c **** 		if(uip_udp_conns[c].lport == htons(lastport))
 76951              		.loc 1 504 0
 76952 0014 4A95     		lda.w	r5, uip_udp_conns
 76953              	.LVL86:
 76954              	.L199:
 495:uIP/uip/uip.c **** 	++lastport;
 76955              		.loc 1 495 0
 76956 0016 2FF7     		sub     r7, -1
 76957 0018 5C87     		casts.h	r7
 497:uIP/uip/uip.c **** 	if(lastport >= 32000)
 76958              		.loc 1 497 0
 76959 001a EE061900 		cp.h	r6, r7
 76960 001e E8071730 		movlo    r7, r4
 504:uIP/uip/uip.c **** 		if(uip_udp_conns[c].lport == htons(lastport))
 76961              		.loc 1 504 0
 76962 0022 0E9C     		mov	r12, r7
 76963 0024 5C7C     		castu.h	r12
 76964 0026 F01F0026 		call	htons
 76965 002a 5C8C     		casts.h	r12
 76966 002c 8A28     		ld.sh	r8, r5[4]
 76967 002e F8081900 		cp.h	r8, r12
 76968 0032 CF20     		breq .L199
 76969 0034 C2C8     		rjmp    .L204
 76970              	.L206:
 497:uIP/uip/uip.c **** 	if(lastport >= 32000)
 76971              		.loc 1 497 0
 76972 0036 4A0B     		lda.w	r11, .LANCHOR0
 76973 0038 B617     		st.h	r11[2], r7
 512:uIP/uip/uip.c **** 	for(c = 0; c < UIP_UDP_CONNS; ++c)
 76974              		.loc 1 512 0
 76975 003a 300C     		mov	r12, 0
 76976 003c B6CC     		st.b	r11[4], r12
 514:uIP/uip/uip.c **** 		if(uip_udp_conns[c].lport == 0)
 76977              		.loc 1 514 0
 76978 003e 5808     		cp.w	r8, 0
 76979 0040 C311     		brne .L201
 76980 0042 C108     		rjmp    .L205
 76981              	.L207:
 76982 0044 302C     		mov	r12, 2
 76983 0046 1899     		mov	r9, r12
 76984              	.L195:
 76985 0048 49B8     		lda.w	r8, .LANCHOR0
 76986 004a B0C9     		st.b	r8[4], r9
 516:uIP/uip/uip.c **** 			conn = &uip_udp_conns[c];
 76987              		.loc 1 516 0
 76988 004c A56C     		lsl     r12, 4
 76989 004e 49B8     		lda.w	r8, uip_udp_conns
 76990 0050 100C     		add     r12, r8
 76991              	.LVL87:
 521:uIP/uip/uip.c **** 	if(conn == 0)
 76992              		.loc 1 521 0
 76993 0052 C091     		brne .L189
 76994 0054 E3CD80FC 		ldm	sp++, r2, r3, r4, r5, r6, r7, pc
 76995              	.LVL88:
 76996              	.L203:
 76997 0058 3039     		mov	r9, 3
 76998 005a 4978     		lda.w	r8, .LANCHOR0
 76999 005c B0C9     		st.b	r8[4], r9
 77000              	.LVL89:
 77001 005e E3CF80FC 		ldm	sp++, r2, r3, r4, r5, r6, r7, pc, r12=0
 77002              	.LVL90:
 77003              	.L205:
 77004 0062 496C     		lda.w	r12, uip_udp_conns
 77005              	.LVL91:
 77006              	.L189:
 526:uIP/uip/uip.c **** 	conn->lport = HTONS(lastport);
 77007              		.loc 1 526 0
 77008 0064 B827     		st.h	r12[4], r7
 527:uIP/uip/uip.c **** 	conn->rport = rport;
 77009              		.loc 1 527 0
 77010 0066 B832     		st.h	r12[6], r2
 530:uIP/uip/uip.c **** 		memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
 77011              		.loc 1 530 0
 77012 0068 5803     			cp.w	r3, 0
 77013 006a F9B80000 	 moveq	r8, 0
 77014 006e F9F80A00 		 st.weq	r12[0], r8
 534:uIP/uip/uip.c **** 		uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 77015              		.loc 1 534 0
 77016 0072 E7F81200 		 ld.shne	r8, r3[0]
 77017 0076 F9F81C00 		 st.hne	r12[0], r8
 77018 007a E7F81201 		 ld.shne	r8, r3[2]
 77019 007e F9F81C01 		 st.hne	r12[2], r8
 536:uIP/uip/uip.c **** 	conn->ttl = UIP_TTL;
 77020              		.loc 1 536 0
 77021 0082 3408     		mov	r8, 64
 77022 0084 F9680008 		st.b	r12[8], r8
 77023              	.LVL92:
 539:uIP/uip/uip.c **** }
 77024              		.loc 1 539 0
 77025 0088 E3CD80FC 		ldm	sp++, r2, r3, r4, r5, r6, r7, pc
 77026              	.L204:
 504:uIP/uip/uip.c **** 		if(uip_udp_conns[c].lport == htons(lastport))
 77027              		.loc 1 504 0
 77028 008c EB090014 		ld.sh	r9, r5[20]
 77029 0090 F8091900 		cp.h	r9, r12
 77030 0094 CC10     		breq .L199
 77031 0096 EB0A0024 		ld.sh	r10, r5[36]
 77032 009a F80A1900 		cp.h	r10, r12
 77033 009e CBC0     		breq .L199
 77034 00a0 CCBB     		rjmp    .L206
 77035              	.L201:
 514:uIP/uip/uip.c **** 		if(uip_udp_conns[c].lport == 0)
 77036              		.loc 1 514 0
 77037 00a2 5809     		cp.w	r9, 0
 77038 00a4 C041     		brne .L194
 77039 00a6 301C     		mov	r12, 1
 77040 00a8 1899     		mov	r9, r12
 77041 00aa CCFB     		rjmp    .L195
 77042              	.L194:
 77043 00ac 580A     		cp.w	r10, 0
 77044 00ae CD51     		brne .L203
 77045 00b0 CCAB     		rjmp    .L207
 77046 00b2 00000000 		.cpool
 77046      00000000 
 77046      00000000 
 77046      0000
 77047              		.align	2
 77048              	.L208:
 77049              	.LFE9:
 77051              		.global	uip_ethaddr
 77052              		.comm	uip_appdata,4,4
 77053              		.comm	uip_len,2,2
 77054              		.comm	uip_conn,4,4
 77055              		.comm	uip_conns,408,4
 77056              		.comm	uip_acc32,4,4
 77057              		.comm	uip_udp_conn,4,4
 77058              		.comm	uip_udp_conns,48,4
 77059              		.comm	uip_flags,1,1
 77060              		.comm	uip_hostaddr,4,2
 77061              		.comm	uip_netmask,4,2
 77062              		.comm	uip_draddr,4,2
 77063              		.comm	uip_sappdata,4,4
 77064              		.comm	uip_slen,2,2
 77065              		.comm	uip_listenports,2,2
 77066              		.comm	uip_connr,4,4
 77067              		.section	.bss
 77068              		.align	2
 77069              		.set	.LANCHOR0,. + 0
 77072              	ipid:
 77073 0000 0000     		.zero	2
 77076              	lastport:
 77077 0002 0000     		.zero	2
 77080              	c:
 77081 0004 00       		.zero	1
 77082 0005 000000   		.zero	3
 77085              	iss:
 77086 0008 00000000 		.zero	4
 77089              	tmp16:
 77090 000c 0000     		.zero	2
 77093              	opt:
 77094 000e 00       		.zero	1
 77097              	uip_ethaddr:
 77098 000f 00000000 		.zero	6
 77098      0000
 77387              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uip.c
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74070  .text.uip_setipid:00000000 uip_setipid
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74090  .text.uip_add32:00000000 uip_add32
                            *COM*:00000004 uip_acc32
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74163  .text.chksum:00000000 chksum
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74249  .text.uip_init:00000000 uip_init
                            *COM*:00000002 uip_listenports
                            *COM*:00000198 uip_conns
                            *COM*:00000030 uip_udp_conns
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74285  .text.uip_unlisten:00000000 uip_unlisten
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74322  .text.uip_listen:00000000 uip_listen
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74358  .text.uip_add_rcv_nxt:00000000 uip_add_rcv_nxt
                            *COM*:00000004 uip_conn
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74402  .text.htons:00000000 htons
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74418  .text.uip_connect:00000000 uip_connect
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74606  .text.uip_tcpchksum:00000000 uip_tcpchksum
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74667  .text.uip_ipchksum:00000000 uip_ipchksum
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74705  .text.uip_chksum:00000000 uip_chksum
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74735  .text.uip_send_P:00000000 uip_send_P
                            *COM*:00000002 uip_slen
                            *COM*:00000004 uip_sappdata
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74775  .text.uip_send:00000000 uip_send
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:74816  .text.uip_process:00000000 uip_process
                            *COM*:00000004 uip_appdata
                            *COM*:00000004 uip_connr
                            *COM*:00000001 uip_flags
                            *COM*:00000002 uip_len
                            *COM*:00000004 uip_udp_conn
                            *COM*:00000004 uip_hostaddr
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:76933  .text.uip_udp_new:00000000 uip_udp_new
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:77097  .bss:0000000f uip_ethaddr
                            *COM*:00000004 uip_netmask
                            *COM*:00000004 uip_draddr
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:77072  .bss:00000000 ipid
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:77076  .bss:00000002 lastport
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:77080  .bss:00000004 c
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:77085  .bss:00000008 iss
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:77089  .bss:0000000c tmp16
C:\Users\Laid\AppData\Local\Temp\ccvD4vif.s:77093  .bss:0000000e opt

UNDEFINED SYMBOLS
uip_buf
memcpy
NetSDR_appcall
NetSDR_UDP_appcall
